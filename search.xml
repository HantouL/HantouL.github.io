<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis高级入门篇</title>
      <link href="/2023/09/16/2023-9-17-Redis%E9%AB%98%E7%BA%A7%E7%AF%87%E5%85%A5%E9%97%A8/"/>
      <url>/2023/09/16/2023-9-17-Redis%E9%AB%98%E7%BA%A7%E7%AF%87%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis入门高级入门篇"><a href="#Redis入门高级入门篇" class="headerlink" title="Redis入门高级入门篇"></a>Redis入门高级入门篇</h1><h2 id="单点Redis的问题"><a href="#单点Redis的问题" class="headerlink" title="单点Redis的问题"></a>单点Redis的问题</h2><ul><li>数据丢失问题 —-Redis数据持久化</li><li>并发能力问题 —-主从集群,读写分离</li><li>故障恢复问题 —-Redis哨兵,健康监测/自动恢复</li><li>存储能力问题 —-搭建分片集群,利用插槽机制动态扩容</li></ul><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="1-RDB-Redis快照"><a href="#1-RDB-Redis快照" class="headerlink" title="1.RDB(Redis快照)"></a>1.RDB(Redis快照)</h2><p>RDB把内存中的所有数据都记录到磁盘中</p><h4 id="执行时机"><a href="#执行时机" class="headerlink" title="执行时机"></a><strong>执行时机</strong></h4><p>RDB持久化在四种情况下会执行：</p><ul><li>执行save命令</li><li>执行bgsave命令</li><li>Redis停机时</li><li>触发RDB条件时</li></ul><p><strong>1)save命令</strong></p><p>save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</p><p><strong>2)bgsave命令</strong></p><p>这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</p><p>其开始时会fork主进程得到子进程,子进程共享主进程内的内存数据,完成fork后读取内存数据并写入RDB文件</p><p> fork采用的是copy-on-write技术</p><ul><li><p>当主进程执行读操作时,访问共享内存</p></li><li><p>当主进程执行写操作时,则会拷贝一份数据再执行写操作</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309162036886.png" alt="image-20230916203610778"></p></li></ul><p><strong>3）停机时</strong></p><p>Redis停机时会自动执行一次save命令，实现RDB持久化。</p><p><strong>4）触发RDB条件</strong></p><p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save &quot;&quot; 则表示禁用RDB</span></span><br><span class="line"><span class="attr">save</span> <span class="string">900 1  </span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 10  </span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000 </span></span><br></pre></td></tr></table></figure><p>RDB的其它配置也可以在redis.conf文件中设置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span></span><br><span class="line"><span class="attr">rdbcompression</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># RDB文件名称</span></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">dump.rdb  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 文件保存的路径目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">./ </span></span><br></pre></td></tr></table></figure><h3 id="RDB缺点"><a href="#RDB缺点" class="headerlink" title="RDB缺点"></a>RDB缺点</h3><ul><li>执行间隔长,两次RDB之间数据写入有丢失风险</li><li>fork子进程,压缩,写出RDB文件都需要消耗资源</li></ul><h2 id="2-AOF-追加文件"><a href="#2-AOF-追加文件" class="headerlink" title="2.AOF(追加文件)"></a>2.AOF(追加文件)</h2><p>Redis处理的每一个写命令都会记录在AOF文件,所以看做是某种命令日志文件</p><h3 id="AOF配置"><a href="#AOF配置" class="headerlink" title="AOF配置"></a>AOF配置</h3><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否开启AOF功能，默认是no</span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># AOF文件的名称</span></span><br><span class="line"><span class="attr">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span></span><br></pre></td></tr></table></figure><p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示每执行一次写命令，立即记录到AOF文件</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">always </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">everysec </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">no</span></span><br></pre></td></tr></table></figure><p>三种策略的对比:</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309162043730.png" alt="image-20230916204345695"></p><h3 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h3><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309162049263.png" alt="image-20230916204916235"></p><p>如图，AOF原本有三个命令，但是<code>set num 123 和 set num 666</code>都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。</p><p>所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p><p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AOF文件比上次文件 增长超过多少百分比则触发重写</span></span><br><span class="line"><span class="attr">auto-aof-rewrite-percentage</span> <span class="string">100</span></span><br><span class="line"><span class="comment"># AOF文件体积最小多大以上才触发重写 </span></span><br><span class="line"><span class="attr">auto-aof-rewrite-min-size</span> <span class="string">64mb </span></span><br></pre></td></tr></table></figure><h2 id="RDB与AOF对比"><a href="#RDB与AOF对比" class="headerlink" title="RDB与AOF对比"></a>RDB与AOF对比</h2><p>在实际应用中要结合优缺点<strong>混合</strong>使用</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309162050972.png" alt="image-20230916205029924"></p><h2 id="Redis主从"><a href="#Redis主从" class="headerlink" title="Redis主从"></a>Redis主从</h2><p>单节点redis的并发能力是有上限的,需要通过搭建主从集群实现读写分离</p><h3 id="主从间数据同步原理"><a href="#主从间数据同步原理" class="headerlink" title="主从间数据同步原理"></a>主从间数据同步原理</h3><ul><li>主从第一次同步是<strong>全量同步</strong></li></ul><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309162127955.png" alt="image-20230916212735891"></p><p>master是如何判断是否是第一次同步呢?</p><p>​    <strong>Replication Id</strong>:其是数据集的id,每个master都有唯一的repliid,slave则会集成master结点的replid</p><p>​    <strong>offset</strong>:偏移量,随着repl_backlog中数据增多而增大</p><p>所以slave的数据同步必须要向master生命自己的reliid和offset以供master判断需要同步哪些数据</p><ul><li>slave重启后同步,执行<strong>增量同步</strong></li></ul><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309162145817.png" alt="image-20230916214538754"></p><p><strong>注意:repl_baklog大小有上限,写满后会覆盖最早的数据,如果slave断开时间过久,导致尚未被备份的数据被覆盖,则无法基于log做增量同步,只能再次进行全量同步</strong></p><h4 id="Redis主从集群的优化"><a href="#Redis主从集群的优化" class="headerlink" title="Redis主从集群的优化"></a>Redis主从集群的优化</h4><ul><li>在master中配置repl-diskless-sync yse启动无磁盘复制,避免全量同步时的磁盘io</li><li>Redis单节点上的内存占用不要太大,减少RDB导致的过多磁盘IO</li><li>适当提高repl_baklog的大小,发现从节点宕机时尽快实现故障恢复,尽量避免进行全量恢复</li><li>限制一个master上的slave数量,如果slave确实多,可以采用主-从-从链式(从节点A是相对于其从节点B的master结点)结构,减轻master压力</li></ul><h2 id="Redis哨兵"><a href="#Redis哨兵" class="headerlink" title="Redis哨兵"></a>Redis哨兵</h2><h3 id="哨兵-sentinel-的作用"><a href="#哨兵-sentinel-的作用" class="headerlink" title="哨兵(sentinel)的作用"></a>哨兵(sentinel)的作用</h3><ul><li><strong>监控</strong>:Sentinel会不断检查master和slave是否按照预期工作</li><li><strong>自动故障恢复</strong>:如果master故障,Sentinel会将一个slave提升为master,当故障实例恢复后也是以新的master为主</li><li><strong>通知</strong>:Sentinel充当Redis客户端的服务发现来源,当集群发生故障转移时,会将最新的消息推送给Redis的客户端</li></ul><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309171228366.png" alt="image-20230917122803281"></p><h3 id="服务状态监控"><a href="#服务状态监控" class="headerlink" title="服务状态监控"></a>服务状态监控</h3><p>Sentinel基于心跳机制检测服务状态,每隔1s向集群的每个实例发送ping指令</p><ul><li>主观下线:如果某sentinel节点发现某实例未在规定时间响应,则认定该实例主观下线</li><li>客观下线:若超过指定数量quorum的sentinel都认为该实例主观下线,则该实例客观下线(quorum值最好超过sentinel实例数量的一半)</li></ul><h3 id="如何选举新的master"><a href="#如何选举新的master" class="headerlink" title="如何选举新的master"></a>如何选举新的master</h3><p><strong>选举依据</strong></p><ul><li>首先判断slave与master结点断开时间的长短,如果超过指定值,就会排除该slave结点</li><li>然后判断slave结点的slave-priority值,越小优先局越高,若为0则用不参加选举</li><li>若slave-priority值一样,则判断slave结点的offset值,越大说明数据越新,优先级越高</li></ul><h3 id="如何实现故障转移"><a href="#如何实现故障转移" class="headerlink" title="如何实现故障转移"></a>如何实现故障转移</h3><ul><li>选定一个slave作为新的master,执行slaveof no one</li><li>让所有节点执行slaveof 新master</li><li>修改故障节点配置,添加slaveof 新master</li></ul><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309171234367.png" alt="image-20230917123410283"></p><h2 id="Redis分片集群"><a href="#Redis分片集群" class="headerlink" title="Redis分片集群"></a>Redis分片集群</h2><h3 id="分片集群结构"><a href="#分片集群结构" class="headerlink" title="分片集群结构"></a>分片集群结构</h3><p>主从和哨兵可以解决高可用,高并发读的问题,但是依然没有解决海量数据存储和高并发写的问题</p><p>使用分片集群可以解决上述问题,其特征如下</p><ul><li>集群中有多个master,每个master保存不同数据</li><li>每个master都可以拥有多个slave结点</li><li>master之间通过ping检测彼此健康状态</li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>seata入门笔记</title>
      <link href="/2023/09/14/2023-9-14-seata%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/09/14/2023-9-14-seata%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="分布式事务理论基础"><a href="#分布式事务理论基础" class="headerlink" title="分布式事务理论基础:"></a>分布式事务理论基础:</h2><h4 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理:"></a>CAP定理:</h4><p>分布式系统结点通过网络连接,一定会出现分区问题P,这时系统的一致性C和可用性A就无法同时满足</p><h4 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论:"></a>BASE理论:</h4><p>是对CAP的一种解决思路,包括基本可用BA(允许损失部分可用来保证核心可用),软状态SS(中间状态),和最终一致性(在经过软状态后最终数据一致)</p><h4 id="解决分布式事务问题的思想"><a href="#解决分布式事务问题的思想" class="headerlink" title="解决分布式事务问题的思想:"></a>解决分布式事务问题的思想:</h4><p>AP模式:各个子事务分别提交,允许结果不一致,通过弥补措施实现最后结果一致</p><p>CP模式:各个子事务执行后相互等待,同时提交同时回滚,实现强一致,但在等待的过程中事务会变为弱可用状态</p><h4 id="解决分布式事务问题的模型"><a href="#解决分布式事务问题的模型" class="headerlink" title="解决分布式事务问题的模型:"></a>解决分布式事务问题的模型:</h4><p>全局事务:指整个分布式事务</p><p>分支事务:分布式事务中包含的每个子系统的事务</p><h3 id="初识Seata"><a href="#初识Seata" class="headerlink" title="初识Seata"></a>初识<a href="https://seata.io/">Seata</a></h3><h4 id="Seata中重要的三个角色-Seata架构"><a href="#Seata中重要的三个角色-Seata架构" class="headerlink" title="Seata中重要的三个角色/Seata架构"></a>Seata中重要的三个角色/Seata架构</h4><ul><li><p>事务协调者TC:维护全局和分支事务的状态</p></li><li><p>事务管理器TM:定义全局事务的范围,开始全局事务,提交或回滚全局事务</p></li><li><p>资源管理器RM:管理分支事务处理的资源,于TC交谈来注册分支事务和报告分支事务的状态,并驱动分支事务或回滚</p></li></ul><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309141708797.png" alt="image-20230914170846702"></p><h3 id="部署TC服务"><a href="#部署TC服务" class="headerlink" title="部署TC服务"></a>部署TC服务</h3><h4 id="1-修改配置"><a href="#1-修改配置" class="headerlink" title="1.修改配置"></a>1.修改配置</h4><p>修改conf目录下的registry.conf文件：</p><p>内容如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">registry</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">  # tc服务的注册中心类，这里选择nacos，也可以是eureka、zookeeper等</span></span><br><span class="line">  <span class="attr">type</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">nacos</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">    # seata tc 服务注册到 nacos的服务名称，可以自定义</span></span><br><span class="line">    <span class="attr">application</span> = <span class="string">&quot;seata-tc-server&quot;</span></span><br><span class="line">    <span class="attr">serverAddr</span> = <span class="string">&quot;127.0.0.1:8848&quot;</span></span><br><span class="line">    <span class="attr">group</span> = <span class="string">&quot;DEFAULT_GROUP&quot;</span></span><br><span class="line">    <span class="attr">namespace</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">cluster</span> = <span class="string">&quot;SH&quot;</span></span><br><span class="line">    <span class="attr">username</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    <span class="attr">password</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">config</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">  # 读取tc服务端的配置文件的方式，这里是从nacos配置中心读取，这样如果tc是集群，可以共享配置</span></span><br><span class="line">  <span class="attr">type</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line"><span class="comment">  # 配置nacos地址等信息</span></span><br><span class="line">  <span class="attr">nacos</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">serverAddr</span> = <span class="string">&quot;127.0.0.1:8848&quot;</span></span><br><span class="line">    <span class="attr">namespace</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">group</span> = <span class="string">&quot;SEATA_GROUP&quot;</span></span><br><span class="line">    <span class="attr">username</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    <span class="attr">password</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    <span class="attr">dataId</span> = <span class="string">&quot;seataServer.properties&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="2-在nacos添加配置"><a href="#2-在nacos添加配置" class="headerlink" title="2.在nacos添加配置"></a>2.在nacos添加配置</h4><p>特别注意，为了让tc服务的集群可以共享配置，我们选择了nacos作为统一配置中心。因此服务端配置文件seataServer.properties文件需要在nacos中配好。</p><p>配置内容如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据存储方式，db代表数据库</span></span><br><span class="line"><span class="attr">store.mode</span>=<span class="string">db</span></span><br><span class="line"><span class="attr">store.db.datasource</span>=<span class="string">druid</span></span><br><span class="line"><span class="attr">store.db.dbType</span>=<span class="string">mysql</span></span><br><span class="line"><span class="attr">store.db.driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">store.db.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/seata?useUnicode=true&amp;rewriteBatchedStatements=true</span></span><br><span class="line"><span class="attr">store.db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">store.db.password</span>=<span class="string">1234</span></span><br><span class="line"><span class="attr">store.db.minConn</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">store.db.maxConn</span>=<span class="string">30</span></span><br><span class="line"><span class="attr">store.db.globalTable</span>=<span class="string">global_table</span></span><br><span class="line"><span class="attr">store.db.branchTable</span>=<span class="string">branch_table</span></span><br><span class="line"><span class="attr">store.db.queryLimit</span>=<span class="string">100</span></span><br><span class="line"><span class="attr">store.db.lockTable</span>=<span class="string">lock_table</span></span><br><span class="line"><span class="attr">store.db.maxWait</span>=<span class="string">5000</span></span><br><span class="line"><span class="comment"># 事务、日志等配置</span></span><br><span class="line"><span class="attr">server.recovery.committingRetryPeriod</span>=<span class="string">1000</span></span><br><span class="line"><span class="attr">server.recovery.asynCommittingRetryPeriod</span>=<span class="string">1000</span></span><br><span class="line"><span class="attr">server.recovery.rollbackingRetryPeriod</span>=<span class="string">1000</span></span><br><span class="line"><span class="attr">server.recovery.timeoutRetryPeriod</span>=<span class="string">1000</span></span><br><span class="line"><span class="attr">server.maxCommitRetryTimeout</span>=<span class="string">-1</span></span><br><span class="line"><span class="attr">server.maxRollbackRetryTimeout</span>=<span class="string">-1</span></span><br><span class="line"><span class="attr">server.rollbackRetryTimeoutUnlockEnable</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">server.undo.logSaveDays</span>=<span class="string">7</span></span><br><span class="line"><span class="attr">server.undo.logDeletePeriod</span>=<span class="string">86400000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 客户端与服务端传输方式</span></span><br><span class="line"><span class="attr">transport.serialization</span>=<span class="string">seata</span></span><br><span class="line"><span class="attr">transport.compressor</span>=<span class="string">none</span></span><br><span class="line"><span class="comment"># 关闭metrics功能，提高性能</span></span><br><span class="line"><span class="attr">metrics.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">metrics.registryType</span>=<span class="string">compact</span></span><br><span class="line"><span class="attr">metrics.exporterList</span>=<span class="string">prometheus</span></span><br><span class="line"><span class="attr">metrics.exporterPrometheusPort</span>=<span class="string">9898</span></span><br></pre></td></tr></table></figure><p>==其中的数据库地址、用户名、密码都需要修改成自己的数据库信息==</p><h4 id="3-创建数据库表"><a href="#3-创建数据库表" class="headerlink" title="3.创建数据库表"></a>3.创建数据库表</h4><p>特别注意：tc服务在管理分布式事务时，需要记录事务相关数据到数据库中，你需要提前创建好这些表。</p><p>新建一个名为seata的数据库，运行资料提供的sql文件：</p><p>这些表主要记录全局事务、分支事务、全局锁信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">SET NAMES utf8mb4;</span><br><span class="line">SET FOREIGN_KEY_CHECKS = 0;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- 分支事务表</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `branch_table`;</span><br><span class="line">CREATE TABLE `branch_table`  (</span><br><span class="line">  `branch_id` bigint(20) NOT NULL,</span><br><span class="line">  `xid` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</span><br><span class="line">  `transaction_id` bigint(20) NULL DEFAULT NULL,</span><br><span class="line">  `resource_group_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `resource_id` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `branch_type` varchar(8) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `status` tinyint(4) NULL DEFAULT NULL,</span><br><span class="line">  `client_id` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `application_data` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `gmt_create` datetime(6) NULL DEFAULT NULL,</span><br><span class="line">  `gmt_modified` datetime(6) NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`branch_id`) USING BTREE,</span><br><span class="line">  INDEX `idx_xid`(`xid`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- 全局事务表</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `global_table`;</span><br><span class="line">CREATE TABLE `global_table`  (</span><br><span class="line">  `xid` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</span><br><span class="line">  `transaction_id` bigint(20) NULL DEFAULT NULL,</span><br><span class="line">  `status` tinyint(4) NOT NULL,</span><br><span class="line">  `application_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `transaction_service_group` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `transaction_name` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `timeout` int(11) NULL DEFAULT NULL,</span><br><span class="line">  `begin_time` bigint(20) NULL DEFAULT NULL,</span><br><span class="line">  `application_data` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `gmt_create` datetime NULL DEFAULT NULL,</span><br><span class="line">  `gmt_modified` datetime NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`xid`) USING BTREE,</span><br><span class="line">  INDEX `idx_gmt_modified_status`(`gmt_modified`, `status`) USING BTREE,</span><br><span class="line">  INDEX `idx_transaction_id`(`transaction_id`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;</span><br><span class="line"></span><br><span class="line">SET FOREIGN_KEY_CHECKS = 1;</span><br></pre></td></tr></table></figure><h4 id="4-启动TC服务"><a href="#4-启动TC服务" class="headerlink" title="4.启动TC服务"></a>4.启动TC服务</h4><p>进入bin目录，运行其中的seata-server.bat即可,启动成功后，seata-server应该已经注册到nacos注册中心了。</p><p>打开浏览器，访问nacos地址：<a href="http://localhost:8848，然后进入服务列表页面，可以看到seata-tc-server的信息">http://localhost:8848，然后进入服务列表页面，可以看到seata-tc-server的信息</a></p><h3 id="微服务集成Seata"><a href="#微服务集成Seata" class="headerlink" title="微服务集成Seata"></a>微服务集成Seata</h3><h4 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--版本较低，1.3.0，因此排除--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--seata starter 采用1.4.2版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;seata.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-修改配置文件-让微服务通过注册中心找到seata-tc-server"><a href="#2-修改配置文件-让微服务通过注册中心找到seata-tc-server" class="headerlink" title="2.修改配置文件,让微服务通过注册中心找到seata-tc-server"></a>2.修改配置文件,让微服务通过注册中心找到seata-tc-server</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">registry:</span> <span class="comment"># TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址</span></span><br><span class="line">    <span class="comment"># 参考tc服务自己的registry.conf中的配置</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span> <span class="comment"># tc</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-tc-server</span> <span class="comment"># tc服务在nacos中的服务名称</span></span><br><span class="line">      <span class="attr">cluster:</span> <span class="string">SH</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">seata-demo</span> <span class="comment"># 事务组，根据这个获取tc服务的cluster名称</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span> <span class="comment"># 事务组与TC服务cluster的映射关系</span></span><br><span class="line">      <span class="attr">seata-demo:</span> <span class="string">SH</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/7/20 算法每日一题</title>
      <link href="/2023/07/20/2023-7-20-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/07/20/2023-7-20-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目1-小红的环形字符串"><a href="#题目1-小红的环形字符串" class="headerlink" title="题目1:小红的环形字符串"></a>题目1:<a href="https://ac.nowcoder.com/acm/contest/60456/A">小红的环形字符串</a></h2><p>小红拿到了一个环形字符串s。所谓环形字符串，指首尾相接的字符串。<br>小红想顺时针截取其中一段连续子串正好等于t，一共有多少种截法？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">2</span>*N],s1[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;s1;</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//直接倍增构造一个伪环形串</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len;i&lt;<span class="number">2</span>*len;i++) s[i]=s[i-len];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="built_in">strlen</span>(s1);j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i+j]!=s1[j])</span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2-相邻不同数字的标记"><a href="#题目2-相邻不同数字的标记" class="headerlink" title="题目2:相邻不同数字的标记"></a>题目2:<a href="https://ac.nowcoder.com/acm/contest/60456/B">相邻不同数字的标记</a></h2><p>小红拿到了一个数组，每个数字被染成了红色或蓝色。</p><p>小红有很多次操作，每次操作可以选择两个相邻的不同颜色的数字标记，并获得它们数字之和的得分。已经被标记的数字无法再次标记。<br>小红想知道，自己最多能获得多少分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dp[i]表示就计算到i时的最大得分</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="type">char</span> c=s[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;t&lt;n;t++)</span><br><span class="line">        <span class="keyword">if</span>(c!=s[t])</span><br><span class="line">        &#123;</span><br><span class="line">            dp[t]=a[t]+a[t<span class="number">-1</span>];</span><br><span class="line">            c=s[t];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    t++;</span><br><span class="line">    <span class="keyword">for</span>(;t&lt;n;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c==s[t]) dp[t]=dp[t<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            c=s[t];</span><br><span class="line">            dp[t]=<span class="built_in">max</span>(dp[t<span class="number">-1</span>],dp[t<span class="number">-2</span>]+a[t]+a[t<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/7/18 算法每日一题</title>
      <link href="/2023/07/18/2023-7-18-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/07/18/2023-7-18-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目1-moon"><a href="#题目1-moon" class="headerlink" title="题目1:moon"></a>题目1:<a href="https://ac.nowcoder.com/acm/contest/58833/B">moon</a></h2><h5 id="你搁这出脑筋急转弯呢T-T"><a href="#你搁这出脑筋急转弯呢T-T" class="headerlink" title="你搁这出脑筋急转弯呢T_T"></a>你搁这出脑筋急转弯呢T_T</h5><p>给出一棵以 1 为根的有根树，一开始每个节点都是白色的。David 和 Adam 在树上博弈，David 先手，每次每个人需要选择树上一个白色的点，并把这个点以及其到根路径上的所有点染成黑色。无法操作的人输。</p><p>假定两人均绝顶聪明，你需要求出谁会获胜。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">// using namespace std;</span></span><br><span class="line"><span class="comment">// const int N=1e5+10;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int a[N]=&#123;0&#125;;</span></span><br><span class="line"><span class="comment">// bool st[N]=&#123;false&#125;;</span></span><br><span class="line"><span class="comment">// int n;</span></span><br><span class="line"><span class="comment">// int ans=0;//操作次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void fun(int v)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     if(a[v]!=-1&amp;&amp;!st[v])</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         n--;</span></span><br><span class="line"><span class="comment">//         st[v]==true;</span></span><br><span class="line"><span class="comment">//         n++;</span></span><br><span class="line"><span class="comment">//         fun(a[v]);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int main()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     a[1]=-1;</span></span><br><span class="line"><span class="comment">//     scanf(&quot;%d&quot;,&amp;n);</span></span><br><span class="line"><span class="comment">//     for(int i=2;i&lt;=n-1;i++) scanf(&quot;%d&quot;,&amp;a[i]);</span></span><br><span class="line"><span class="comment">//     fun()</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//David先手必胜</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;David&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2-小红的基环树"><a href="#题目2-小红的基环树" class="headerlink" title="题目2:小红的基环树"></a>题目2:<a href="https://ac.nowcoder.com/acm/contest/60282/A">小红的基环树</a></h2><h4 id="脑筋急转弯二号"><a href="#脑筋急转弯二号" class="headerlink" title="脑筋急转弯二号"></a>脑筋急转弯二号</h4><p>定义基环树为n个节点、n条边的、没有自环和重边的无向连通图。<br>定义一个图的直径是任意两点最短路的最大值。<br>小红想知道，n个节点构成的所有基环树中，最小的直径是多少？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">if</span>(n!=<span class="number">3</span>)cout&lt;&lt;<span class="number">2</span>&lt;&lt;endl;   </span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目3-小红的回文串"><a href="#题目3-小红的回文串" class="headerlink" title="题目3:小红的回文串"></a>题目3:<a href="https://ac.nowcoder.com/acm/contest/60282/B">小红的回文串</a></h2><p>小红拿到了一个字符串，字符串仅由小写字母和’?’字符组成。<br>小红会将每个’?’替换成任意小写字母。她希望最终字符串变成回文串。<br>小红想知道，有多少种不同的方案？答案请对1e9+7取模。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>, MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = s.<span class="built_in">length</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[l] == <span class="string">&#x27;?&#x27;</span> || s[r] == <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[l]==s[r]) ans *= <span class="number">26</span>,ans%=MOD;<span class="comment">//两个?</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[l] != s[r])</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        l++, r--;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/7/14 算法每日一题</title>
      <link href="/2023/07/14/2023-7-14-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/07/14/2023-7-14-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-游游的数组染色"><a href="#题目-游游的数组染色" class="headerlink" title="题目:游游的数组染色"></a>题目:<a href="https://ac.nowcoder.com/acm/contest/60245/B">游游的数组染色</a></h2><p>游游拿到了一个数组，其中一些数被染成红色，一些数被染成蓝色。<br>游游想知道，取两个不同颜色的数，且它们的数值相等，有多少种不同的取法？<br>我们定义，两种取法如果取的某个数在原数组的位置不同，则定义为不同的取法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[N];</span><br><span class="line"><span class="type">char</span> c[N];</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m[<span class="number">2</span>];<span class="comment">//R对应0,B对应1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += m[c[i] == <span class="string">&#x27;B&#x27;</span>][a[i]];</span><br><span class="line">        m[c[i] == <span class="string">&#x27;R&#x27;</span>][a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/7/8 算法每日一题</title>
      <link href="/2023/07/08/2023-7-8-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/07/08/2023-7-8-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-方豆子"><a href="#题目-方豆子" class="headerlink" title="题目:方豆子"></a>题目:<a href="https://ac.nowcoder.com/acm/contest/60063/C">方豆子</a></h2><p>阿宁最近对吃豆子感兴趣，阿宁想要用程序输出一下，但是图形化对于阿宁来说太难。因此他决定用字符，并且是方形的模样。</p><p>给一个正整数n，输出n级好豆子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">一级好豆子：</span><br><span class="line">******</span><br><span class="line">******</span><br><span class="line">******</span><br><span class="line">***...</span><br><span class="line">***...</span><br><span class="line">***...</span><br><span class="line"> </span><br><span class="line">一级坏豆子：</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">...***</span><br><span class="line">...***</span><br><span class="line">...***</span><br><span class="line"> </span><br><span class="line">二级好豆子：</span><br><span class="line">一级坏豆子 一级坏豆子</span><br><span class="line">一级坏豆子 一级好豆子</span><br><span class="line"> </span><br><span class="line">二级坏豆子：</span><br><span class="line">一级好豆子 一级好豆子</span><br><span class="line">一级好豆子 一级坏豆子</span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">x级好豆子：</span><br><span class="line">x-1级坏豆子 x-1级坏豆子</span><br><span class="line">x-1级坏豆子 x-1级好豆子</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">x级坏豆子：</span><br><span class="line">x-1级好豆子 x-1级好豆子</span><br><span class="line">x-1级好豆子 x-1级坏豆子</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ans[<span class="number">1</span>&lt;&lt;<span class="number">12</span>][<span class="number">1</span>&lt;&lt;<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> n,<span class="type">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当n等于0时，表示到达最小级别的豆子，需要进行填充操作。根据flag的值，对应填充好豆子或者坏豆子的图案。</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="comment">//好豆子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;x+<span class="number">3</span>;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=y;j&lt;y+<span class="number">3</span>;j++)</span><br><span class="line">                    ans[i][j]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt; x + <span class="number">3</span>; i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = y; j &lt; y + <span class="number">3</span>; j++)</span><br><span class="line">                    ans[i][j] = <span class="string">&#x27;*&#x27;</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) t=t&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    t=t*<span class="number">3</span>;</span><br><span class="line">    <span class="comment">//当前级别的豆子划分为四个部分，并以不同的方式填充每个部分。其中，flag的值会在每次递归调用时进行取反。</span></span><br><span class="line">    <span class="built_in">cal</span>(x,y,n<span class="number">-1</span>,flag^<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cal</span>(x,y+t,n<span class="number">-1</span>,flag^<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cal</span>(x+t,y,n<span class="number">-1</span>,flag^<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cal</span>(x+t,y+t,n<span class="number">-1</span>,flag);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cal</span>(<span class="number">0</span>,<span class="number">0</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) t&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    t*=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t;i++)</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/7/7 算法每日一题</title>
      <link href="/2023/07/07/2023-7-7-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/07/07/2023-7-7-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-AcWing-3326-最大硬币数"><a href="#题目-AcWing-3326-最大硬币数" class="headerlink" title="题目:AcWing 3326.最大硬币数"></a>题目:<a href="https://www.acwing.com/problem/content/3329/">AcWing 3326.最大硬币数</a></h2><p>Mike 有一个 N 行 N 列的方格矩阵。</p><p>位于第 i 行第 j 列的方格的位置坐标表示为 (i,j)。矩阵左上角方格的坐标即为 (1,1)。每个方格中都包含一定数量的硬币，Mike 只有到达一个方格内时，方可收集方格中的硬币。Ci,j 表示第 i 行第 j 列的方格中的硬币数量。</p><p>当 Mike 处于方格 (i,j) 时，他可以选择移动至方格 (i−1,j−1) 或方格 (i+1,j+1) 中，前提是所选择的方格位于矩阵边界内，且之前没有到达过。</p><p>Mike 可以选择从任意方格开始移动，也可以选择在移动至任意方格时结束移动。Mike 希望尽可能多的收集硬币。</p><p>请帮助他确定他可以收集的最大硬币数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> c[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">getans</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a&lt;=n&amp;&amp;b&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        max+=c[a][b];</span><br><span class="line">        a++,b++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=T;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;c[i][j]);</span><br><span class="line">                </span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,<span class="built_in">getans</span>(i,<span class="number">1</span>));</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,<span class="built_in">getans</span>(<span class="number">1</span>,i));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %lld\n&quot;</span>, t, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/7/6 算法每日一题</title>
      <link href="/2023/07/06/2023-7-6-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/07/06/2023-7-6-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目1-AcWing-3325-Kick-Start"><a href="#题目1-AcWing-3325-Kick-Start" class="headerlink" title="题目1:AcWing 3325.Kick_Start"></a>题目1:<a href="https://www.acwing.com/problem/content/3328/">AcWing 3325.Kick_Start</a></h2><p>Ksenia 非常喜欢读书，因此每天她都会从自己最喜欢的书中选取一段内容进行阅读，然后再开始她早晨的其他活动。</p><p>一段内容可以看作是整个文本中的一个子字符串。</p><p>Ksenia 有点迷信，她坚信如果阅读的这段内容是以字符串 KICK 开头，然后中间包含 0 个或更多个字符，最后以字符串 START 结尾，即使这段内容没什么意义，她的一天也会非常的幸运。</p><p>给定这本书的全部文本内容，请你数一数在这本书变得破旧不堪，Ksenia 不得不再买新书之前，共有多少个幸运片段可供她阅读。</p><p>只要两个片段的起始位置或结束位置不同，就认为这两个片段是不同的，即使它们包含的内容完全相同。</p><p>还需注意，不同片段之间可能会有重叠部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findLucky</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> kick = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>()<span class="number">-4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//i的变化符合kmp思想</span></span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">substr</span>(i, <span class="number">4</span>) == <span class="string">&quot;KICK&quot;</span>) kick ++, i += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.<span class="built_in">substr</span>(i, <span class="number">5</span>) == <span class="string">&quot;START&quot;</span>) ans += kick, i += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=T;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">findLucky</span>(s);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>,t,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2-AcWing-4114-垃圾桶"><a href="#题目2-AcWing-4114-垃圾桶" class="headerlink" title="题目2:AcWing 4114.垃圾桶"></a>题目2:<a href="https://www.acwing.com/problem/content/4117/">AcWing 4114.垃圾桶</a></h2><p>一条很长的街道上有 N 个房子。</p><p>第一个房子在位置 1，第二个房子在位置 2，以此类推。</p><p>任意一对房子 i 和 j 之间的距离为 |i−j|。</p><p>一些房子的位置处有垃圾桶。每个房子的主人都要倒垃圾。如果自己房子前面有垃圾桶，则无需移动，直接倒垃圾即可。</p><p>如果自己房子前面没有垃圾桶，则前往距离自己最近的垃圾桶处倒垃圾，如果这样的垃圾桶不唯一，则任意前往一个即可。</p><p>请计算，所有房子的主人倒垃圾需要行走的总距离之和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> l[N], r[N];<span class="comment">//分别表示该住户左侧和右侧最近的垃圾桶,若自带垃圾桶则为0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>; t &lt;= T; t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, s + <span class="number">1</span>);</span><br><span class="line">        l[<span class="number">0</span>] = <span class="number">-1e6</span>, r[n + <span class="number">1</span>] = <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            l[i] = s[i] == <span class="string">&#x27;1&#x27;</span> ? i : l[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">            r[i] = s[i] == <span class="string">&#x27;1&#x27;</span> ? i : r[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            ans += <span class="built_in">min</span>(i - l[i], r[i] - i);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %lld\n&quot;</span>, t, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/7/5 算法每日一题</title>
      <link href="/2023/07/05/2023-7-5-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/07/05/2023-7-5-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-AcWing-3748-递增子串"><a href="#题目-AcWing-3748-递增子串" class="headerlink" title="题目:AcWing 3748.递增子串"></a>题目:<a href="https://www.acwing.com/problem/content/3751/">AcWing 3748.递增子串</a></h2><p>的朋友约翰刚刚度假归来，他迫不及待地想要跟你分享他了解到的关于字符串的一个新性质。</p><p>他了解到，如果一个长度为 L 的大写字母构成的字符串 C，满足对于每对索引 i,j（1≤i&lt;j≤L，索引编号 1∼L），位置 i 处的字符均小于位置 j 处的字符，则该字符串是严格递增的。</p><p>例如，字符串 ABC 和 ADF 是严格递增的，而字符串 ACC 和 FDA 则不是。</p><p>在教给你这个关于字符串的新性质后，他打算考一考你：</p><p>给定一个长度为 N 的字符串 S，请你计算对于每个位置 i（1≤i≤N），以该位置结束的最长严格递增子串的长度是多少？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=T;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;n,s);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, t);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,f=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>||s[i<span class="number">-1</span>]&lt;s[i]) f++;</span><br><span class="line">            <span class="keyword">else</span> f=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,f);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/7/4 算法每日一题</title>
      <link href="/2023/07/04/2023-7-4-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/07/04/2023-7-4-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-AcWing-4118-狗和猫"><a href="#题目-AcWing-4118-狗和猫" class="headerlink" title="题目:AcWing 4118.狗和猫"></a>题目:<a href="https://www.acwing.com/problem/content/4121/">AcWing 4118.狗和猫</a></h2><p>你在动物收容所工作，负责喂养动物。</p><p>你一共准备了 D 份狗粮和 C 份猫粮。一共有 N 只动物排队等候用餐，有的是狗，有的是猫。当然，也有可能全都是狗或者全都是猫。</p><p>我们可以用一个长度为 N 的由大写字母 C 和 D 组成的字符串 S 来表示队列中猫狗的顺序。</p><p>如果队列中第 i 只动物是猫，则第 i 个字符为 C。如果队列中第 i 只动物是狗，则第 i 个字符为 D。</p><p>动物们严格按照排队顺序依次进食。每只狗吃一份狗粮，每只猫吃一份猫粮。</p><p>此外，你还有额外的猫粮。每当一条狗吃完一份狗粮，你就会为猫多提供 M 份猫粮。</p><p>每只动物都只会在排在其前面的所有动物都进食完毕后，才肯进食。这也就意味着，当轮到某只动物进食，但是却没有相应的食物时，它和排在它后面的所有动物都会因此无法进食。</p><p>请问，在这种情况下，队列中的所有狗能否都得到喂食。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=T;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> N,D,C,M;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;N,&amp;D,&amp;C,&amp;M);</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;<span class="comment">//狗前的猫数量</span></span><br><span class="line">        <span class="type">int</span> cat=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;D&#x27;</span>) q.<span class="built_in">push</span>(cat),cat=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> cat++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//q.push(cat); 只需要管的狗都喂了没,所以不需要管尾部的猫</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((C-q.<span class="built_in">front</span>())&gt;=<span class="number">0</span>&amp;&amp;D&gt;=<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                D--;</span><br><span class="line">                C+=M;</span><br><span class="line">                C-=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: YES\n&quot;</span>,t);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: NO\n&quot;</span>,t);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/7/3 算法每日一题</title>
      <link href="/2023/07/03/2023-7-3-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/07/03/2023-7-3-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目1-AcWing-4443-无限区域"><a href="#题目1-AcWing-4443-无限区域" class="headerlink" title="题目1:AcWing 4443.无限区域"></a>题目1:<a href="https://www.acwing.com/problem/content/4446/">AcWing 4443.无限区域</a></h2><p>给定一个无限大的二维平面，设点 S 为该平面的中心点。</p><p>设经过点 S 的垂直方向的直线为 P，如果直线 P 是一个圆的切线，且切点恰好为点 S，那么：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果该圆位于直线 P 的右侧，则称之为右圆。</span><br><span class="line">如果该圆位于直线 P 的左侧，则称之为左圆。</span><br></pre></td></tr></table></figure></p><p>现在，给定三个整数 R,A,B，你需要按照右圆、左圆、右圆、左圆…的顺序不断画圆，具体要求如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一个右圆的半径等于 R。</span><br><span class="line">每个左圆的半径等于你画的上一个圆的半径乘以 A。</span><br><span class="line">每个右圆（第一个除外）的半径等于你画的上一个圆的半径除以 B（向下取整）。</span><br><span class="line">当你要画的圆的半径等于 0 时，绘画停止。</span><br></pre></td></tr></table></figure></p><p>请你计算，所有画出的圆的面积之和。题目保证绘画会在有限数量的步骤后停止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.1415927</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//画画顺序 右 左 右 左</span></span><br><span class="line"><span class="comment">//当出现画圆半径为0的情况,则退出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>; t &lt;= T; t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> r, a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>, &amp;r, &amp;a, &amp;b);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = r*r;</span><br><span class="line">        <span class="comment">//一次执行左右两个操作,因为就算在中途半径清零了,对结果也没有影响</span></span><br><span class="line">        <span class="keyword">while</span>(r &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r *= a;</span><br><span class="line">            ans += r*r;</span><br><span class="line">            r /= b;</span><br><span class="line">            ans += r*r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %lf\n&quot;</span>,t,PI*ans);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2-AcWing-3752-更小的字符串"><a href="#题目2-AcWing-3752-更小的字符串" class="headerlink" title="题目2:AcWing 3752.更小的字符串"></a>题目2:<a href="https://www.acwing.com/problem/content/3755/">AcWing 3752.更小的字符串</a></h2><p>给定一个整数 K 和一个长度为 N 的字符串 S。</p><p>已知，字符串 S 是由前 K 个小写字母组成。</p><p>现在，请你找出满足下列条件的回文字符串的数量：</p><p>长度为 N。<br>字典序上小于 S。<br>由前 K 个小写字母组成。<br>由于满足条件的字符串数量可能很大，所以输出对 1e9+7 取模后的答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N];<span class="comment">//f表示有n个位置可以随便取时的分支数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=T;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">        <span class="type">char</span> s[N];</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        </span><br><span class="line">        f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            f[i]=(LL)f[i<span class="number">-1</span>]*k%MOD;</span><br><span class="line">            </span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid=(n+<span class="number">1</span>)/<span class="number">2</span>;<span class="comment">//自由度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;mid;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=(LL)(s[i]-<span class="string">&#x27;a&#x27;</span>)*f[mid-i<span class="number">-1</span>]%MOD;</span><br><span class="line">            res%=MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断回文串是否小于原串=&gt;前半段全与原s相等的情况</span></span><br><span class="line">        <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=mid<span class="number">-1</span>,j=n<span class="number">-1</span>-i;i&gt;=<span class="number">0</span>;i--,j++)</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=s[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]&lt;s[j]) y=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        res=(res+y)%MOD;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>, t, res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/7/2 算法每日一题</title>
      <link href="/2023/07/02/2023-7-2-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/07/02/2023-7-2-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目1-AcWing-3321-ATM队列"><a href="#题目1-AcWing-3321-ATM队列" class="headerlink" title="题目1:AcWing 3321.ATM队列"></a>题目1:<a href="https://www.acwing.com/problem/content/3324/">AcWing 3321.ATM队列</a></h2><p>N 个人（编号 1∼N），排成一队在 ATM 机前准备取钱。</p><p>初始时，队列按编号升序的顺序排列。</p><p>第 i 个人需要取 Ai 元钱。<br>一个人一次最多可以取 X 元钱。</p><p>当轮到某个人取钱时，如果其需要的钱的数量大于 X，则只能先取 X 元钱，然后去队尾重新排队，等待下次轮到他取钱时，继续去取。</p><p>当一个人取够钱时，他就会拿着钱离开队列。</p><p>现在，请你确定所有人离开队列的顺序。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>,i);</span><br><span class="line">        <span class="type">int</span> n,x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;y);</span><br><span class="line">            a[j]=&#123;(y<span class="number">-1</span>)/x,j&#125;;<span class="comment">//直接计算轮次,需要注意当待取钱数等于一次最多能去的钱数的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[j].second);</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2-AcWing-4122-字符串转换"><a href="#题目2-AcWing-4122-字符串转换" class="headerlink" title="题目2:AcWing 4122.字符串转换"></a>题目2:<a href="https://www.acwing.com/problem/content/4125/">AcWing 4122.字符串转换</a></h2><p>给定一个由小写字母构成的字符串 S。</p><p>再给定一个由若干个各不相同的小写字母按字典序排序构成的字符串 F。</p><p>现在，你可以对字符串 S 进行字符转换操作。</p><p>每次选中其中一个字符（即某个小写字母），将其转换为一个按照字母顺序与其相邻（上一个或下一个）的小写字母。</p><p>例如，c 可以转换为 b 或 d。</p><p>额外的，我们将按照循环顺序考虑字母，即我们认为 a 的上一个字母为 z，z 的下一个字母为 a。</p><p>请问，至少需要进行多少次操作，可以使得字符串 S 中的每个字母都出现在字符串 F 中。</p><p>代码如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string s, f;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; f;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; s.<span class="built_in">size</span>(); a++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> m = <span class="number">26</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; f.<span class="built_in">size</span>(); b++)</span><br><span class="line">            &#123;</span><br><span class="line">                m = <span class="built_in">min</span>(m, <span class="built_in">abs</span>(s[a] - f[b]));</span><br><span class="line">                m = <span class="built_in">min</span>(m, <span class="built_in">abs</span>(s[a] + <span class="number">26</span> - f[b]));</span><br><span class="line">                m = <span class="built_in">min</span>(m, <span class="built_in">abs</span>(s[a] - <span class="number">26</span> - f[b]));</span><br><span class="line">            &#125;</span><br><span class="line">            ans += m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>, i, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/7/1 算法每日一题</title>
      <link href="/2023/07/01/2023-7-1-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/07/01/2023-7-1-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>因为期末周和放假回家休息了几天,今天开始继续</p><h2 id="题目1-AcWing-4737-冰壶"><a href="#题目1-AcWing-4737-冰壶" class="headerlink" title="题目1:AcWing 4737.冰壶"></a>题目1:<a href="https://www.acwing.com/problem/content/4740/">AcWing 4737.冰壶</a></h2><p>红队和黄队进行了一场冰壶比赛，比赛结束后，裁判正在计算两队的得分。</p><p>场地可以看作一个二维平面，得分区域可以看作一个以 (0,0) 为圆心 Rh 为半径的圆。</p><p>场地上散落着 N 个红队的冰壶以及 M 个黄队的冰壶。</p><p>冰壶可以看作一个半径为 Rs 的圆。</p><p>每个冰壶的圆心坐标已知。<br>如果一个冰壶的任何部分位于得分区域的圆上或圆内（两者相切也算），则视为该冰壶位于得分区域内。<br>如果一个冰壶能够同时满足：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.它位于得分区域内。</span><br><span class="line"></span><br><span class="line">2.不存在任何对方冰壶比它距离得分中心 (0,0) 更近（欧几里得距离）。</span><br></pre></td></tr></table></figure><br>那么，这个冰壶就是一个得分冰壶。</p><p>一个队伍的最终得分等于该队伍的得分冰壶数量。请你计算并输出两支队伍的最终得分。</p><p>一个冰壶与得分中心之间的距离等于其圆心点到点 (0,0)的距离。</p><p>数据保证不同冰壶与得分中心之间的距离不同，且冰壶两两之间不重叠（但可能相切）。</p><p>代码如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; a, b;<span class="comment">//直接存得分圈内的圆壶的距离</span></span><br><span class="line">        <span class="type">int</span> rs,rh,n,m;<span class="comment">//rs场地半径,rh圆壶半径,n,m圆壶数</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;rs,&amp;rh);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="type">double</span> d = <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">            <span class="keyword">if</span> (d &lt;= rs + rh) a.<span class="built_in">push_back</span>(d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="type">double</span> d = <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">            <span class="keyword">if</span> (d &lt;= rs + rh) b.<span class="built_in">push_back</span>(d);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> m1 = <span class="number">0</span>, m2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">empty</span>() || b.<span class="built_in">empty</span>()) m1 = a.<span class="built_in">size</span>(), m2 = b.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">            <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> d : a)</span><br><span class="line">                <span class="keyword">if</span> (d &lt; b[<span class="number">0</span>]) m1++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> d : b)</span><br><span class="line">                <span class="keyword">if</span> (d &lt; a[<span class="number">0</span>]) m2++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d %d\n&quot;</span>,i,m1,m2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="题目2-AcWing-4633-学生和导师"><a href="#题目2-AcWing-4633-学生和导师" class="headerlink" title="题目2:AcWing 4633.学生和导师"></a>题目2:<a href="https://www.acwing.com/problem/content/4636/">AcWing 4633.学生和导师</a></h2><p>有 N 个学生（编号 1∼N）正在一起准备编程竞赛。</p><p>为了帮助彼此做好准备，每个学生都要选择一个其他学生作为他的导师，帮助其进步。<br>每个学生只能拥有一位导师，但是一个学生可以成为多个学生的导师。</p><p>第 i 个学生的实力评分为 Ri。</p><p>我们认为，导师不能比其受指导者强太多，所以只有当 Rj≤2×Ri 时，学生 j 才能成为学生 i 的导师。</p><p>请注意，导师的评分可以小于或等于其受指导者的评分。</p><p>毫不奇怪，每个学生都希望自己的导师尽可能强，所以对于每个学生，请你找出他们可以选择的导师的最高评分。</p><p>代码如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="built_in">memcpy</span>(b,a,<span class="keyword">sizeof</span> a);</span><br><span class="line">        <span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>,i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用二分找大于2a[i]的第一个位置,然后对其--,就找到了</span></span><br><span class="line">        <span class="comment">//如果正好为自身,同样--,找到比自己拉的导师</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">1</span>,r=n;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(b[mid]&gt;<span class="number">2</span>*a[i]) r=mid;</span><br><span class="line">                <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(b[r]&gt;<span class="number">2</span>*a[i]) r--;<span class="comment">//超出范围</span></span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[r]) r--;<span class="comment">//等于自身</span></span><br><span class="line">            <span class="keyword">if</span>(r!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[r]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/6/25 算法每日一题</title>
      <link href="/2023/06/25/2023-6-25-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/06/25/2023-6-25-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-AcWing-4738-快乐子数组"><a href="#题目-AcWing-4738-快乐子数组" class="headerlink" title="题目:AcWing 4738.快乐子数组"></a>题目:<a href="https://www.acwing.com/problem/content/4741/">AcWing 4738.快乐子数组</a></h2><p>我们将 F(B,L,R) 定义为整数数组 B 的索引从 L 到 R（包括两者）的子数组的各个元素之和。</p><p>更具体的说，F(B,L,R)=BL+BL+1+…+BR。</p><p>如果一个长度为 K 的整数数组 C 满足其所有前缀和均为非负整数，则称数组 C 为快乐数组。</p><p>更具体的说，如果 F(C,1,1),F(C,1,2),…,F(C,1,K) 均为非负整数，则数组 C 为快乐数组。</p><p>给定一个包含 N 个整数的数组 A，请你计算数组 A 中的所有快乐连续子数组的元素和相加的结果。</p><h3 id="大佬代码"><a href="#大佬代码" class="headerlink" title="大佬代码"></a><a href="https://www.acwing.com/solution/content/148121/">大佬代码</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//菜,自己润不出来</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> p[N], pp[N], r[N];</span><br><span class="line"><span class="comment">//设p数组的前缀和数组为pp, pp[i]=p[1]+p[2]+…+p[i]</span></span><br><span class="line"><span class="comment">//定义r[l]为， 以al开始的最长快乐子数组的右端点。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T; cin &gt;&gt; T;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>; t &lt;= T; t ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            p[i] = p[i - <span class="number">1</span>] + x;</span><br><span class="line">            pp[i] = pp[i - <span class="number">1</span>] + p[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        stk.<span class="built_in">push</span>(n + <span class="number">1</span>), p[n + <span class="number">1</span>] = <span class="number">-1e9</span>;<span class="comment">//初始化栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">0</span>; i --) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (p[i] &lt;= p[stk.<span class="built_in">top</span>()])<span class="comment">//当栈顶元素大时</span></span><br><span class="line">                stk.<span class="built_in">pop</span>();<span class="comment">//直接删除栈顶元素</span></span><br><span class="line">                </span><br><span class="line">            r[i + <span class="number">1</span>] = stk.<span class="built_in">top</span>();<span class="comment">//找到了右端点</span></span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> j = r[i] - <span class="number">1</span>;</span><br><span class="line">            res += pp[j] - pp[i - <span class="number">1</span>] - (j - i + <span class="number">1</span>) * p[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="再贴一个单调栈的文章吧"><a href="#再贴一个单调栈的文章吧" class="headerlink" title="再贴一个单调栈的文章吧"></a>再贴一个单调栈的文章吧</h3><p><a href="https://www.acwing.com/solution/content/27437/">单调栈</a></p><p>算法原理:<br>用单调递增栈，当该元素可以入栈的时候，栈顶元素就是它左侧第一个比它小的元素。<br>以：3 4 2 7 5 为例，过程如下：<br><img src="https://cdn.acwing.com/media/article/image/2023/03/11/55289_7a61998ec0-20201211221031165.gif" alt="image"></p><p>这里是伪代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="comment">//此处一般需要给数组最后添加结束标志符，具体下面例题会有详细讲解</span></span><br><span class="line"><span class="keyword">for</span> (遍历这个数组)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (栈空 || 栈顶元素大于等于当前比较元素)</span><br><span class="line">&#123;</span><br><span class="line">入栈;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (栈不为空 &amp;&amp; 栈顶元素小于当前元素)</span><br><span class="line">&#123;</span><br><span class="line">栈顶元素出栈;</span><br><span class="line">更新结果;</span><br><span class="line">&#125;</span><br><span class="line">当前数据入栈;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「lucky52529」的原创文章，遵循CC <span class="number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/lucky52529/article/details/89155694</span></span><br></pre></td></tr></table></figure></p><p>代码如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> stk[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">while</span> (tt &amp;&amp; stk[tt] &gt;= x) tt -- ;<span class="comment">//如果栈顶元素大于当前待入栈元素，则出栈</span></span><br><span class="line">        <span class="keyword">if</span> (!tt) <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);<span class="comment">//如果栈空，则没有比该元素小的值。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, stk[tt]);<span class="comment">//栈顶元素就是左侧第一个比它小的元素。</span></span><br><span class="line">        stk[ ++ tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/6/24 算法每日一题</title>
      <link href="/2023/06/24/2023-6-24-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/06/24/2023-6-24-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-AcWing-4741-魔法百合井"><a href="#题目-AcWing-4741-魔法百合井" class="headerlink" title="题目:AcWing 4741.魔法百合井"></a>题目:<a href="https://www.acwing.com/problem/content/4744/">AcWing 4741.魔法百合井</a></h2><p>森林里有一口很深的魔法井，井中有 L 朵百合花。</p><p>你带着一个大空篮子和足够多的硬币来到了井边。<br>这个井有魔力，向里面投入硬币可以发生神奇的事情：</p><p>如果你向井里一次性投入 1 个硬币，井就会发动魔法，将一朵百合花扔进你的篮子里。<br>如果你向井里一次性投入 4 个硬币，井就会发动魔法，统计并记录到目前为止，已经扔进你的篮子里的百合花的数量。<br>如果你向井里一次性投入 2 个硬币，井就会发动魔法，将等同于上次记录数量的百合花扔进你的篮子里。<br>有一点需要特别注意，如果你向井里一次性投入 1 个或 2 个硬币后，井中已经没有足够的百合花扔给你了，那么井就不会发动任何魔法，也不会扔给你任何百合花（钱白花了）。</p><p>请你计算，为了将所有百合花都收入篮中，所需要花费的最少硬币数量。</p><h3 id="自己尝试的错误做法"><a href="#自己尝试的错误做法" class="headerlink" title="自己尝试的错误做法"></a>自己尝试的错误做法</h3><p>可以发现这样选不出最优的开始倍增的位置,原理我也不清楚,反正模拟下案例发现这样暴力模拟确实做不出来<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加一朵鲜花需要1</span></span><br><span class="line"><span class="comment">//对当前持有鲜花倍增需要4+2=6</span></span><br><span class="line"><span class="comment">//对上一次持有的鲜花数进行倍增需要2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当篮子内鲜花数&gt;=6时开始考虑倍增</span></span><br><span class="line"><span class="comment">// 若倍增后超过 井内鲜花数,则不倍增,否则倍增</span></span><br><span class="line"><span class="comment">// 若不倍增,看看对上次持有鲜花数倍增能否更接近答案,之后加一,重复这个过程;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t, l;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;l);</span><br><span class="line">        <span class="type">int</span> nf = <span class="number">0</span>;<span class="comment">//当前篮子里鲜花数量</span></span><br><span class="line">        <span class="type">int</span> f = l;<span class="comment">//当前井中鲜花数</span></span><br><span class="line">        <span class="type">int</span> lastf = <span class="number">0</span>;<span class="comment">//上次记录井中鲜花数</span></span><br><span class="line">        <span class="type">int</span> coin = <span class="number">0</span>;<span class="comment">//硬币数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (nf != l)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (nf &lt; <span class="number">6</span> &amp;&amp; f != <span class="number">0</span>) coin++, f--, nf++;</span><br><span class="line">            <span class="keyword">while</span> (f &gt;= lastf&amp;&amp;nf!=l)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nf * <span class="number">2</span> &lt;= l &amp;&amp; f &gt;= nf) coin += <span class="number">6</span>, lastf = nf, nf += nf, f -= lastf;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (f &gt;= lastf &amp;&amp; nf + lastf &lt; l)coin += <span class="number">2</span>, nf += lastf, f -= lastf;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (nf != l) coin++, f--, nf++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; coin &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="这是简化后的dp"><a href="#这是简化后的dp" class="headerlink" title="这是简化后的dp"></a>这是简化后的dp</h3><p><a href="https://www.acwing.com/solution/content/191789/">转自:鸣一YU</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//f[i]表示i朵花的最少花费</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于题目范围内的i,遍历其约数</span></span><br><span class="line">        <span class="comment">//其中，j 表示翻倍的倍数(2的个数)，即从 i/j 开始翻倍；i/j 表示翻倍后的数量，即每次翻倍的数量为 i/j；</span></span><br><span class="line">        <span class="comment">//i%(i/j) 表示最后一次翻倍时需要花费的额外费用(结尾补1)。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//具体地，首先将 f[i] 更新为当前最小花费，然后枚举从 i/j 开始翻倍的倍数 j，计算翻倍后的数量</span></span><br><span class="line">        <span class="comment">//和最后一次翻倍的额外费用，然后加上 4+(j-1)*2，即投入 4 个硬币并记录新的数量的花费。最后，将</span></span><br><span class="line">        <span class="comment">//这个值与当前的 f[i] 取最小值，表示使用这种翻倍方式所需的最小花费。</span></span><br><span class="line"></span><br><span class="line">        f[i]=i;<span class="comment">//初始化i朵花最坏情况：每朵花都是一块钱买的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>; j&lt;=i/j; j++)<span class="comment">//j表示扩大的倍数</span></span><br><span class="line">            f[i]=<span class="built_in">min</span>(f[i], f[i/j]+<span class="number">4</span>+(j<span class="number">-1</span>)*<span class="number">2</span>+i%(i/j));</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">              f[i/j]表示从i/j这个开始翻倍时的最小费用,</span></span><br><span class="line"><span class="comment">              f[i/j]+4+(j-1)*2+i%(i/j)这就是翻倍后的通用的推导公式；</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a ; cin &gt;&gt; a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>, i, f[a]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/6/21 算法每日一题</title>
      <link href="/2023/06/23/2023-6-23-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/06/23/2023-6-23-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目1-AcWing-4742-电"><a href="#题目1-AcWing-4742-电" class="headerlink" title="题目1:AcWing 4742.电"></a>题目1:<a href="https://www.acwing.com/problem/content/4745/">AcWing 4742.电</a></h2><p>某城市有 N 个电力节点，编号 1∼N。</p><p>这些电力节点形成的电力网络，可以看作一个 N 个节点 N−1 条边的连通图。</p><p>每个电力节点都有一个固定的电容，其中第 i 个节点的电容为 Ai。</p><p>现在，可以选择其中一个节点进行供电，其它节点也可以根据实际连接以及具体电容情况接收电力。</p><p>具体来说，如果第 i 个节点通电，那么它也可以将电力传输给其它所有与它直接连接且电容严格小于 Ai 的节点。</p><p>我们希望通过合理选择初始供电节点，从而使得尽可能多的节点能够通电。</p><p>请你计算并输出可以通电的最大节点数量。</p><h3 id="手搓邻接表-原文链接"><a href="#手搓邻接表-原文链接" class="headerlink" title="手搓邻接表 原文链接"></a>手搓邻接表 <a href="https://blog.csdn.net/qq_63356727/article/details/129209473">原文链接</a></h3><p>h数组：表示每个顶点对应的链表的头节点的下标。</p><p>e数组：表示每个边的终点。</p><p>ne数组：表示与当前边起点相同的下一条边的下标。</p><p>需要注意的是,这些数组内存储的都是下标</p><p>具体来说，对于一条边(a, b)，我们将它插入到顶点a的链表中。我们需要先将新边的终点存入e数组中，将当前顶点a的链表的头节点下标存入ne数组中，然后将当前边的下标存入h数组中。同时，为了保证新插入的边在链表的头部，我们需要将当前边的下标作为新的头节点，将它存入h数组中，并更新ne数组中原来的头节点的值，使其指向当前边的下标。这样，就能够实现将新边插入到链表的头部，并更新该顶点的链表头节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//DFS</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2</span>*<span class="number">1e5</span>+<span class="number">10</span>,M=N*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],idx=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    res[n]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[n];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=e[i];</span><br><span class="line">        <span class="keyword">if</span>(w[n]&gt;w[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (res[j] == <span class="number">0</span>) <span class="built_in">dfs</span>(j);</span><br><span class="line">            res[n] += res[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t,n;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[j]), h[j] = <span class="number">-1</span>, res[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a,b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">            <span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res[j]==<span class="number">0</span>) <span class="built_in">dfs</span>(j);</span><br><span class="line">            <span class="keyword">if</span>(res[j]&gt;ans) ans=res[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>,i,ans);</span><br><span class="line">        </span><br><span class="line">        idx=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2-AcWing-4740-跑圈"><a href="#题目2-AcWing-4740-跑圈" class="headerlink" title="题目2:AcWing 4740.跑圈"></a>题目2:<a href="https://www.acwing.com/problem/content/4743/">AcWing 4740.跑圈</a></h2><p>阿达正在一个长度为 L 的环形跑道上练习跑步。</p><p>为了更专注于跑步，阿达专门准备了一台机器来统计她跑的圈数。</p><p>机器放置在跑道的起跑线上，从 0 开始计数。</p><p>每当阿达离开起跑线时（直接越过起跑线或在起跑线位置处改变方向并离开起跑线），她的面朝方向就会被机器记录。</p><p>机器只会实时记录她最近一次离开起跑线时的面朝方向。<br>每当阿达到达起跑线位置时，只要其面朝方向与机器记录的上次离开起跑线时的面朝方向相同，机器计数就会加 1。</p><p>阿达从起跑线处开始跑步。她的耐力有限，无法将计划的训练量一口气完成。因此，每跑一段距离，她都会原地休息一段时间，用来恢复体力。</p><p>不幸的是，阿达的记忆力并不是很好，每当她休息完再次开始跑步时，她都会忘了之前面朝的方向。这时，她只能随意选择一个方向（顺时针或逆时针），并面朝该方向从她停下的位置开始继续跑步。</p><p>具体的说，她一共进行了 N 段跑步，其中第 i 段跑步的距离为 Di，跑步时的面朝方向为 Ci<br>。</p><p>请你计算，在阿达完成跑步后，机器最终记录的圈数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">1</span>; m &lt;= t; m++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, n;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; n;</span><br><span class="line">        <span class="comment">//bool first = true;//记录第一次起跑</span></span><br><span class="line">        <span class="type">char</span> f, lf;<span class="comment">//当前方向,上次方向</span></span><br><span class="line">        <span class="type">int</span> d;<span class="comment">//本段跑步长度</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;<span class="comment">//圈数量  注意数据范围ll</span></span><br><span class="line">        <span class="type">int</span> rd = <span class="number">0</span>;<span class="comment">//当前位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %c&quot;</span>, &amp;d, &amp;f);</span><br><span class="line">            <span class="comment">//if(first) lf=f,first=false;</span></span><br><span class="line">            <span class="keyword">if</span> (rd == <span class="number">0</span>) lf = f;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (lf == f)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((rd + d) / l)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans += (rd + d) / l;</span><br><span class="line">                    rd = (rd + d) % l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> rd += d;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rd - d &gt; <span class="number">0</span>) rd -= d;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    rd = (d - rd), lf = f;</span><br><span class="line">                    <span class="keyword">if</span> (rd / l)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans += rd / l;</span><br><span class="line">                        rd = rd % l;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %lld\n&quot;</span>,m,ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/6/22 算法每日一题</title>
      <link href="/2023/06/22/2023-6-22-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/06/22/2023-6-22-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>题目:<a href="https://www.acwing.com/problem/content/4443/">AcWing 4440.照相</a></p><p>迫切希望在郡县集市上赢得最佳奶牛摄影师的农夫约翰正在尝试为他的N头奶牛拍摄一张完美的照片。</p><p>农夫约翰拥有两种品种的奶牛：更赛牛（Guernsey）和荷斯坦牛（Holstein）。</p><p>为了使他的照片尽可能地艺术，他想把他的奶牛排成一排，使得尽可能多的更赛牛处于队列中的偶数位置（队列中的第一个位置是奇数位置，下一个是偶数位置，以此类推）。</p><p>由于他与他的奶牛缺乏有效的沟通，他可以达到目的的唯一方法是让他的奶牛的偶数长的「前缀」进行反转（一个前缀指的是对于某个位置 j，从第一头奶牛到第 j 头奶牛范围内的所有奶牛）。</p><p>请计算农夫约翰达到目的所需要的最小反转次数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ACW4440 take cow photo</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2</span>*<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于牛的总数为偶数,且每次翻转的牛的数量总取前偶数个</span></span><br><span class="line"><span class="comment">// 对于每次输入,对其进行两两一组的分组</span></span><br><span class="line"><span class="comment">// 对于组别GH,需要对其进行翻转,让其变为HG,因为翻转后会破坏前面已经符合题意的前缀</span></span><br><span class="line"><span class="comment">// 所以需要对其前缀进行翻转维护前缀的正确性</span></span><br><span class="line"><span class="comment">// 对于组别GG,HH,直接忽略即可</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string s; </span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;<span class="comment">//翻转次数</span></span><br><span class="line">    <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i+=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;G&#x27;</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">&#x27;H&#x27;</span>) ans+=flag==<span class="number">2</span>,flag=<span class="number">1</span>;<span class="comment">//GH情况,如果前面是GH,则先放着不管,攒着一起翻转前缀</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;H&#x27;</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">&#x27;G&#x27;</span>) ans+=flag==<span class="number">1</span>,flag=<span class="number">2</span>;<span class="comment">//HG情况,如果前面也是GH的情况,则需要处理前面的前缀了</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="number">1</span>) ans++;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/6/21 算法每日一题</title>
      <link href="/2023/06/21/2023-6-21-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/06/21/2023-6-21-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>题目:<a href="https://www.acwing.com/activity/content/problem/content/8434/">AcWing 4908.饥饿的牛</a></p><p>贝茜是一头饥饿的牛。每天晚上，如果牛棚中还有干草的话，贝茜都会吃掉其中的一捆。</p><p>初始时，牛棚中没有干草。</p><p>为了让贝茜不被饿死，农夫约翰制定了N个给贝茜送干草的计划。</p><p>其中第 i个计划是在第 di天的白天给贝茜送去 bi捆干草。</p><p>这些计划互不冲突，保证 1≤d1&lt;d2&lt;…&lt;dN≤T。</p><p>请你计算，贝茜在第 1∼T天中有多少天有干草吃。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ACW4908 hunger cow</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n,t;<span class="comment">//送n次草,共t天</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> di,bi,cao=<span class="number">0</span>,last=<span class="number">0</span>;<span class="comment">//当前送草日,当前送草量,上次更新的库存草料数,上次送草日</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> fullDay=<span class="number">0</span>;<span class="comment">//吃饱天数</span></span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;di,&amp;bi);</span><br><span class="line">        <span class="keyword">if</span>(di-last&gt;cao)<span class="comment">//中间挨饿了</span></span><br><span class="line">        &#123;</span><br><span class="line">            fullDay+=cao;</span><br><span class="line">            cao=bi;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cao-=(di-last);</span><br><span class="line">            cao+=bi;</span><br><span class="line">            fullDay+=di-last;</span><br><span class="line">        &#125;</span><br><span class="line">        last=di;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理最后一次送草的余料</span></span><br><span class="line">    <span class="keyword">if</span>(cao&gt;=(t-last+<span class="number">1</span>)) fullDay+=(t-last+<span class="number">1</span>);<span class="comment">//够吃到结束</span></span><br><span class="line">    <span class="keyword">else</span> fullDay+=cao;<span class="comment">//不够吃到结束</span></span><br><span class="line">    cout&lt;&lt;fullDay&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23年大二下硬件课设</title>
      <link href="/2023/06/20/2023-6-20-23%E7%A1%AC%E4%BB%B6%E8%AF%BE%E8%AE%BE/"/>
      <url>/2023/06/20/2023-6-20-23%E7%A1%AC%E4%BB%B6%E8%AF%BE%E8%AE%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="verilog代码实现模拟交通灯"><a href="#verilog代码实现模拟交通灯" class="headerlink" title="verilog代码实现模拟交通灯"></a>verilog代码实现模拟交通灯</h1><h2 id="题目要求如下"><a href="#题目要求如下" class="headerlink" title="题目要求如下"></a>题目要求如下</h2><p>模拟交通灯<br>输入信号：时钟信号clk<br>输出信号：东西向红黄绿灯信号r1、y1、g1以及南北向红黄绿灯信号r2、y2、g2<br>设计要求：<br>1、输出高电平表示相应灯点亮，低电平表示相应灯熄灭。<br>2、初始时东西向绿灯，g1输出高电平，南北向红灯，r2输出高电平。<br>3、12个时钟脉冲（可统一使用时钟脉冲的上升沿或者下降沿，下同）后，原绿灯方向变为黄灯，再3个时钟脉冲后，黄灯方向变红灯，同时原红灯方向变绿灯；随后又是12个时钟脉冲后，当前绿灯方向又变为黄灯，再过3个时钟脉冲后，黄灯方向变红灯，同时当前红灯方向又变为绿灯，如此循环往复。<br>4、绿灯变为黄灯前，绿灯必须先闪烁数次以作为提示，即第8个时钟脉冲到来后绿灯暂时熄灭，第9个时钟脉冲到来后绿灯重新点亮，第10个时钟脉冲到来后绿灯又熄灭，第11个时钟脉冲到来后绿灯又点亮，直到第12个时钟脉冲到来后绿灯才变为黄灯，此功能必须实现。<br>5、设法消除输出信号中的干扰脉冲（“毛刺”），此功能必须实现。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在这个模拟交通灯系统中，我们需要根据输入信号：时钟信号clk输出东西向红黄绿灯信号r1、y1、g1以及南北向红黄绿灯信号r2、y2、g2。整个系统要求输出高电平表示相应灯点亮，低电平表示相应灯熄灭，并且初始状态下东西向道路为绿色，南北向道路为红色。此外，在每一个方向上车辆可以行驶的时间是有限制的，并且在不同时期会出现所谓“闪烁”等特殊情况。</p><h3 id="TLCounter模块设计"><a href="#TLCounter模块设计" class="headerlink" title="TLCounter模块设计"></a>TLCounter模块设计</h3><p>对于计数器模块,我们需要实现以下的功能需求：①能够循环计数0~27，并根据计数值更新交通信号灯状态。②在每个时间单位内，交通信号灯的状态都需要被同步更新。③交通信号灯的控制信号需要被输出到特定的IO口。<br>TLCounter模块由一个5位二进制寄存器组成，用于循环计数0~27。其中第一位最低位作为使能端口（enable），其余四位可表示16种状态，在此我们仅使用其中12种状态作为交通灯各个阶段。每当计数器的值变化时，就会触发TLDecoder模块更新输出状态。在该设计中，我们使用了简单的异或逻辑实现二进制寄存器的自加1操作。<br>具体实现代码如下：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> TLCounter(clk,cnt);<span class="comment">//0~27 循环计数</span></span><br><span class="line"><span class="keyword">input</span> clk;</span><br><span class="line"><span class="keyword">output</span>[<span class="number">4</span>:<span class="number">0</span>] cnt;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">4</span>:<span class="number">0</span>] cnt=<span class="number">5&#x27;b00001</span>;</span><br><span class="line"><span class="keyword">assign</span> clr=~(cnt[<span class="number">0</span>]&amp;cnt[<span class="number">1</span>]&amp;(cnt[<span class="number">2</span>])&amp;cnt[<span class="number">3</span>]&amp;cnt[<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">cnt[<span class="number">0</span>] &lt;= (~cnt[<span class="number">0</span>]);</span><br><span class="line">cnt[<span class="number">1</span>] &lt;= (cnt[<span class="number">1</span>] ^ cnt[<span class="number">0</span>]);</span><br><span class="line">cnt[<span class="number">2</span>] &lt;= (cnt[<span class="number">2</span>] ^ (cnt[<span class="number">0</span>] &amp; cnt[<span class="number">1</span>]));</span><br><span class="line">cnt[<span class="number">3</span>] &lt;= (cnt[<span class="number">3</span>] ^ (cnt[<span class="number">0</span>] &amp; cnt[<span class="number">1</span>] &amp; cnt[<span class="number">2</span>]));</span><br><span class="line">cnt[<span class="number">4</span>] &lt;= (cnt[<span class="number">4</span>] ^ (cnt[<span class="number">0</span>] &amp; cnt[<span class="number">1</span>] &amp; cnt[<span class="number">2</span>] &amp; cnt[<span class="number">3</span>]));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><br>在上面的代码中，我们首先定义了一个输入时钟信号（clk）、使能信号（enable）和一个用于输出计数器数值的信号（cnt）。然后，我们使用reg关键字声明了一个名为cnt的寄存器，并将其初始化为5’b00001。<br>接下来是关键的部分：在顺时针上升沿时，如果使能信号enable为高电平，则寄存器cnt的值会自动加1。具体实现方法是使用异或逻辑运算符（^）对各个二进制位进行比较和修改。通过这样的方式，我们就成功地实现了一个简单的计数器模块。</p><h3 id="TLDecoder模块设计"><a href="#TLDecoder模块设计" class="headerlink" title="TLDecoder模块设计"></a>TLDecoder模块设计</h3><p>TLDecoder模块是由一个组合电路构成，它将计数器产生的信号解码成相应的交通灯控制信号。具体实现采用了基于嵌套语句和位运算符构建的多层分支结构来判断当前处于哪种状态，并生成相应控制信号。<br>具体实现代码如下：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> TLDecoder(cnt,light,clk);</span><br><span class="line"><span class="keyword">input</span> clk;</span><br><span class="line"><span class="keyword">input</span>[<span class="number">4</span>:<span class="number">0</span>] cnt;</span><br><span class="line"><span class="keyword">output</span>[<span class="number">5</span>:<span class="number">0</span>] light;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">5</span>:<span class="number">0</span>] light=<span class="number">6&#x27;b001100</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)<span class="comment">//所有的输出信号都将在时钟的上升沿同步更新，从而消除可能的毛刺</span></span><br><span class="line"><span class="keyword">begin</span> light[<span class="number">5</span>]&lt;=((cnt[<span class="number">4</span>]&amp;(~cnt[<span class="number">3</span>]))|(cnt[<span class="number">4</span>]&amp;(~cnt[<span class="number">2</span>]))|((~cnt[<span class="number">4</span>])&amp;cnt[<span class="number">3</span>]&amp;cnt[<span class="number">2</span>]&amp;cnt[<span class="number">1</span>]));</span><br><span class="line">light[<span class="number">4</span>]&lt;=(((~cnt[<span class="number">4</span>])&amp;cnt[<span class="number">3</span>]&amp;(~cnt[<span class="number">2</span>])&amp;cnt[<span class="number">1</span>]&amp;cnt[<span class="number">0</span>])|((~cnt[<span class="number">4</span>])&amp;cnt[<span class="number">3</span>]&amp;cnt[<span class="number">2</span>]&amp;(~cnt[<span class="number">1</span>])));</span><br><span class="line">light[<span class="number">2</span>]&lt;=(((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">3</span>]))|((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">2</span>]))|((~cnt[<span class="number">4</span>])&amp;cnt[<span class="number">2</span>]&amp;(~cnt[<span class="number">1</span>])));</span><br><span class="line">light[<span class="number">1</span>]&lt;=((cnt[<span class="number">4</span>]&amp;cnt[<span class="number">3</span>]&amp;(~cnt[<span class="number">2</span>])&amp;cnt[<span class="number">0</span>])|(cnt[<span class="number">4</span>]&amp;cnt[<span class="number">3</span>]&amp;(~cnt[<span class="number">2</span>])&amp;cnt[<span class="number">1</span>]));</span><br><span class="line">light[<span class="number">3</span>]&lt;=(((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">3</span>])&amp;(~cnt[<span class="number">1</span>]))|((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">3</span>])&amp;(~cnt[<span class="number">2</span>]))|((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">2</span>])&amp;(~cnt[<span class="number">1</span>])&amp;(~cnt[<span class="number">0</span>]))|((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">2</span>])&amp;cnt[<span class="number">1</span>]&amp;(~cnt[<span class="number">0</span>]))|((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">3</span>])&amp;cnt[<span class="number">1</span>]&amp;(~cnt[<span class="number">0</span>])));</span><br><span class="line">light[<span class="number">0</span>]&lt;=((cnt[<span class="number">4</span>]&amp;(~cnt[<span class="number">3</span>])&amp;(~cnt[<span class="number">2</span>]))|(cnt[<span class="number">4</span>]&amp;(~cnt[<span class="number">2</span>])&amp;(~cnt[<span class="number">1</span>])&amp;(~cnt[<span class="number">0</span>]))|(cnt[<span class="number">4</span>]&amp;(~cnt[<span class="number">3</span>])&amp;(~cnt[<span class="number">1</span>])&amp;(~cnt[<span class="number">0</span>]))|(cnt[<span class="number">4</span>]&amp;(~cnt[<span class="number">3</span>])&amp;cnt[<span class="number">1</span>]&amp;(~cnt[<span class="number">0</span>]))|((~cnt[<span class="number">4</span>])&amp;cnt[<span class="number">3</span>]&amp;cnt[<span class="number">2</span>]&amp;cnt[<span class="number">1</span>]));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><br>该模块实现了一个基于计数器值的交通信号灯控制器。在给定时钟信号的上升沿触发下，通过组合逻辑电路计算出当前计数器值所对应的红、黄、绿三种灯的状态，并将其输出到light寄存器中。具体地说，该模块包含一个5位的输入计数器值cnt和一个6位的输出灯状态light，其中light[5:0]分别对应红、黄、绿三种灯的状态。通过在不同的计数器值下控制各个灯的状态变化，从而实现了基于计数器的交通信号灯控制功能。</p><h2 id="毛刺的消除"><a href="#毛刺的消除" class="headerlink" title="毛刺的消除"></a>毛刺的消除</h2><p>在实现了基本的红绿灯代码后，发现执行的结果中存在“毛刺”现象。<br>首先，我们需要确定毛刺的来源。查阅资料，发现毛刺可能源于TLDecoder模块的always @(cnt)敏感性列表。因为当cnt发生变化时，所有的输出信号都会重新计算。这可能会导致不同信号之间的计算不同步，从而引入毛刺。为了解决这个问题，我们可以尝试使用同步的时钟信号来消除毛刺。<br>具体来说，我们可以将TLDecoder模块的输入信号添加一个时钟信号clk，然后将敏感性列表更改为posedge clk。这样，所有的输出信号都将在时钟的上升沿同步更新，从而消除可能的毛刺。不过，请注意，这将使输出信号的更新速度受到时钟频率的限制。请根据具体应用场景调整时钟频率以满足实际需求。</p><h4 id="verilog代码如下"><a href="#verilog代码如下" class="headerlink" title="verilog代码如下"></a>verilog代码如下</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> HardwareCourse(clk,r1,g1,y1,r2,y2,g2);</span><br><span class="line"><span class="keyword">input</span> clk;</span><br><span class="line"><span class="keyword">output</span> r1,y1,g1,r2,y2,g2;</span><br><span class="line"><span class="keyword">wire</span>[<span class="number">4</span>:<span class="number">0</span>] cnt;</span><br><span class="line"></span><br><span class="line">TLCounter u1(clk,cnt);</span><br><span class="line">TLDecoder u2(cnt,&#123;r1,y1,g1,r2,y2,g2&#125;,clk);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> TLCounter(clk,cnt);<span class="comment">//0~27 循环计数</span></span><br><span class="line"><span class="keyword">input</span> clk;</span><br><span class="line"><span class="keyword">output</span>[<span class="number">4</span>:<span class="number">0</span>] cnt;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">4</span>:<span class="number">0</span>] cnt=<span class="number">5&#x27;b00001</span>;</span><br><span class="line"><span class="keyword">assign</span> clr=~(cnt[<span class="number">0</span>]&amp;cnt[<span class="number">1</span>]&amp;(cnt[<span class="number">2</span>])&amp;cnt[<span class="number">3</span>]&amp;cnt[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">cnt[<span class="number">0</span>] &lt;= (~cnt[<span class="number">0</span>]);</span><br><span class="line">cnt[<span class="number">1</span>] &lt;= (cnt[<span class="number">1</span>] ^ cnt[<span class="number">0</span>]);</span><br><span class="line">cnt[<span class="number">2</span>] &lt;= (cnt[<span class="number">2</span>] ^ (cnt[<span class="number">0</span>] &amp; cnt[<span class="number">1</span>]));</span><br><span class="line">cnt[<span class="number">3</span>] &lt;= (cnt[<span class="number">3</span>] ^ (cnt[<span class="number">0</span>] &amp; cnt[<span class="number">1</span>] &amp; cnt[<span class="number">2</span>]));</span><br><span class="line">cnt[<span class="number">4</span>] &lt;= (cnt[<span class="number">4</span>] ^ (cnt[<span class="number">0</span>] &amp; cnt[<span class="number">1</span>] &amp; cnt[<span class="number">2</span>] &amp; cnt[<span class="number">3</span>]));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> TLDecoder(cnt,light,clk);</span><br><span class="line"><span class="keyword">input</span> clk;</span><br><span class="line"><span class="keyword">input</span>[<span class="number">4</span>:<span class="number">0</span>] cnt;</span><br><span class="line"><span class="keyword">output</span>[<span class="number">5</span>:<span class="number">0</span>] light;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">5</span>:<span class="number">0</span>] light=<span class="number">6&#x27;b001100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">light[<span class="number">5</span>]&lt;=((cnt[<span class="number">4</span>]&amp;(~cnt[<span class="number">3</span>]))|(cnt[<span class="number">4</span>]&amp;(~cnt[<span class="number">2</span>]))|((~cnt[<span class="number">4</span>])&amp;cnt[<span class="number">3</span>]&amp;cnt[<span class="number">2</span>]&amp;cnt[<span class="number">1</span>]));</span><br><span class="line">light[<span class="number">4</span>]&lt;=(((~cnt[<span class="number">4</span>])&amp;cnt[<span class="number">3</span>]&amp;(~cnt[<span class="number">2</span>])&amp;cnt[<span class="number">1</span>]&amp;cnt[<span class="number">0</span>])|((~cnt[<span class="number">4</span>])&amp;cnt[<span class="number">3</span>]&amp;cnt[<span class="number">2</span>]&amp;(~cnt[<span class="number">1</span>])));</span><br><span class="line"><span class="comment">//light[3]&lt;=(((~cnt[4])&amp;(~cnt[3]))|((~cnt[4])&amp;(~cnt[2])&amp;(~cnt[1]))|((~cnt[4])&amp;(~cnt[2])&amp;cnt[1]&amp;(~cnt[0])));</span></span><br><span class="line">light[<span class="number">2</span>]&lt;=(((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">3</span>]))|((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">2</span>]))|((~cnt[<span class="number">4</span>])&amp;cnt[<span class="number">2</span>]&amp;(~cnt[<span class="number">1</span>])));</span><br><span class="line">light[<span class="number">1</span>]&lt;=((cnt[<span class="number">4</span>]&amp;cnt[<span class="number">3</span>]&amp;(~cnt[<span class="number">2</span>])&amp;cnt[<span class="number">0</span>])|(cnt[<span class="number">4</span>]&amp;cnt[<span class="number">3</span>]&amp;(~cnt[<span class="number">2</span>])&amp;cnt[<span class="number">1</span>]));</span><br><span class="line"><span class="comment">//light[0]&lt;=((cnt[4]&amp;(~cnt[3]))|(cnt[4]&amp;(~cnt[2])&amp;(~cnt[1])&amp;(~cnt[0]))|((~cnt[4])&amp;cnt[3]&amp;cnt[2])&amp;cnt[1]);</span></span><br><span class="line"></span><br><span class="line">light[<span class="number">3</span>]&lt;=(((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">3</span>])&amp;(~cnt[<span class="number">1</span>]))|((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">3</span>])&amp;(~cnt[<span class="number">2</span>]))|((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">2</span>])&amp;(~cnt[<span class="number">1</span>])&amp;(~cnt[<span class="number">0</span>]))|((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">2</span>])&amp;cnt[<span class="number">1</span>]&amp;(~cnt[<span class="number">0</span>]))|((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">3</span>])&amp;cnt[<span class="number">1</span>]&amp;(~cnt[<span class="number">0</span>])));</span><br><span class="line">light[<span class="number">0</span>]&lt;=((cnt[<span class="number">4</span>]&amp;(~cnt[<span class="number">3</span>])&amp;(~cnt[<span class="number">2</span>]))|(cnt[<span class="number">4</span>]&amp;(~cnt[<span class="number">2</span>])&amp;(~cnt[<span class="number">1</span>])&amp;(~cnt[<span class="number">0</span>]))|(cnt[<span class="number">4</span>]&amp;(~cnt[<span class="number">3</span>])&amp;(~cnt[<span class="number">1</span>])&amp;(~cnt[<span class="number">0</span>]))|(cnt[<span class="number">4</span>]&amp;(~cnt[<span class="number">3</span>])&amp;cnt[<span class="number">1</span>]&amp;(~cnt[<span class="number">0</span>]))|((~cnt[<span class="number">4</span>])&amp;cnt[<span class="number">3</span>]&amp;cnt[<span class="number">2</span>]&amp;cnt[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/6/20 算法每日一题</title>
      <link href="/2023/06/20/2023-6-20-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/06/20/2023-6-20-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>题目:<a href="https://ac.nowcoder.com/acm/contest/59284/E">幼稚园的树2</a></p><p>牛牛在幼稚园做义工，幼稚园中共有 n 棵树，第 1 天中午时它们的高度分别为：ℎ1,ℎ2,…,ℎn（单位：毫米）。</p><p>每一天的晚上第 i 棵树的高度会增加 ai毫米，而牛牛的任务则是在第二天的清晨检查每一棵树的高度，若某棵树的高度超过了 k 毫米牛牛就会将它的高度修剪为 b 毫米。</p><p>牛牛想请你帮它计算一下第 m 天中午每一棵树的高度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cut</span><span class="params">(<span class="type">int</span> h,<span class="type">int</span> ch,<span class="type">int</span> ach,<span class="type">int</span> gr,<span class="type">int</span> day)</span><span class="comment">//初始高度,要修剪的高度,修剪后高度,每天生长高度,天数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cd1 = (ch-h)/gr+<span class="number">1</span>;<span class="comment">//第一轮到初始值需要的时间</span></span><br><span class="line">    <span class="keyword">if</span>(day&lt;cd1) <span class="keyword">return</span> h+gr*day;</span><br><span class="line">    <span class="keyword">else</span> day-=cd1,h=ach;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cut_r = (ch-ach)/gr+<span class="number">1</span>;<span class="comment">//修剪后要生长的高度/每天生长高度 向上取整 =&gt; 每次修剪间隔的时间</span></span><br><span class="line">    <span class="keyword">return</span> ach+gr*(day%cut_r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> n,m,k,b;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tree[N];</span><br><span class="line"><span class="type">int</span> grow[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;cut(4,10,3,2,4);//初始高度为4,长到10后修建为3,每天长2,长4天</span></span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;b;<span class="comment">//树数,第m天,长到k剪为b</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tree[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;grow[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cout&lt;&lt;<span class="built_in">cut</span>(tree[i],k,b,grow[i],m<span class="number">-1</span>)&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23年大二下软件课设</title>
      <link href="/2023/06/20/2023-6-20-23%E8%BD%AF%E4%BB%B6%E8%AF%BE%E8%AE%BE/"/>
      <url>/2023/06/20/2023-6-20-23%E8%BD%AF%E4%BB%B6%E8%AF%BE%E8%AE%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="WHSubway-武汉市地铁导引系统"><a href="#WHSubway-武汉市地铁导引系统" class="headerlink" title="WHSubway 武汉市地铁导引系统"></a>WHSubway 武汉市地铁导引系统</h1><p>本系统前端基于<a href="https://blog.csdn.net/qq_42365534/article/details/129887911?spm=1001.2014.3001.5502">electron-vue3+vite</a>脚手架搭建,实现了<del>简陋</del>基础的GUI功能<br>后端用了SpringBoot,mybatis等技术<br>武汉市地铁线路截取日期为2023.5.23日</p><p><strong><em>由于electron的文件太大了,传不到github上,就用夸克网盘吧</em></strong></p><p>夸克网盘地址:<a href="https://pan.quark.cn/s/c24eb516f6c2">WHSubway 武汉市地铁引导系统</a></p><h3 id="以下是实验报告中截取的废话"><a href="#以下是实验报告中截取的废话" class="headerlink" title="以下是实验报告中截取的废话"></a><del>以下是实验报告中截取的废话</del></h3><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>随着城市的快速发展，武汉市地铁系统不断扩建，已成为市民出行的重要交通方式之一。然而由于线路复杂、站点众多，乘客常常面临选择路线困难的问题。因此，如何高效地引导乘客选择最合适的路线已是一个具有挑战性的问题。<br>为了解决这个问题，武汉市地铁导引系统应运而生。该系统可以让乘客输入起始站点和目的站点，自动计算最短路线，并在路线信息中提供换乘方案，以便乘客提前规划出行路线。这不仅可以缓解乘客选择路线的困难，还能减少拥挤，优化地铁运营效率。<br>武汉市地铁导引系统使用了最新的技术，基于Electron-Vite-Vue框架实现了图形化界面，使用户操作更加友好和方便。同时，前后端分离的设计，采用MyBatis和MySQL数据库进行数据管理，采用SpringBoot的后端框架，使得系统更加易于更新和维护，也增强了系统的可靠性和稳定性。<br>武汉市地铁导引系统基于2023.5.27的武汉地铁线路，但随着地铁线路不断扩建和更新，该系统也可以通过修改后端的数据库不断完善和更新，以满足不同时间段、不同线路的乘客需求。武汉市地铁导引系统将为城市居民提供了更加便捷、快速、准确的出行选择。</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><h4 id="图形化界面"><a href="#图形化界面" class="headerlink" title="图形化界面"></a>图形化界面</h4><p>为了便于乘客使用，需要设计一个简单的图形化界面，让用户能直观的了解系统的使用方法和用途。GUI中要对用户的操作进行引导，例如选择站点的下拉菜单选项比较多，所以设计用户能直接在选项栏中进行输入以进行模糊搜索，同时需要对用户的操作进行初步的判断与纠错，以减轻后端的负担，例如，用户未输入站点就点击提交时，提示用户输入站点，而不是直接把数据提交给后端处理查询。</p><h4 id="获取最短路径"><a href="#获取最短路径" class="headerlink" title="获取最短路径"></a>获取最短路径</h4><p>获取最短路径是本系统的核心算法，为了实现最短路径的查询，使用广度优先搜索BFS算法，这样可以较快的找到经过站点最少的地铁线路。</p><h4 id="换乘判断"><a href="#换乘判断" class="headerlink" title="换乘判断"></a>换乘判断</h4><p>为了方便用户进行路线的规划，本系统需要展示换乘站点，为了实现换乘站点的查询，需要进行换乘判断，并输出将要换乘的线路。</p><h4 id="缩略地图放大"><a href="#缩略地图放大" class="headerlink" title="缩略地图放大"></a>缩略地图放大</h4><p>为了让用户在查询查询前能找到想去的站点，差查询后能对查找到的线路进行概览，需要将界面上缩略地图进行局部的放大，以便于用户方便的查看大地图。</p><p><img src="https://img-blog.csdnimg.cn/ef1f6e21aa5c43baa3ed2a09c400de29.png" alt="欢迎界面"><br><img src="https://img-blog.csdnimg.cn/ecab171b5417476db0ee3cff54b72582.jpeg" alt="线路查找示意"></p>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>王道数据结构书-线性表作业2</title>
      <link href="/2023/03/23/2023-3-23-%E7%8E%8B%E9%81%93%E7%AE%97%E6%B3%95%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/03/23/2023-3-23-%E7%8E%8B%E9%81%93%E7%AE%97%E6%B3%95%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="太菜了-简单题也要看答案的思路-T-T"><a href="#太菜了-简单题也要看答案的思路-T-T" class="headerlink" title="太菜了,简单题也要看答案的思路 T T"></a>太菜了,简单题也要看答案的思路 T T</h3><div class="row">    <embed src="https://pic-bed-1wt.pages.dev/files/2022王道算法2.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王道数据结构书-线性表作业1</title>
      <link href="/2023/03/19/2023-3-19-%E7%8E%8B%E9%81%93%E7%AE%97%E6%B3%95%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2023/03/19/2023-3-19-%E7%8E%8B%E9%81%93%E7%AE%97%E6%B3%95%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="https://pic-bed-1wt.pages.dev/files/2022王道算法1.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《惠子，凝视》：比赛落幕，生活如旧</title>
      <link href="/2023/02/23/2023-2-23-%E3%80%8A%E6%83%A0%E5%AD%90%EF%BC%8C%E5%87%9D%E8%A7%86%E3%80%8B/"/>
      <url>/2023/02/23/2023-2-23-%E3%80%8A%E6%83%A0%E5%AD%90%EF%BC%8C%E5%87%9D%E8%A7%86%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="《惠子，凝视》：比赛落幕，生活如旧"><a href="#《惠子，凝视》：比赛落幕，生活如旧" class="headerlink" title="《惠子，凝视》：比赛落幕，生活如旧"></a>《惠子，凝视》：比赛落幕，生活如旧</h1><p>心情乱糟糟的，挑了一个之前收藏的日影来缓解一下。<br>电影的对话很少，但影调有惊艳到我，非常浓的日影味。刚开始不知道女主的情况，还纳闷为什么女主一直不说话。<br>明明只是个大学生，就这么喜欢日影，感觉有点太老成了。惠子先天失聪，会长大病，全馆也关了，最后收到大家瞩目的比赛也输了<br>惠子最强烈的情感表达，也只是因为听不到裁判的声音而错失机会的怒号。<br>无论怎样，生活仍在继续，次日黄昏，惠子依然出现在河畔跑步，在工作时指导后辈折好床单角。<br>惠子回到了酒店工作，惠子的对手回到了建筑工地，无关赛场上的胜负，一切喧嚣最终都会归于寂静。<br><img src="https://pic-bed-1wt.pages.dev/img/《惠子，凝视》.jpg" style= 'width="80%" align="left"'>  </p>]]></content>
      
      
      <categories>
          
          <category> 观影墙 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影 </tag>
            
            <tag> 日影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鼠鼠の寒假Vlog</title>
      <link href="/2023/02/19/2023-2-20-%E9%BC%A0%E9%BC%A0Vlog/"/>
      <url>/2023/02/19/2023-2-20-%E9%BC%A0%E9%BC%A0Vlog/</url>
      
        <content type="html"><![CDATA[<h3 id="鼠鼠我呀，要暑假才能再见到鼠鼠了捏"><a href="#鼠鼠我呀，要暑假才能再见到鼠鼠了捏" class="headerlink" title="鼠鼠我呀，要暑假才能再见到鼠鼠了捏"></a>鼠鼠我呀，要暑假才能再见到鼠鼠了捏</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=567231124&bvid=BV15v4y1s7VB&cid=1016043469&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><h3 id="整个活"><a href="#整个活" class="headerlink" title="整个活"></a>整个活</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=267212852&bvid=BV1HY411Y7PJ&cid=1016135232&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div>]]></content>
      
      
      <categories>
          
          <category> 茶余饭后 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vlog </tag>
            
            <tag> 动物朋友 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拿证！</title>
      <link href="/2023/02/17/2023-2-17-%E6%8B%BF%E8%AF%81%EF%BC%81/"/>
      <url>/2023/02/17/2023-2-17-%E6%8B%BF%E8%AF%81%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h3 id="拿证啦！花了一个月时间终于拿到了"><a href="#拿证啦！花了一个月时间终于拿到了" class="headerlink" title="拿证啦！花了一个月时间终于拿到了"></a>拿证啦！花了一个月时间终于拿到了</h3><p>　　练车第一天遇见的大叔，一开始就是练踩油门和挂挡，大叔看我无聊，过来教我倒车入库，他随便教了下，我还真学会了，后面也总是看见他。刚开始还以为大叔是个很闲的人，后来知道他在驾校附近的工厂工作，跟我一样想早点拿证，所以就也天天来练车。最后结果也不错，我们科目一到科目三都是一起考试的，都是一遍过。本来昨天科四还在到处找他没看见，应该以后也见不到他了吧…应该加个微信的，还有一个小姐姐，也是一起考的科二，也祝她暑假科三一把过。<br>　　没想到考驾照能直接全部一把过，如果挂了还要多花不少钱呢。<br>　　总之痛苦的学车生活结束了，暑假也不用再晒大太阳去练车了，寒假一个月拿证的flag也实现了，其实开车真的不难，而且开习惯了开那种好开的路感觉还很爽。<br>　　感谢教练，感谢一起练车的大叔！<br><img src="https://pic-bed-1wt.pages.dev/img/拿证1.png" width="50%"><br><img src="https://pic-bed-1wt.pages.dev/img/拿证2.png" width="50%"></p>]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大二学生寒假自律的一天</title>
      <link href="/2023/02/10/2023-2-11-%E8%9C%88%E8%9A%A3%E5%A4%A7%E5%AD%A6%E7%94%9F%E8%87%AA%E5%BE%8B%E7%9A%84%E4%B8%80%E5%A4%A9Vlog/"/>
      <url>/2023/02/10/2023-2-11-%E8%9C%88%E8%9A%A3%E5%A4%A7%E5%AD%A6%E7%94%9F%E8%87%AA%E5%BE%8B%E7%9A%84%E4%B8%80%E5%A4%A9Vlog/</url>
      
        <content type="html"><![CDATA[<h3 id="家访班会展示用，制作时长两时半-gt"><a href="#家访班会展示用，制作时长两时半-gt" class="headerlink" title="家访班会展示用，制作时长两时半:&gt;"></a>家访班会展示用，制作时长两时半:&gt;</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=779212716&bvid=BV1J14y1c7sJ&cid=1002396299&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div>]]></content>
      
      
      <categories>
          
          <category> 茶余饭后 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vlog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科三一把过</title>
      <link href="/2023/02/10/2023-2-10-%E7%A7%91%E4%B8%89%E4%B8%80%E6%8A%8A%E8%BF%87/"/>
      <url>/2023/02/10/2023-2-10-%E7%A7%91%E4%B8%89%E4%B8%80%E6%8A%8A%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="本人于公元2023年2月2日进行的科目三-道路驾驶技能考试一次通过，特此公告！"><a href="#本人于公元2023年2月2日进行的科目三-道路驾驶技能考试一次通过，特此公告！" class="headerlink" title="本人于公元2023年2月2日进行的科目三 道路驾驶技能考试一次通过，特此公告！"></a>本人于公元2023年2月2日进行的科目三 道路驾驶技能考试一次通过，特此公告！</h3><!-- ![成绩](https://pic-bed-1wt.pages.dev/img/%E7%A7%91%E7%9B%AE%E4%B8%89.png) --><p><img src="https://pic-bed-1wt.pages.dev/img/拿证1.png" width="50%"></p>]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科二一把过</title>
      <link href="/2023/02/02/2023-2-2-%E7%A7%91%E4%BA%8C%E4%B8%80%E6%8A%8A%E8%BF%87/"/>
      <url>/2023/02/02/2023-2-2-%E7%A7%91%E4%BA%8C%E4%B8%80%E6%8A%8A%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="本人于公元2023年2月2日进行的场地驾驶技能考试（科目二）一次通过，特此公告（狗头）！"><a href="#本人于公元2023年2月2日进行的场地驾驶技能考试（科目二）一次通过，特此公告（狗头）！" class="headerlink" title="本人于公元2023年2月2日进行的场地驾驶技能考试（科目二）一次通过，特此公告（狗头）！"></a>本人于公元2023年2月2日进行的场地驾驶技能考试（科目二）一次通过，特此公告（狗头）！</h3>]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初学MarkDown语法</title>
      <link href="/2023/01/29/2023-1-29-%E5%88%9D%E5%AD%A6md%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/01/29/2023-1-29-%E5%88%9D%E5%AD%A6md%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="初学MarkDown语法"><a href="#初学MarkDown语法" class="headerlink" title="初学MarkDown语法"></a>初学MarkDown语法</h1><p>年差不多过完了，想写写博客发现没学过md语法…</p><h2 id="学习资料："><a href="#学习资料：" class="headerlink" title="学习资料："></a>学习资料：</h2><p><a href="https://blog.csdn.net/TeFuirnever/article/details/104255022?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167500645516800213086410%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167500645516800213086410&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-104255022-null-null.142^v71^one_line,201^v4^add_ask&amp;utm_term=markdown&amp;spm=1018.2226.3001.4187">Markdown入门指南</a></p><p><a href="https://www.bilibili.com/video/BV1JA411h7Gw/?spm_id_from=333.1007.top_right_bar_window_history.content.click">参考视频：8分钟让你快速掌握Markdown</a></p><p><a href="https://www.fomal.cc/posts/2013454d.html">Markdown语法与外挂标签写法汇总</a></p><p><strong>以下是这次学习的练手</strong></p><hr><h1 id="块元素"><a href="#块元素" class="headerlink" title="==块元素=="></a>==块元素==</h1><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="…"><a href="#…" class="headerlink" title="…"></a>…</h3><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><p>==我是高亮==</p><p><em>倾斜</em><br><strong>加粗</strong><br><strong><em>倾斜且加粗</em></strong><br><del>划掉</del><br>我是^上标^<br>我是~下标~</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ul><li>一二三四五<ul><li>上山打老虎<ul><li>老虎没打到<ul><li>打到小松鼠</li></ul></li></ul></li></ul></li></ul><ol><li>一二三四五</li><li>上山打老虎</li><li>老虎没打到</li><li>打到小松鼠</li></ol><p>明天要做的事:</p><ul><li>[ ] 吃饭</li><li>[ ] 睡觉</li><li>[x] 打豆豆</li></ul><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><div class="table-container"><table><thead><tr><th style="text-align:center">Mon</th><th style="text-align:center">Tue</th><th style="text-align:center">Wed</th><th style="text-align:center">Thu</th><th style="text-align:center">Fri</th><th style="text-align:center">Sat</th><th style="text-align:center">Sun</th></tr></thead><tbody><tr><td style="text-align:center">上山</td><td style="text-align:center">上山</td><td style="text-align:center">上山</td><td style="text-align:center">上山</td><td style="text-align:center">上山</td><td style="text-align:center">上山</td><td style="text-align:center">上山</td></tr></tbody></table></div><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><code>我是单行代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>这是一段引用</p></blockquote><h2 id="行文"><a href="#行文" class="headerlink" title="行文"></a>行文</h2><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>我是<sup><a href="#fn_脚注" id="reffn_脚注">脚注</a></sup></p><p>横线</p><hr><h1 id="行元素"><a href="#行元素" class="headerlink" title="==行元素=="></a>==行元素==</h1><p><a href="www.bilibili.com" title="一个视频网站">b站</a></p><p><a href="www.bilibili.com" title="一个视频网站">b站</a></p><p>请参考<a href="# 块元素">块元素</a></p><p>ULR:<br><a href="http://www.bilibili.com">http://www.bilibili.com</a></p><iframe src="//player.bilibili.com/player.html?aid=327623069&bvid=BV1JA411h7Gw&cid=171385214&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20岁生日随笔</title>
      <link href="/2023/01/19/2023-1-19-20%E5%B2%81%E7%94%9F%E6%97%A5%E9%9A%8F%E7%AC%94/"/>
      <url>/2023/01/19/2023-1-19-20%E5%B2%81%E7%94%9F%E6%97%A5%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<h3 id="20岁生日随笔-作为网站第一篇文章补档发布"><a href="#20岁生日随笔-作为网站第一篇文章补档发布" class="headerlink" title="20岁生日随笔 作为网站第一篇文章补档发布~"></a>20岁生日随笔 作为网站第一篇文章补档发布~</h3><p>感觉还没反应过来就已经二十了<br>我从未像今年一样，决绝的彻底的想要告别我的19岁，迎接20岁。20岁真的会好吗？说实话我也不知道。只能说，答案在空中飘荡。<br>进入大学后，总是陷入周期性的焦虑，渐渐失掉了高中时高远的追求，又被无力感所裹挟，不知道未来会怎样。我开始厌倦用宏大叙事，用公共的视角看待社会，厌倦应付学校中那些不必要的形式，面对不断涌入的负面信息，我选择了逃避；我发现在时代的洪流面前，逃避和退缩也许并不可耻。与其试图改变无法改变的事，不如趁着秋日午后，爬上宿舍天台，蹲守一朵檐上的云；不如约上三两好友，去巷角的咖啡店，打扰猫咪的甜梦；安心于当下，享受每一个“非必要的瞬间”。<br>于是，我开始学着变得简单，变得不再贪婪，只愿这一生有所值得。新的一岁，我要明确地爱，直接的厌恶，真诚的喜欢，拥有站在太阳下的坦荡，大声无愧地称赞自己。祝我的朋友们，值得一切。快乐，平安，炽热或静好，努力收获回报！<br>“你且听这荒唐 春秋走来一步步，你且迷这风浪 永远二十赶朝暮，将昨日事，归欢喜处，我们都需要自渡。”</p>]]></content>
      
      
      <categories>
          
          <category> 茶余饭后 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>优质转载测试</title>
      <link href="/2023/01/19/2023-1-19-%E4%BC%98%E8%B4%A8%E8%BD%AC%E8%BD%BD/"/>
      <url>/2023/01/19/2023-1-19-%E4%BC%98%E8%B4%A8%E8%BD%AC%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="这是第一篇优质转载"><a href="#这是第一篇优质转载" class="headerlink" title="这是第一篇优质转载"></a>这是第一篇优质转载</h2>]]></content>
      
      
      <categories>
          
          <category> 优质转载 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>知识笔记测试</title>
      <link href="/2023/01/19/2023-1-19-%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/19/2023-1-19-%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是第一篇知识笔记"><a href="#这是第一篇知识笔记" class="headerlink" title="这是第一篇知识笔记"></a>这是第一篇知识笔记</h2><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法学习测试</title>
      <link href="/2023/01/19/2023-1-19-%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/01/19/2023-1-19-%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是第一篇算法学习测试"><a href="#这是第一篇算法学习测试" class="headerlink" title="这是第一篇算法学习测试"></a>这是第一篇算法学习测试</h2>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>生活日常测试</title>
      <link href="/2023/01/19/2023-1-19-%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8/"/>
      <url>/2023/01/19/2023-1-19-%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="这是一篇测试"><a href="#这是一篇测试" class="headerlink" title="这是一篇测试"></a>这是一篇测试</h2>]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
