<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java基础刷题笔记9</title>
      <link href="/2023/10/17/2023-10-17-java%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B09/"/>
      <url>/2023/10/17/2023-10-17-java%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B09/</url>
      
        <content type="html"><![CDATA[<h1 id="Java刷题笔记9"><a href="#Java刷题笔记9" class="headerlink" title="Java刷题笔记9"></a>Java刷题笔记9</h1><h2 id="T1-又是类内执行顺序"><a href="#T1-又是类内执行顺序" class="headerlink" title="T1  又是类内执行顺序"></a>T1  又是类内执行顺序</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310172020698.png" alt="image-20231017201429605"></p><p>类中的静态部分,从上到下运行,先遇见谁执行谁;<br>所以先执行<code>publicstaticTest t1 =</code>new <code>Test();</code></p><p>在new Test()的过程中已经执行了一次静态成员函数的初始化了,所以接着往下执行,<strong><u>关于static的运行是类的事,实例化的过程中不管他</u></strong>,所以接着输出了A</p><p>再找到静态块static,这里输出B</p><p>最后在main方法中,重复了一次实例化的过程,输出A</p><h2 id="T2-自动转型"><a href="#T2-自动转型" class="headerlink" title="T2 自动转型"></a>T2 自动转型</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310172032950.png" alt="image-20231017203231893"></p><p>你是懂自动转型的</p><blockquote><p>被final修饰的变量是常量，这里的b6=b4+b5可以看成是b6=10；在编译时就已经变为b6=10了</p><p> 而b1和b2是byte类型，java中进行计算时候将他们提升为int类型，再进行计算，b1+b2计算后已经是int类型，赋值给b3，b3是byte类型，类型不匹配，编译不会通过，需要进行强制转换。</p><p> Java中的byte，short，char进行计算时都会提升为int类型。</p></blockquote><h2 id="T3-类的构造-amp-继承-amp-实例化"><a href="#T3-类的构造-amp-继承-amp-实例化" class="headerlink" title="T3 类的构造&amp;继承&amp;实例化"></a>T3 类的构造&amp;继承&amp;实例化</h2><p>Test.main()函数执行后的输出是（ ）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">B</span>().getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">A</span> <span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">            setValue(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value= value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                value ++;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.setValue(value);</span><br><span class="line">                System.out.println(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">B</span> <span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="number">5</span>);</span><br><span class="line">            setValue(getValue()- <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.setValue(<span class="number">2</span> * value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A    6 7 7</p><p>B    22 34 17</p><p>C    22 74 74</p><p>D    11 17 34</p><blockquote><p><strong>第一个数值</strong></p><ol><li><p>new B()构造B类实例对象，进入B类的构造方法，B类构造方法的第一行代码用super(5)调用了父类带有参数的构造函数，父类的构造函数又调用了setValue()方法，但值得注意的是，<strong>子类中的方法覆盖父类的方法以后，由于向上转型，父类调用的方法实际上是子类的</strong>。那么这里的setValue(v);调用了B类的setValue()方法，而B类中setValue()方法又使用<strong>super</strong>关键字调用了父类的setValue()方法，将B实例的value值设置为2 x 5 = 10。那么到这里，B类的构造函数中第一行代码super(5)执行完毕，程序继续向下执行进入setValue(getValue()- 3);代码块。</p></li><li><p>这里先执行getValue()方法，但因为B类中并没有重写该方法，这里需要调用父类的getValue()方法。进入A类getValue()方法，首先是value++，那么此时B的成员变量value值由 10变为11，程序继续向下执行，将11作为返回值，但此处要注意的一点是，在<strong>Try catch finally**</strong>体系当中，在return之前始终会执行finally里面的代码，如果finally里面有return，则数据跟随finally改变。如果没有return，则原数据不跟随finally里改变的数据改变。<strong>那么进入finally代码块，由于此时正在初始化的是B类的一个对象（运行时多态），因此调用B类的setValue()方法。B类的setValue()方法中使用</strong>super<em>*关键字调用了父类的setValue()方法，将原有的value</em>2，即11 x 2 = 22，继续向下进行System.out.println(value);输出第一个数值22。随后，A类的getValue()方法将之前暂存的value=11返回。</p></li></ol><p><strong>第二个数值</strong></p><ol><li><p>拿到getValue()方法返回值之后程序继续运行，此处代码变为setValue(11- 3);根据和之前相同的流程，B类成员变量value的值变为16。程序运行到此处，new B()执行完毕。</p></li><li><p>回到main函数中，实例化的B类对象调用getValue()方法，B类中并没有重写该方法，需要调用父类的getValue()方法。getValue()方法第一行代码value++将B的成员变量value值变为17，此时执行到return代码，将value=17暂存，等待finally代码块运行完毕后返回。</p></li><li><p>此处finally代码块执行流程和之前相同，这里不再赘述。那么执行完this.setValue(value);后，value值变为2 x 17 = 34。继续向下进行System.out.println(value);输出第二个数值34，return刚刚暂存的value=17。</p></li></ol><p><strong>第三个数值</strong></p><p>回到main函数，将刚刚返回的值输出，就得到了第三个数值17。</p><p>综上所述，本题正确答案为B。</p></blockquote><h2 id="T4-异常发现时机"><a href="#T4-异常发现时机" class="headerlink" title="T4 异常发现时机"></a>T4 异常发现时机</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310192319077.png" alt="image-20231019231950987"></p><blockquote><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310192320806.png" alt="img"></p><p>编译时能被发现的是必须加上try catch的异常，这些异常在编译时可以被发现，如果异常编译时不一定发生，如除以0异常，指针为空异常。</p></blockquote><h2 id="T5-集合的线程安全"><a href="#T5-集合的线程安全" class="headerlink" title="T5 集合的线程安全"></a>T5 集合的线程安全</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310192321522.png" alt="image-20231019232131480"></p><blockquote><p>基本上我们平常用到的都是非线程安全的集合类，因为要使线程安全，是要加锁来实现的，势必造成性能降低。如hashset、hashmap、arraylist、linkedlist、treemap、treeset、stringbulider等。 </p><p>  像stringbuffer、vector、hashtable这些都是专用于多线程的，再者以concurrent（意为：同时发生的）为前缀的集合类大多是线程安全的。</p><p>作者：72%<br>链接：<a href="https://www.nowcoder.com/exam/test/75216289/submission?pid=53805751">https://www.nowcoder.com/exam/test/75216289/submission?pid=53805751</a><br>来源：牛客网</p></blockquote><h2 id="T6-字符串split方法"><a href="#T6-字符串split方法" class="headerlink" title="T6 字符串split方法"></a>T6 字符串split方法</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310192355435.png" alt="image-20231019235522396"></p><blockquote><p>String split 这个方法默认返回一个数组，   如果没有找到分隔符，   会把整个字符串当成一个长度为1的字符串数组返回到结果， 所以此处结果就是1 </p></blockquote><h2 id="T7-线程创建方式"><a href="#T7-线程创建方式" class="headerlink" title="T7 线程创建方式"></a>T7 线程创建方式</h2><p>创建线程对象两种方式： </p><ol><li>继承Thread类，重载run方法</li><li>实现Runnable接口，实现run方法 </li></ol>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23/10/16 算法每日一题</title>
      <link href="/2023/10/16/2023-10-16-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/10/16/2023-10-16-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>1、油壶里有10升油，现在只有两个分别能装3升和7升油的瓶子，需要将10 升油等分成2 个5 升油。程序输出分油次数最少的详细操作过程。</p><p>选作：将油壶的容量改为L 升，两个瓶子的容量分别为M 和N 升，其中：L、M和N 均为正整数，且L 为正偶数、L = M + N，输出利用这两个瓶子将油壶中油等分的最少操作过程，如果不能等分，输出“None”。</p><h3 id="按照下面的思路进行模拟"><a href="#按照下面的思路进行模拟" class="headerlink" title="按照下面的思路进行模拟"></a>按照下面的思路进行模拟</h3><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310162016338.png" alt="image-20231016201325358"></p><h3 id="输出None时的判断"><a href="#输出None时的判断" class="headerlink" title="输出None时的判断"></a>输出None时的判断</h3><p>参考倒水问题,这里相当于是倒水问题的特解</p><p><a href="https://blog.csdn.net/lanchunhui/article/details/50594649">倒水问题的万能解法（扩展欧几里得算法）</a></p><h3 id="Java算法实现"><a href="#Java算法实现" class="headerlink" title="Java算法实现"></a>Java算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//package src.main.com.hantouInWIT2021.test1;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入大壶,和两个杯子的容量: &quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">        String[] s1 = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> Integer.parseInt(s1[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> Integer.parseInt(s1[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(s1[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;第 1 种方案：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">min1</span> <span class="operator">=</span> pull(l, m, n);</span><br><span class="line">        System.out.println(<span class="string">&quot;第 2 种方案：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">min2</span> <span class="operator">=</span> pull(l, n, m);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (min1==-<span class="number">1</span>&amp;&amp;min2==-<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (min1==-<span class="number">1</span>&amp;&amp;min2!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第 2 种方案步骤最少。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (min1 != -<span class="number">1</span> &amp;&amp; min2 == -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第 1 种方案步骤最少。&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (min1 &gt; min2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;第 2 种方案步骤最少。&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;第 1 种方案步骤最少。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b, a%b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">pull</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((l/<span class="number">2</span>)%gcd(m,n)!=<span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;None&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (a != l / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a + b &lt;= m) &#123;</span><br><span class="line">                a = <span class="number">0</span>;</span><br><span class="line">                b += a;</span><br><span class="line">                System.out.println(++cnt + <span class="string">&quot;: &quot;</span> + l + <span class="string">&quot;L容器向 &quot;</span> + m + <span class="string">&quot; L容器倒入 &quot;</span> + m + <span class="string">&quot; L油&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(++cnt + <span class="string">&quot;: &quot;</span> + l + <span class="string">&quot;L容器向 &quot;</span> + m + <span class="string">&quot; L容器倒入 &quot;</span> + (m - b) + <span class="string">&quot; L油&quot;</span>);</span><br><span class="line">                a -= (m - b);</span><br><span class="line">                b = m;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b == l / <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (b + c &lt;= n) &#123;</span><br><span class="line">                    c += b;</span><br><span class="line">                    System.out.println(++cnt + <span class="string">&quot;: &quot;</span> + m + <span class="string">&quot; L容器向 &quot;</span> + n + <span class="string">&quot; L容器倒入 &quot;</span> + b + <span class="string">&quot; L油&quot;</span>);</span><br><span class="line">                    b = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    b -= (n - c);</span><br><span class="line">                    System.out.println(++cnt + <span class="string">&quot;: &quot;</span> + m + <span class="string">&quot; L容器向 &quot;</span> + n + <span class="string">&quot; L容器倒入 &quot;</span> + (n - c) + <span class="string">&quot; L油&quot;</span>);</span><br><span class="line">                    c = n;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == n) &#123;</span><br><span class="line">                    a += n;</span><br><span class="line">                    c = <span class="number">0</span>;</span><br><span class="line">                    System.out.println(++cnt + <span class="string">&quot;: &quot;</span> + n + <span class="string">&quot; L容器向 &quot;</span> + l + <span class="string">&quot; L容器倒入 &quot;</span> + n + <span class="string">&quot; L油&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(b==l/<span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6046 L3 快速傅里叶变换 学习笔记</title>
      <link href="/2023/10/14/2023-10-14-MIT6-046%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-L3-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/10/14/2023-10-14-MIT6-046%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-L3-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="MIT6-046算法设计-L3-快速傅里叶变换-分治思想-学习笔记"><a href="#MIT6-046算法设计-L3-快速傅里叶变换-分治思想-学习笔记" class="headerlink" title="MIT6.046算法设计 L3 快速傅里叶变换(分治思想) 学习笔记"></a>MIT6.046算法设计 L3 快速傅里叶变换(分治思想) 学习笔记</h1><blockquote><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310161208224.png" alt="warning"><br>这是一篇不求甚解的笔记(因为作者太菜),只是大概的粗略的了解了一下快速傅里叶变换的的分治思想<br>你看<strong>这篇文章并不能让你学会FFT!</strong><br><strong>这篇笔记真的很水!</strong></p><p>推荐视频:<br><a href="https://www.bilibili.com/video/BV1za411F76U/?spm_id_from=333.337.search-card.all.click&amp;vd_source=ccb7919bcde1355acd4bb39725e50302">快速傅里叶变换(FFT)——有史以来最巧妙的算法？</a></p></blockquote><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>对于一个多项式A(x)=a0+a1x+a2x^2+…+a(n-1)x^(n-1)</p><h3 id="其有多少种不同的表示方式"><a href="#其有多少种不同的表示方式" class="headerlink" title="其有多少种不同的表示方式"></a>其有多少种不同的表示方式</h3><ol><li><p>系数表达<br>可以将多项式抽象为一个向量(a0,a1,a2,a3,…an−1); 每个向量都与一个多项式一一对应</p></li><li><p>点值表达,对于一个多项式,给定n个数值x0,x1,….,x(n-1)带入A(x)即可确定一个n-1项的多项式</p><blockquote><p>n个点可以确定一个n-1的多项式</p></blockquote></li><li><p>加法式?<br><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310161123066.png" alt="image-20231016112119135"></p></li></ol><h3 id="多项式不同表达方法对多项式计算的时间复杂度"><a href="#多项式不同表达方法对多项式计算的时间复杂度" class="headerlink" title="多项式不同表达方法对多项式计算的时间复杂度"></a>多项式不同表达方法对多项式计算的时间复杂度</h3><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310161124160.png" alt="image-20231016112413080"></p><h3 id="如何获取最佳的多项式运算的时间复杂度"><a href="#如何获取最佳的多项式运算的时间复杂度" class="headerlink" title="如何获取最佳的多项式运算的时间复杂度?"></a>如何获取最佳的多项式运算的时间复杂度?</h3><p>从上图中我们可以看出,系数表达式的乘法较为复杂,而点值表达的求值运算比较复杂<br>有没有一种方法,能让系数表达方法和点值表达方法之间相互转换,让所有运算都能在O(n)时间复杂度内完成?</p><h2 id="快速傅里叶变换-FFT"><a href="#快速傅里叶变换-FFT" class="headerlink" title="快速傅里叶变换 FFT"></a>快速傅里叶变换 FFT</h2><h3 id="如果我们需要求两个多项式的乘积"><a href="#如果我们需要求两个多项式的乘积" class="headerlink" title="如果我们需要求两个多项式的乘积"></a>如果我们需要求两个多项式的乘积</h3><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310161154218.png" alt="image-20231016115416131"></p><p>比如Ax,Bx都是2阶的多项式,他们的乘积C则为4阶多项式,需要5个点来确定; 我们从AB各取x相同的5个点,然后把他们相乘,带入C,就能求出C了</p><p>通过这样的计算,计算多项式乘法的时间一下从O(n^2)缩短为O(n)</p><h3 id="怎么取点更快更好"><a href="#怎么取点更快更好" class="headerlink" title="怎么取点更快更好?"></a>怎么取点更快更好?</h3><p>多项式可以拆成两个子式子嘛,一个奇一个偶,都只需要求x的正或负半轴就能知道另外半边的值,这样计算量又少了一半<br>所以我们需要做的是,把多项式拆成奇偶两部分,对他们分开计算,然后再合并求值,计算出他们相乘后得到的新的多项式就行</p><h3 id="还能更好吗"><a href="#还能更好吗" class="headerlink" title="还能更好吗??"></a>还能更好吗??</h3><p>我们知道,对一个数a开方得到数b,b^2显然等于a</p><p>如果重复上面的分奇偶的部分,就差不多是不断地找平方根x</p><h4 id="这里要引入一个单位根的概念"><a href="#这里要引入一个单位根的概念" class="headerlink" title="这里要引入一个单位根的概念"></a>这里要引入一个单位根的概念</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310161203684.png" alt="image-20231016120326592"></h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310161204335.png" alt="image-20231016120418280"></p><h3 id="傅里叶算法"><a href="#傅里叶算法" class="headerlink" title="傅里叶算法"></a>傅里叶算法</h3><p>FFT算法的输入是多项式的n个系数其中n是2的幂次，我们取为1的n次方根，递归的底层情况是n=1，此时我们只在一个点上求多项式的值。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9b09342cb435e71a1231faac2e5e53cc.png" alt="img"></p><p>递归的主要命令就是把多项式拆分成奇/偶函数两部分，两部分就是调用函数两次，此时这两个子多项式函数都是n/2阶的，所以对应的求值点将是1的n/2次方根。</p>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6046 R1 矩阵乘法与主定理 学习笔记</title>
      <link href="/2023/10/14/2023-10-14-MIT6-046-R1-%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E4%B8%8E%E4%B8%BB%E5%AE%9A%E7%90%86-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/10/14/2023-10-14-MIT6-046-R1-%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E4%B8%8E%E4%B8%BB%E5%AE%9A%E7%90%86-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="MIT6-046算法设计-R1-矩阵乘法与主定理-学习笔记"><a href="#MIT6-046算法设计-R1-矩阵乘法与主定理-学习笔记" class="headerlink" title="MIT6.046算法设计 R1 矩阵乘法与主定理 学习笔记"></a>MIT6.046算法设计 R1 矩阵乘法与主定理 学习笔记</h1><h2 id="带权区间调度"><a href="#带权区间调度" class="headerlink" title="带权区间调度"></a>带权区间调度</h2><p>在L1中我们学习了区间调度</p><h3 id="现在对每个任务加权-要如何处理得到最大和"><a href="#现在对每个任务加权-要如何处理得到最大和" class="headerlink" title="现在对每个任务加权,要如何处理得到最大和?"></a>现在对每个任务加权,要如何处理得到最大和?</h3><p>假设每一个任务都是潜在的第一个被执行的任务,将这个任务设为任务j,则得到他的权重w[j]; </p><p>对于j后面的任务,我们也进行同样的尝试,定义Rj为{ i | s(i) &gt; f(j)},解释一下,Rj是请求的集合,其中他们的完成时间晚于第j个请求的停止时间</p><p>我们称原来的问题为WIS(1,2,….n),则可以将其拆分为若干子问题</p><blockquote><p>WIS: Weighted Interval Scheduling 带权区间调度</p></blockquote><p>最终不断地解决子问题,最后得到答案为 max(j&lt;=j&lt;=n){w[j]+WIS(R[j])}, <strong>时间复杂度为n^2</strong></p><h3 id="Can-we-do-better"><a href="#Can-we-do-better" class="headerlink" title="Can  we do better?"></a>Can  we do better?</h3><h4 id="哪里拖慢了效率"><a href="#哪里拖慢了效率" class="headerlink" title="哪里拖慢了效率?"></a>哪里拖慢了效率?</h4><p>上面的方法对所有的子问题都进行了尝试,包括那些明显不满足条件的</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310141154450.png" alt="image-20231014114846004"></p><blockquote><p>具体来说,当我们尝试了请求2作为开始的请求后,对于以请求3开始的子问题,其实是请求2作为开头的请求的子问题,就是 以请求3开头的结果的权重和 等于 以2开头的权重和 减去 请求2的权重</p><p>而上面的算法又从头对以2开头的子问题 的 子问题进行了一次计算,造成了重复计算, 明明只需要减去2的权重就完事了,不是吗</p></blockquote><h4 id="Let’s-do-this"><a href="#Let’s-do-this" class="headerlink" title="Let’s do this"></a>Let’s do this</h4><p>对上面的算法进行改造,根据分析,显然不应该尝试所有可能的请求</p><h5 id="问题来了-如何找到适合作为开头的请求"><a href="#问题来了-如何找到适合作为开头的请求" class="headerlink" title="问题来了,如何找到适合作为开头的请求?"></a>问题来了,如何找到适合作为开头的请求?</h5><p>对于上面图中的例子,显然只选择1,2是更好的</p><p>将请求按照开始时间进行排序,我们应该首先考虑开始时间较早的请求</p><p><strong>考虑一个问题: 如何取舍请求1呢</strong></p><p>WIS(1,2…,n)= max{WIS(2,…,n)+w[1],WIS(R1)}</p><blockquote><p>解释: 在考虑请求1的权值和 与 在请求1结束后开始的所有可能结果进行比较</p></blockquote><p>递归树图</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310141205193.png" alt="image-20231014120541132"></p><h5 id="开始解决问题"><a href="#开始解决问题" class="headerlink" title="开始解决问题"></a>开始解决问题</h5><ol><li>对所有请求,按照开始时间进行递增排序 O(nlogn)</li><li>参考上图的递归树,进行自底向上递归 O(n)</li></ol><p><strong>复杂度为O(nlogn)</strong></p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>改进后的算法,对于每个子问题,只需要进行一次max计算(因为子问题已经在自底向上的过程中被算过了,只需要加一次当前判断的权; )</p><p>而对于改进前的的算法,每一层向上递归都会增加一个可能性,而且需要进行重复计算,所以他的层数是1+2+3+…+n,复杂度为O(n^2)</p><h2 id="矩阵乘法中的Strassen算法"><a href="#矩阵乘法中的Strassen算法" class="headerlink" title="矩阵乘法中的Strassen算法"></a>矩阵乘法中的Strassen算法</h2><h3 id="矩阵乘法-很复杂吧"><a href="#矩阵乘法-很复杂吧" class="headerlink" title="矩阵乘法, 很复杂吧?"></a>矩阵乘法, 很复杂吧?</h3><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310141219090.webp" alt="img"></p><p>显然,这个朴素的算矩阵乘法的时间复杂度为O(n^3)</p><h3 id="我超-Strassen"><a href="#我超-Strassen" class="headerlink" title="我超,Strassen!"></a>我超,Strassen!</h3><p>没想到吧,存在小于O(n^3)的算法</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310141226168.png" alt="image-20231014122607096"></p><p>得到递推公式</p><p><strong>T(n) = 8*T(n/2) + O((n/2)^2)</strong>      (8次矩阵乘法,4次矩阵加法 + 矩阵合并)</p><h3 id="Strassen实现步骤"><a href="#Strassen实现步骤" class="headerlink" title="Strassen实现步骤"></a>Strassen实现步骤</h3><ol><li>按上述方法将ABC分解 O(n)</li><li><p>创建如下矩阵 O(n^2)<br><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310141240561.png" alt="image-20231014124011533"></p></li><li><p>递归计算如下7个矩阵<br><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310141240670.png" alt="image-20231014124034863"></p></li><li><p>通过P计算C   O(n^2)<br><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310141241322.png" alt="image-20231014124115289"></p></li></ol><blockquote><p>以上步骤来自:<br>详解矩阵乘法中的Strassen算法 - Coder LL的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/78657463">https://zhuanlan.zhihu.com/p/78657463</a></p></blockquote><h2 id="Master-Theorem-主定理"><a href="#Master-Theorem-主定理" class="headerlink" title="Master Theorem 主定理"></a>Master Theorem 主定理</h2><h3 id="主定理是用来"><a href="#主定理是用来" class="headerlink" title="主定理是用来"></a>主定理是用来</h3><p>求解递如下归算法的时间复杂度..</p><p>T(n) = aT(n/b) + f(n)</p><p>有三种情况</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310141303640.jpeg" alt="img"></p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310141303888.png" alt="image-20231014130322858"></p><blockquote><p>参考:<br>主定理(Master Theorem) - John Liu的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/113406812">https://zhuanlan.zhihu.com/p/113406812</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础刷题笔记8</title>
      <link href="/2023/10/13/2023-10-13-java%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B08/"/>
      <url>/2023/10/13/2023-10-13-java%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B08/</url>
      
        <content type="html"><![CDATA[<h1 id="Java刷题笔记8"><a href="#Java刷题笔记8" class="headerlink" title="Java刷题笔记8"></a>Java刷题笔记8</h1><h2 id="T1-父类子类的调用"><a href="#T1-父类子类的调用" class="headerlink" title="T1 父类子类的调用"></a>T1 父类子类的调用</h2><p>假定Base b = new Derived（）; 调用执行b.methodOne（）后，输出结果是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodOne</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">      System.out.print(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">      methodTwo();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodTwo</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">      System.out.print(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodOne</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">super</span>.methodOne();</span><br><span class="line">      System.out.print(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodTwo</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">super</span>.methodTwo();</span><br><span class="line">      System.out.print(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案: ABDC</p><blockquote><p>只要是被子类重写的方法，不被super调用都是调用子类方法</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310141009980.jpeg" alt="img"></p></blockquote><h2 id="T2-Hashtable-和-HashMap-的区别"><a href="#T2-Hashtable-和-HashMap-的区别" class="headerlink" title="T2 Hashtable 和 HashMap 的区别"></a>T2 Hashtable 和 HashMap 的区别</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310141016305.png" alt="image-20231014101636256"></p><blockquote><p>HashTable和HashMap的区别（7点）： </p><p>  1.<strong>继承的父类不同</strong>：HashTable继承Dictory类，HashMap继承AbstractMap.但都实现了Map接口； </p><p>  2.<strong>线程安全性不同</strong>：HashTable是线程安全的,适用于多线程；HashMap是非线程安全，更适合于单线程； </p><p>  3.是否提供<strong>contains方法</strong>：HashTable中保留了contains方法，与constainsValue功能相同；HashMap中去掉了contains方法； </p><p>  4.<strong>key和value是否可为null值</strong>：HashTable的key、value都不允许null值；HashMap，null可以作为key； </p><p>  5.<strong>遍历方式的内部实现不同</strong>：HashTable、HashMap都使用了Iterator，HashTable还使用过Enumeration方式；</p><p>  6.<strong>hash值不同</strong>：HashTable直接使用对象的hashCode，而HashMap重新计算hash值。 </p><p>  7.内部使用的<strong>数组初始化和扩容方式不同</strong>：Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂；Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。</p><p>作者：98年饭崽<br>链接：<a href="https://www.nowcoder.com/exam/test/74968216/submission?pid=53634742&amp;testCallback=undefined">https://www.nowcoder.com/exam/test/74968216/submission?pid=53634742&amp;testCallback=undefined</a><br>来源：牛客网</p></blockquote><h2 id="T3-静态方法"><a href="#T3-静态方法" class="headerlink" title="T3 静态方法"></a>T3 静态方法</h2><p>阅读如下代码。 请问，对语句行 test.hello(). 描述正确的有（）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> NowCoder;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Test test=<span class="literal">null</span>;</span><br><span class="line">        test.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A 能编译通过，并正确运行</p><p>B因为使用了未初始化的变量，所以不能编译通过</p><p>C 以错误的方式访问了静态方法</p><p>D 能编译通过，但因变量为null，不能正常运行</p><p>答案: A</p><blockquote><p>静态方法的使用不依靠对象，只看类型，在编译时就确定了</p></blockquote><p>　</p><h2 id="T4-构造方法的调用时机"><a href="#T4-构造方法的调用时机" class="headerlink" title="T4 构造方法的调用时机"></a>T4 构造方法的调用时机</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310141104493.png" alt="image-20231014110410450"></p><blockquote><p>readObject方法只是从文件中还原对象，clone只是一种复制拷贝对象。</p><p>构造函数的作用是完成对象的初始化。当程序执行到new操作符时， 首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化。而选项B、D中，对象的初始化并不是通过构造函数完成的，而是读取别的内存区域中的对象的各个域来完成。</p><p>作者：joso<br>链接：<a href="https://www.nowcoder.com/exam/test/74971287/submission?pid=53636911&amp;testCallback=undefined">https://www.nowcoder.com/exam/test/74971287/submission?pid=53636911&amp;testCallback=undefined</a><br>来源：牛客网</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础刷题笔记7</title>
      <link href="/2023/10/12/2023-10-12-java%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B07/"/>
      <url>/2023/10/12/2023-10-12-java%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B07/</url>
      
        <content type="html"><![CDATA[<h1 id="Java刷题笔记7"><a href="#Java刷题笔记7" class="headerlink" title="Java刷题笔记7"></a>Java刷题笔记7</h1><h2 id="T1-变量定义"><a href="#T1-变量定义" class="headerlink" title="T1 变量定义"></a>T1 变量定义</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310121040816.png" alt="image-20231012103302896"></p><blockquote><p>A. byte的取值范围为[-128, 127]</p><p>B. 可以将<em>null</em>赋给引用类型<em>变量</em>，但不可以将<em>null</em>赋给基本类型<em>变量</em>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D. </span><br><span class="line">double a = 0.9239（√）</span><br><span class="line">double a = 0.9239d（√）</span><br><span class="line">float a = 0.9239f（√）</span><br><span class="line">float a = 0.9239（×）</span><br></pre></td></tr></table></figure></blockquote><h2 id="T2-接口继承"><a href="#T2-接口继承" class="headerlink" title="T2 接口继承"></a>T2 接口继承</h2><blockquote><p>Java中类是单继承，但接口可以多继承，Interfere1 extends Interface2,Interface3… </p></blockquote><h2 id="T3-线程"><a href="#T3-线程" class="headerlink" title="T3 线程"></a>T3 线程</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310121103002.png" alt="image-20231012110312964"></p><blockquote><p>   run()相当于线程的任务处理逻辑的<strong>入口</strong>方法，它由Java虚拟机在运行相应线程时直接调用，而不是由应用代码进行调用。  </p><p>   start()的作用是<strong>启动</strong>相应的线程。启动一个线程实际是请求Java虚拟机运行相应的线程，而这个线程何时能够运行是由线程调度器决定的。start()调用结束并不表示相应线程已经开始运行，这个线程可能稍后运行，也可能永远也不会运行。  </p></blockquote><h2 id="T4-Collection"><a href="#T4-Collection" class="headerlink" title="T4 Collection"></a>T4 Collection</h2><p><img src="https://uploadfiles.nowcoder.com/images/20190626/8063197_1561528276822_5E395ABADA193BD98F733540EDD03F5C" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础刷题笔记6</title>
      <link href="/2023/10/11/2023-10-11-java%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B06/"/>
      <url>/2023/10/11/2023-10-11-java%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B06/</url>
      
        <content type="html"><![CDATA[<h1 id="Java刷题笔记6"><a href="#Java刷题笔记6" class="headerlink" title="Java刷题笔记6"></a>Java刷题笔记6</h1><h2 id="T1-静态变量"><a href="#T1-静态变量" class="headerlink" title="T1  静态变量"></a>T1  静态变量</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310112239695.png" alt="image-20231011223932601"></p><blockquote><p>静态变量只能在类主体中定义，不能在方法中定义</p><p>PS : </p><p><strong>类的final成员变量</strong>必须满足以下其中一个条件<br>    1、在构造函数中赋值<br>    2、定义时初始化赋值<br>    3、初始化块中初始化，但是不可在静态初始化块中初始化，只能是静态的final成员变量才能在静态初始化块中初始化</p></blockquote><h2 id="T2-抽象类-amp-接口"><a href="#T2-抽象类-amp-接口" class="headerlink" title="T2 抽象类 &amp; 接口"></a>T2 抽象类 &amp; 接口</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310112307834.png" alt="image-20231011230751791"></p><blockquote><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>特点:<br>1.抽象类中可以构造方法<br>2.抽象类中可以存在普通属性，方法，静态属性和方法。<br>3.抽象类中可以存在抽象方法。<br>4.<strong>如果一个类中有一个抽象方法，那么当前类一定是抽象类；抽象类中不一定有抽象方法。</strong><br>5.抽象类中的抽象方法，需要有子类实现，<strong>如果子类不实现，则子类也需要定义为抽象的。</strong><br>6.<strong>抽象类不能被实例化，抽象类和抽象方法必须被abstract修饰</strong><br>7.抽象类中得方法访问修饰符默认是default<br>8.抽象类可以实现接口</p><p>关键字使用注意：<br>抽象类中的抽象方法（其前有abstract修饰）不能用private、static、synchronized、native访问修饰符修饰。 </p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>1.在接口中只有方法的声明，没有方法体。<br>2.<strong>在接口中只有常量，因为定义的变量，在编译的时候都会默认加上public static final</strong><br>3.<strong>在接口中的方法，永远都被public来修饰</strong>。<br>4.<strong>接口中没有构造方法，也不能实例化接口的对象</strong>。（所以接口不能继承类）<br>5.接口可以实现多继承<br>6.<strong>接口中定义的方法都需要有实现类来实现，如果实现类不能实现接口中的所有方法则实现类定义为抽象类。</strong><br>7.接口可以继承接口，用extends</p><p>作者：存在moring<br>链接：<a href="https://www.nowcoder.com/exam/test/74837104/submission?pid=53549264&amp;testCallback=undefined">https://www.nowcoder.com/exam/test/74837104/submission?pid=53549264&amp;testCallback=undefined</a><br>来源：牛客网</p></blockquote><h2 id="T3-堆栈"><a href="#T3-堆栈" class="headerlink" title="T3  堆栈"></a>T3  堆栈</h2><p>下列Java代码中的变量a、b、c分别在内存的<em>__</em>存储区存放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> “aa”;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> “bb”;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> “cc”;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案: 堆区、栈区、栈区</p><blockquote><p>a是类中的成员变量，存放在堆区 b、c都是方法中的局部变量，存放在栈区</p><p> <strong>堆区</strong>：只存放类对象，线程共享； </p><p> <strong>方法区</strong>：又叫静态存储区，存放class文件和静态数据，线程共享; </p><p>  <strong>栈区</strong>：存放方法局部变量，基本类型变量区、执行环境上下文、操作指令区，线程不共享;</p></blockquote><h2 id="T4"><a href="#T4" class="headerlink" title="T4 ??"></a>T4 ??</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310112334349.png" alt="image-20231011233358805"></p><blockquote><p>这题先放下不表</p><p>其实已经考虑过了i++和=的赋值先后的问题了,但还不是很明白</p><p>这里(i++)赋给i的值还是0,同时i还在等待++</p><p>按照答案来做马后炮的分析,是i先执行了++,然后又被之前的0赋值回去变为0了</p><p><strong>很神奇吧, JVM</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23/7/20 算法每日一题</title>
      <link href="/2023/10/10/2023-10-10-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/10/10/2023-10-10-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目1-中国剩余定理"><a href="#题目1-中国剩余定理" class="headerlink" title="题目1:中国剩余定理"></a>题目1:中国剩余定理</h2><p>广场上有一队士兵，如果排成10 列纵队，最后剩下a 个人(0 &lt;= a &lt;= 9)；如果排成9 列纵队，最后剩下b 个人(0 &lt;= b &lt;= 8)；如果排成8 列纵队，最后剩下c 个人(0 &lt;= c &lt;= 7)……如果排成2 列纵队，最后剩下i 个人(0 &lt;= i &lt;= 1)，输入a, b, c,…, i，输出广场上士兵的最少可能人数，分别用蛮力法和数学建模方法求解。</p><p>4396</p><p>6 4 4 0 4 1 0 1 0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">题目:广场上有一队士兵，如果排成<span class="number">10</span> 列纵队，最后剩下a 个人(<span class="number">0</span> &lt;= a &lt;= <span class="number">9</span>)；如果排成<span class="number">9</span> 列纵队，最后剩下b 个人(<span class="number">0</span> &lt;= b &lt;= <span class="number">8</span>)；如果排成<span class="number">8</span> 列纵队，最后剩下c 个人(<span class="number">0</span> &lt;= c &lt;= <span class="number">7</span>)……如果排成<span class="number">2</span> 列纵队，最后剩下i 个人(<span class="number">0</span> &lt;= i &lt;= <span class="number">1</span>)，输入a, b, c,…, i，输出广场上士兵的最少可能人数，分别用蛮力法和数学建模及中国中值定理(又称老子定理)方法求解。</span><br><span class="line">请帮我补全下面的代码,写出数学建模法</span><br><span class="line"><span class="keyword">package</span> org.hantou;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">//数据生成</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getData</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; i &gt;= <span class="number">2</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> num % i;</span><br><span class="line">            result.append(remainder).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result.toString().trim());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴力方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">violentWay</span><span class="params">(<span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">//            System.out.println(result);</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> a[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">columns</span> <span class="operator">=</span> i + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (result % columns != remaining) &#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">mathWay</span><span class="params">(<span class="type">int</span> a[])</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入剩余人数a到i：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        String[] soldiersString = input.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[soldiersString.length];</span><br><span class="line">        <span class="comment">//将输入转为字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; soldiersString.length; i++) &#123;</span><br><span class="line">            <span class="comment">//这里翻转,从2开始而不是10</span></span><br><span class="line">            a[soldiersString.length-i-<span class="number">1</span>] = Integer.parseInt(soldiersString[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //6 0 2 1 0 1 2 0 0 -&gt; 666</span></span><br><span class="line"><span class="comment">//        System.out.println(a.toString());</span></span><br><span class="line">        System.out.println(violentWay(a));</span><br><span class="line">        System.out.println(mathWay(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">题目:广场上有一队士兵，如果排成<span class="number">10</span> 列纵队，最后剩下a 个人(<span class="number">0</span> &lt;= a &lt;= <span class="number">9</span>)；如果排成<span class="number">9</span> 列纵队，最后剩下b 个人(<span class="number">0</span> &lt;= b &lt;= <span class="number">8</span>)；如果排成<span class="number">8</span> 列纵队，最后剩下c 个人(<span class="number">0</span> &lt;= c &lt;= <span class="number">7</span>)……如果排成<span class="number">2</span> 列纵队，最后剩下i 个人(<span class="number">0</span> &lt;= i &lt;= <span class="number">1</span>)，输入a, b, c,…, i，输出广场上士兵的最少可能人数，分别用蛮力法和数学建模及中国中值定理(又称老子定理)方法求解。</span><br><span class="line">对于数学建模法报错了Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ArithmeticException: / by zero</span><br><span class="line">    请帮我解决</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">mathWay</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] m = <span class="keyword">new</span> <span class="title class_">int</span>[a.length];</span><br><span class="line">    <span class="type">int</span>[] M = <span class="keyword">new</span> <span class="title class_">int</span>[a.length];</span><br><span class="line">    <span class="type">int</span>[] M1 = <span class="keyword">new</span> <span class="title class_">int</span>[a.length];</span><br><span class="line">    <span class="type">int</span>[] M2 = <span class="keyword">new</span> <span class="title class_">int</span>[a.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">M0</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">M1Sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">M2Sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">columns</span> <span class="operator">=</span> i + <span class="number">2</span>;</span><br><span class="line">        m[i] = columns - a[i];</span><br><span class="line">        M0 *= columns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">columns</span> <span class="operator">=</span> i + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">Mi</span> <span class="operator">=</span> M0 / columns;</span><br><span class="line">        M[i] = Mi;</span><br><span class="line">        M1[i] = inverse(Mi, columns);</span><br><span class="line">        M1Sum += M1[i] * Mi * m[i];</span><br><span class="line">        M2[i] = M1[i] * Mi;</span><br><span class="line">        M2Sum += M2[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> M1Sum % M0;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> x + k * M2Sum;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">columns</span> <span class="operator">=</span> i + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (result % columns != a[i]) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">inverse</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b0</span> <span class="operator">=</span> b, t, q;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x0</span> <span class="operator">=</span> <span class="number">0</span>, x1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (a &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        q = a / b;</span><br><span class="line">        t = b;</span><br><span class="line">        b = a % b;</span><br><span class="line">        a = t;</span><br><span class="line">        t = x0;</span><br><span class="line">        x0 = x1 - q * x0;</span><br><span class="line">        x1 = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x1 += b0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">这个错误通常是因为在求解Mi时，如果某个列数为<span class="number">0</span>，那么Mi会变成<span class="number">0</span>，从而导致除数为<span class="number">0</span>的错误。所以需要在计算Mi之前，先判断列数是否为<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">修改后的mathWay方法如下：</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">mathWay</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] m = <span class="keyword">new</span> <span class="title class_">int</span>[a.length];</span><br><span class="line">    <span class="type">int</span>[] M = <span class="keyword">new</span> <span class="title class_">int</span>[a.length];</span><br><span class="line">    <span class="type">int</span>[] M1 = <span class="keyword">new</span> <span class="title class_">int</span>[a.length];</span><br><span class="line">    <span class="type">int</span>[] M2 = <span class="keyword">new</span> <span class="title class_">int</span>[a.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">M0</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">M1Sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">M2Sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">columns</span> <span class="operator">=</span> i + <span class="number">2</span>;</span><br><span class="line">        m[i] = columns - a[i];</span><br><span class="line">        M0 *= columns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">columns</span> <span class="operator">=</span> i + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">Mi</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (columns != <span class="number">0</span>) &#123;</span><br><span class="line">            Mi = M0 / columns;</span><br><span class="line">        &#125;</span><br><span class="line">        M[i] = Mi;</span><br><span class="line">        M1[i] = inverse(Mi, columns);</span><br><span class="line">        M1Sum += M1[i] * Mi * m[i];</span><br><span class="line">        M2[i] = M1[i] * Mi;</span><br><span class="line">        M2Sum += M2[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> M1Sum % M0;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> x + k * M2Sum;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">columns</span> <span class="operator">=</span> i + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (result % columns != a[i]) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">这样就可以避免除数为<span class="number">0</span>的错误了。</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法设计 实验一</title>
      <link href="/2023/10/10/2023-10-10-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-%E5%AE%9E%E9%AA%8C%E4%B8%80/"/>
      <url>/2023/10/10/2023-10-10-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-%E5%AE%9E%E9%AA%8C%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="题目1-中国剩余定理"><a href="#题目1-中国剩余定理" class="headerlink" title="题目1:  中国剩余定理"></a>题目1:  中国剩余定理</h2><p>广场上有一队士兵，如果排成10 列纵队，最后剩下a 个人(0 &lt;= a &lt;= 9)；如果排成9 列纵队，最后剩下b 个人(0 &lt;= b &lt;= 8)；如果排成8 列纵队，最后剩下c 个人(0 &lt;= c &lt;= 7)……如果排成2 列纵队，最后剩下i 个人(0 &lt;= i &lt;= 1)，输入a, b, c,…, i，输出广场上士兵的最少可能人数，分别用蛮力法和数学建模方法求解。</p><p>4396 -&gt; 6 4 4 0 4 1 0 1 0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hantou.test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴力方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">violentWay</span><span class="params">(<span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">//            System.out.println(result);</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> a[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">columns</span> <span class="operator">=</span> i + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (result % columns != remaining) &#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">mathWay</span><span class="params">(Map&lt;Integer,Integer&gt; a,<span class="type">int</span>[] w)</span>&#123;</span><br><span class="line">        <span class="comment">//1.计算所有模数的积(2,3,5,7)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">210</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.计算第i个方程的Ci=M/key</span></span><br><span class="line">        <span class="type">int</span>[] c1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>];</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry :a.entrySet())&#123;</span><br><span class="line">            c1[entry.getKey()]=M/entry.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.计算c1i在模mi意义下的逆元c2i</span></span><br><span class="line">        <span class="type">int</span>[] c2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>];</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry :a.entrySet())&#123;</span><br><span class="line">            ex_gcd(c1[entry.getKey()],entry.getKey());</span><br><span class="line">            <span class="comment">//这里得到的逆元为x,若x为负数,则需要将x+mi再取余</span></span><br><span class="line">            c2[entry.getKey()]=((x+entry.getKey())%entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算最终ans</span></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry :a.entrySet())&#123;</span><br><span class="line">            ans+=a.get(entry.getKey())*c1[entry.getKey()]*c2[entry.getKey()]%M;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!check(w,ans)) ans+=M;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ex_gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> ex_gcd(b, a%b);</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp - a/b * y;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(x%(i+<span class="number">2</span>)!=a[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入剩余人数a到i：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        String[] soldiersString = input.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[soldiersString.length];</span><br><span class="line">        <span class="comment">//将输入转为字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; soldiersString.length; i++) &#123;</span><br><span class="line">            <span class="comment">//这里翻转,从2开始而不是10</span></span><br><span class="line">            a[soldiersString.length-i-<span class="number">1</span>] = Integer.parseInt(soldiersString[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //6 0 2 1 0 1 2 0 0 -&gt; 666</span></span><br><span class="line">        System.out.println(violentWay(a));</span><br><span class="line">        Map&lt;Integer,Integer&gt; t = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        t.put(<span class="number">2</span>,a[<span class="number">0</span>]);</span><br><span class="line">        t.put(<span class="number">3</span>,a[<span class="number">1</span>]);</span><br><span class="line">        t.put(<span class="number">5</span>,a[<span class="number">3</span>]);</span><br><span class="line">        t.put(<span class="number">7</span>,a[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">        System.out.println(mathWay(t,a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2-对角线的之字形方针"><a href="#题目2-对角线的之字形方针" class="headerlink" title="题目2:  对角线的之字形方针"></a>题目2:  对角线的之字形方针</h2><p>给定一个正整数n，输出如下 n ´ n “之字形”方阵。</p><p>例： 8 ´ 8 方阵。</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310121926167.png" alt="img"> </p><p>选作：输入任意的两个正整数<em>m</em> 和<em>n</em>(<strong>m</strong> ¹ <strong>n</strong>)，构造<strong>m</strong> ´ <strong>n</strong> “之字形”矩阵，以下示例为3 ´ 5 矩阵：</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310121926920.png" alt="img"> </p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310122026619.png" alt="image-20231012202611527"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入m n;若要求n*n的方阵,请输入n n:&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        String s[] = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> Integer.parseInt(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(s[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        getmatrix(m,n);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getmatrix</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//计数器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m + n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//i记录走过的斜线次数</span></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//↗</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Math.min(i, m - <span class="number">1</span>); j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i - j;</span><br><span class="line">                    <span class="keyword">if</span> (k &lt; n) &#123;</span><br><span class="line">                        a[j][k] = cnt++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//↙</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Math.min(i, n - <span class="number">1</span>); j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i - j;</span><br><span class="line">                    <span class="keyword">if</span> (k &lt; m) &#123;</span><br><span class="line">                        a[k][j] = cnt++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                System.out.print(a[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目3-ab-cde-fijk"><a href="#题目3-ab-cde-fijk" class="headerlink" title="题目3:  ab*cde=fijk"></a>题目3:  ab*cde=fijk</h2><p>用1、2、3、4、5、6、7、8、9这9 个数字，填入 ? 中使等式??*???=????成立，每个数字恰好只用一次。</p><p>以下是所有的7 个答案供参考：</p><p>12 <em> 483 = 5796、18 </em>297 = 5346、27 * 198 = 5346、</p><p>28 <em> 157 = 4396、39 </em> 186 = 7254、42 * 138 = 5796、</p><p>48 * 159 = 7632。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> product)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        num[a / <span class="number">10</span>]++;</span><br><span class="line">        num[a % <span class="number">10</span>]++;</span><br><span class="line">        num[b / <span class="number">100</span>]++;</span><br><span class="line">        num[(b / <span class="number">10</span>) % <span class="number">10</span>]++;</span><br><span class="line">        num[b % <span class="number">10</span>]++;</span><br><span class="line">        num[product / <span class="number">1000</span>]++;</span><br><span class="line">        num[(product / <span class="number">100</span>) % <span class="number">10</span>]++;</span><br><span class="line">        num[(product / <span class="number">10</span>) % <span class="number">10</span>]++;</span><br><span class="line">        num[product % <span class="number">10</span>]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i] != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//爆搜</span></span><br><span class="line">    <span class="comment">//第一个数12~98</span></span><br><span class="line">    <span class="comment">//第二个数123~987</span></span><br><span class="line">    <span class="comment">//双重遍历后check求解</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">12</span>; a &lt;= <span class="number">98</span>; a++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">123</span>; b &lt;= <span class="number">987</span>; b++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> a * b;</span><br><span class="line">                <span class="keyword">if</span> (product &gt; <span class="number">9999</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (check(a, b, product)) &#123;</span><br><span class="line">                    System.out.println(a + <span class="string">&quot; * &quot;</span> + b + <span class="string">&quot; = &quot;</span> + product);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题目4-滑动窗口"><a href="#题目4-滑动窗口" class="headerlink" title="题目4:  滑动窗口"></a>题目4:  滑动窗口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入正整数n:&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(s);</span><br><span class="line"></span><br><span class="line">        getAns(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getAns</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">st</span> <span class="operator">=</span> <span class="number">1</span>, ed = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//滑动窗口求解,操作窗口头尾的同时维护窗口内的sum</span></span><br><span class="line">        <span class="keyword">while</span>(st&lt;=n/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;n)&#123;</span><br><span class="line">                sum+=++ed;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;n)&#123;</span><br><span class="line">                sum-=st++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=st;i&lt;ed;i++)</span><br><span class="line">                    System.out.print(i+<span class="string">&quot;+&quot;</span>);</span><br><span class="line">                System.out.println(ed);</span><br><span class="line">                sum-=st++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;共有&quot;</span>+cnt+<span class="string">&quot;个不同连续自然段&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目5"><a href="#题目5" class="headerlink" title="题目5:"></a>题目5:</h2><p>一个整数n(n £ 30)可以有多种分划，分划的整数之和为n，在不区分分划出各整数的次序时，字典序递减输出n 的各详细分划方案和分划总数。</p><p>例如<strong>n</strong> = 6，程序输出为：</p><p>6</p><p>5  1</p><p>4  2</p><p>4  1  1</p><p>3  3</p><p>3  2  1</p><p>3  1  1  1</p><p>2  2  2</p><p>2  2  1  1</p><p>2  1  1  1  1</p><p>1  1  1  1  1  1</p><p>total = 11</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入正整数n:&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(s);</span><br><span class="line"></span><br><span class="line">        getAns(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getAns</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//每层开始时,要对第一次进行特殊处理,给出初步的数组</span></span><br><span class="line">            ArrayList&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            a.add(i);</span><br><span class="line">            <span class="keyword">if</span>(i!=n)&#123;</span><br><span class="line">                <span class="type">int</span> m=i,g=n;</span><br><span class="line">                <span class="keyword">while</span>(g-m&gt;m)&#123;</span><br><span class="line">                    a.add(m);</span><br><span class="line">                    g-=m;</span><br><span class="line">                &#125;</span><br><span class="line">                a.add(g-m);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; a.size(); k++) &#123;</span><br><span class="line">                System.out.print(a.get(k)+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            cnt++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理尾巴</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> a.size()-<span class="number">1</span>; j &gt;<span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a.get(j)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                    a.set(j, a.get(j)-<span class="number">1</span>);</span><br><span class="line">                    a.add(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; a.size(); k++) &#123;</span><br><span class="line">                        System.out.print(a.get(k)+<span class="string">&quot; &quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println();</span><br><span class="line">                    j++;<span class="comment">//注意这里的j++,就是把尾巴上的非1的数反复拆解</span></span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;total = &quot;</span>+cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java基础刷题笔记5</title>
      <link href="/2023/10/10/2023-10-10-java%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B05/"/>
      <url>/2023/10/10/2023-10-10-java%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B05/</url>
      
        <content type="html"><![CDATA[<h1 id="Java刷题笔记5"><a href="#Java刷题笔记5" class="headerlink" title="Java刷题笔记5"></a>Java刷题笔记5</h1><h2 id="T1-Thread-sleep"><a href="#T1-Thread-sleep" class="headerlink" title="T1 Thread.sleep()"></a>T1 Thread.sleep()</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310100907729.png" alt="image-20231010090749637"></p><blockquote><p>yield()让当前正在运行的线程回到可运行状态，以允许具有相同优先级的其他线程获得运行的机会。因此，使用yield()的目的是让具有<strong>相同优先级</strong>的线程之间能够适当的轮换执行。但是，实际中无法保证yield()达到让步的目的，因为，让步的线程可能被线程调度程序再次选中。</p><p>作者：我该叫什么<br>链接：<a href="https://www.nowcoder.com/exam/test/74715778/submission?pid=53461726&amp;testCallback=undefined">https://www.nowcoder.com/exam/test/74715778/submission?pid=53461726&amp;testCallback=undefined</a><br>来源：牛客网</p><p>A助记: 睡觉sleep()是抱着锁睡觉的, 等待wait()时把锁释放</p></blockquote><h2 id="T2-垃圾回收"><a href="#T2-垃圾回收" class="headerlink" title="T2 垃圾回收"></a>T2 垃圾回收</h2><p>下面哪些描述是正确的：（ ）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> B ref;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">(B b)</span> &#123;</span><br><span class="line">            ref = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class B &#123;</span><br><span class="line">        <span class="keyword">private</span> A ref;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">(A a)</span> &#123;</span><br><span class="line">            ref = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    …</span><br><span class="line">        start();</span><br><span class="line">    ….</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        a.setB(b);</span><br><span class="line">        b = <span class="literal">null</span>; <span class="comment">//</span></span><br><span class="line">        a = <span class="literal">null</span>;</span><br><span class="line">    …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.  b = null执行后b可以被垃圾回收</p><p>B.  a = null执行后b可以被垃圾回收</p><p>C.  a = null执行后a可以被垃圾回收</p><p>D.  a,b必须在整个程序结束后才能被垃圾回收</p><p>E.  类A和类B在设计上有循环引用，会导致内存泄露</p><p>F.  a, b 必须在start方法执行完毕才能被垃圾回收</p><blockquote><p><img src="https://uploadfiles.nowcoder.com/images/20200408/165701207_1586336189484_802A6FE5D8D89EC50285B88F46C488F4" alt="img"></p></blockquote><h2 id="T3-Collection接口-amp-Map接口"><a href="#T3-Collection接口-amp-Map接口" class="headerlink" title="T3 Collection接口 &amp; Map接口"></a>T3 Collection接口 &amp; Map接口</h2><p> <img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310100933796.png" alt="image-20231010093057632"></p><blockquote><p><img src="https://uploadfiles.nowcoder.com/images/20170608/7010483_1496884090913_9553A95A1845661EB80E51191737B9FF" alt="img"></p></blockquote><h2 id="T4-JDBC-amp-设计模式"><a href="#T4-JDBC-amp-设计模式" class="headerlink" title="T4 JDBC &amp; 设计模式"></a>T4 JDBC &amp; 设计模式</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310100938207.png" alt="image-20231010093848157"></p><h2 id="T5-char存储"><a href="#T5-char存储" class="headerlink" title="T5 char存储"></a>T5 char存储</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310100949138.png" alt="image-20231010094940108"></p><blockquote><p>  <strong>java</strong>中只有byte, boolean是一个字节, char是两个字节, 所以对于java来说127不会发生溢出, 输出328 </p><p>  但是对于<strong>c/c++</strong>语言来说, char是一个字节, 会发生溢出, 对127加一发生溢出, 0111 1111 —&gt; 1000 0000, 1000 0000为补码-128, 所以结果为200-128=72 </p></blockquote><h2 id="T6-JRE"><a href="#T6-JRE" class="headerlink" title="T6 JRE"></a>T6 JRE</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310101003316.png" alt="image-20231010100337277"></p><blockquote><p><strong>后台线程</strong>：指为其他线程提供服务的线程，也称为守护线程。JVM的垃圾回收线程就是一个后台线程。 </p><p><strong>前台线程(main方法)</strong>：是指接受后台线程服务的线程，其实前台后台线程是联系在一起，就像傀儡和幕后操纵者一样的关系。傀儡是前台线程、幕后操纵者是后台线程。由前台线程创建的线程默认也是前台线程。可以通过isDaemon()和setDaemon()方法来判断和设置一个线程是否为后台线程。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础刷题笔记4</title>
      <link href="/2023/10/09/2023-10-9-java%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B04/"/>
      <url>/2023/10/09/2023-10-9-java%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B04/</url>
      
        <content type="html"><![CDATA[<h1 id="Java刷题笔记4"><a href="#Java刷题笔记4" class="headerlink" title="Java刷题笔记4"></a>Java刷题笔记4</h1><h2 id="T1-赋值符号-移位"><a href="#T1-赋值符号-移位" class="headerlink" title="T1 赋值符号 | 移位"></a>T1 赋值符号 | 移位</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310091406835.png" alt="image-20231009140449517"></p><blockquote><p>&lt;&lt;表示左移位 </p><p>  >&gt;表示带符号右移位 </p><p>  >&gt;&gt;表示无符号右移 </p><p>  但是没有&lt;&lt;&lt;(无符号左移)运算符 </p></blockquote><h2 id="T2-父类-子类调用"><a href="#T2-父类-子类调用" class="headerlink" title="T2 父类/子类调用"></a>T2 父类/子类调用</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310091413521.png" alt="image-20231009141342433"></p><blockquote><p>  不会初始化子类的几种 </p><ol><li><p>调用的是父类的static方法或者字段 </p></li><li><p>调用的是父类的final方法或者字段 </p></li><li><p>通过数组来引用 (在初始化数组的时候不会初始化,而操作数组中元素时才进行初始化)</p></li></ol></blockquote><h2 id="T3-正则表达式"><a href="#T3-正则表达式" class="headerlink" title="T3 正则表达式"></a>T3 正则表达式</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310091427196.png" alt="image-20231009142707137"></p><h3 id="正则表达式的规则"><a href="#正则表达式的规则" class="headerlink" title="正则表达式的规则"></a>正则表达式的规则</h3><ol><li>任意一个字符表示匹配任意对应的字符，如a匹配a，7匹配7，-匹配-。    </li><li>[]代表匹配中括号中其中任一个字符，如[abc]匹配a或b或c。    </li><li>-在中括号里面和外面代表含义不同，如在外时，就匹配-，如果在中括号内[a-b]表示匹配26个小写字母中的任一个；[a-zA-Z]匹配大小写共52个字母中任一个；[0-9]匹配十个数字中任一个。    </li><li>^在中括号里面和外面含义不同，如在外时，就表示开头，如^7[0-9]表示匹配开头是7的，且第二位是任一数字的字符串；如果在中括号里面，表示除了这个字符之外的任意字符(包括数字，特殊字符)，如<sup><a href="#fn_abc" id="reffn_abc">abc</a></sup>表示匹配出去abc之外的其他任一字符。    </li><li>.表示匹配任意的字符。    </li><li>\d表示数字。    </li><li>\D表示非数字。    </li><li>\s表示由空字符组成，<code>[ \t\n\r\x\f]。</code>    </li><li>\S表示由非空字符组成，<code>[^\s]</code>  </li><li>\w表示字母、数字、下划线，<code>[a-zA-Z0-9_]</code>。    </li><li>\W表示不是由字母、数字、下划线组成。    </li><li>?: 表示出现0次或1次。    </li><li>+表示出现1次或多次。    </li><li>*表示出现0次、1次或多次。    </li><li>{n}表示出现n次。    </li><li>{n,m}表示出现n~m次。    </li><li>{n,}表示出现n次或n次以上。    </li><li>XY表示X后面跟着Y，这里X和Y分别是正则表达式的一部分。    </li><li>X|Y表示X或Y，比如”food|f”匹配的是foo（d或f），而”(food)|f”匹配的是food或f。    </li><li>(X)子表达式，将X看做是一个整体    </li></ol><h2 id="T4-try…catch…finally问题"><a href="#T4-try…catch…finally问题" class="headerlink" title="T4 try…catch…finally问题"></a>T4 try…catch…finally问题</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310091431674.png" alt="image-20231009143108600"></p><blockquote><p>结论：<br><strong>如果try语句里有return，那么代码的行为如下：</strong> </p><ol><li><p>如果有返回值，就把返回值保存到局部变量中</p></li><li><p>执行jsr指令跳到finally语句里执行</p></li><li><p>执行完finally语句后，返回之前保存在局部变量表里的值  </p></li></ol><p><strong>如果try，finally语句里均有return，忽略try的return，而使用finally的return.</strong></p></blockquote><h2 id="T5-String引用问题"><a href="#T5-String引用问题" class="headerlink" title="T5 String引用问题"></a>T5 String引用问题</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310091440350.png" alt="image-20231009144050267"></p><blockquote><p>str1指向常量池中的字符串；str2是通过StringBuilder类new出的对象，指向堆。故为false</p><p>当创建了匿名对象new String(“llo”)时，会在堆内存中开辟空间，地址值不一样了</p></blockquote><h2 id="T6-抽象类-amp-接口"><a href="#T6-抽象类-amp-接口" class="headerlink" title="T6 抽象类 &amp; 接口"></a>T6 抽象类 &amp; 接口</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310091452126.png" alt="image-20231009145255000"></p><blockquote><p>abstract class表示的是”is-a”关系，interface表示的是”like-a”关系。<br>is-a:继承关系 has-a:从属关系 like-a:组合关系</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础刷题笔记3</title>
      <link href="/2023/10/08/2023-10-8-java%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B03/"/>
      <url>/2023/10/08/2023-10-8-java%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B03/</url>
      
        <content type="html"><![CDATA[<h1 id="Java刷题笔记3"><a href="#Java刷题笔记3" class="headerlink" title="Java刷题笔记3"></a>Java刷题笔记3</h1><h2 id="T1-子类与父类实例化时的执行顺序"><a href="#T1-子类与父类实例化时的执行顺序" class="headerlink" title="T1 子类与父类实例化时的执行顺序"></a>T1 子类与父类实例化时的执行顺序</h2><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序:"></a>执行顺序:</h3><p><strong>父类静态代码块 -&gt;子类静态代码块 -&gt;父类非静态代码块 -&gt; 父类构造函数 -&gt; 子类非静态代码块 -&gt; 子类构造函数。 </strong> </p><p>  案例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类静态代码块&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类非静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类非静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果为：  父类静态代码块<br>                子类静态代码块<br>                父类非静态代码块<br>                父类构造函数<br>                子类非静态代码块<br>                子类构造函数 </p><h2 id="T2-内部类"><a href="#T2-内部类" class="headerlink" title="T2 内部类"></a>T2 内部类</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310081949311.png" alt="image-20231008194910228"></p><blockquote><p><strong>知识总结:</strong><br> 1.静态内部类才可以声明静态方法 </p><p> 2.静态方法不可以使用非静态变量 </p><p> 3.抽象方法不可以有函数体</p></blockquote><h2 id="T3-静态方法的调用"><a href="#T3-静态方法的调用" class="headerlink" title="T3 静态方法的调用"></a>T3 静态方法的调用</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310081957898.png" alt="image-20231008195709851"></p><blockquote><p>在java中静态方法中不能使用非静态方法和非静态变量。但非静态方法中可以使用静态变量</p><p><strong>在本题中,<u>main方法</u>显然是静态方法</strong></p></blockquote><h2 id="T4-开发中使用泛型的作用"><a href="#T4-开发中使用泛型的作用" class="headerlink" title="T4 开发中使用泛型的作用"></a>T4 开发中使用泛型的作用</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310082032108.png" alt="image-20231008203227076"></p><blockquote><p>泛型仅仅是java的语法糖，它不会影响java虚拟机生成的汇编代码，在编译阶段，虚拟机就会把泛型的类型擦除，还原成没有泛型的代码，顶多编译速度稍微慢一些，执行速度是完全没有什么区别的</p></blockquote><h2 id="T5-Java多态调用"><a href="#T5-Java多态调用" class="headerlink" title="T5 Java多态调用"></a>T5 Java多态调用</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310082033092.png" alt="image-20231008203334063"></p><blockquote><p>java多态有两种情况：<strong>重载</strong>和<strong>覆写</strong> 在覆写中，运用的是动态单分配，是根据new的类型确定对象，从而确定调用的方法； 在重载中，运用的是静态多分派，即根据静态类型确定对象，因此不是根据new的类型确定调用的方法</p></blockquote><h2 id="T6-接口中成员变量的默认等价类型"><a href="#T6-接口中成员变量的默认等价类型" class="headerlink" title="T6 接口中成员变量的默认等价类型"></a>T6 接口中成员变量的默认等价类型</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310082038902.png" alt="image-20231008203801866"></p><blockquote><p>接口中的变量默认是public static final 的，方法默认是public abstract 的 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6046 L2 学习笔记</title>
      <link href="/2023/10/08/2023-10-8-MIT-6046-L2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/10/08/2023-10-8-MIT-6046-L2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="MIT6-046算法设计-L2-学习笔记"><a href="#MIT6-046算法设计-L2-学习笔记" class="headerlink" title="MIT6.046算法设计 L2 学习笔记"></a>MIT6.046算法设计 L2 学习笔记</h1><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><h3 id="给一堆非三点共线的点-如何选一个最少点围成的圈-将所有点包围"><a href="#给一堆非三点共线的点-如何选一个最少点围成的圈-将所有点包围" class="headerlink" title="给一堆非三点共线的点,如何选一个最少点围成的圈,将所有点包围?"></a>给一堆非三点共线的点,如何选一个最少点围成的圈,将所有点包围?</h3><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310101013750.png" alt="image-20231010101024967"></p><p>点比较少,我们可以直接看出来,并将形成的圈用双向链表表示,记为CH(S)</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310101013643.png" alt="image-20231010101320617"></p><h3 id="问题来了-如何找到围成CH-S-的线段呢"><a href="#问题来了-如何找到围成CH-S-的线段呢" class="headerlink" title="问题来了,如何找到围成CH(S)的线段呢"></a>问题来了,如何找到围成CH(S)的线段呢</h3><p>选择两点,并用直线将其连接,若剩余的所有点都在同一侧,就表示他是CH(S)中的一条线段</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310101014663.png" alt="image-20231010101422634"></p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度?"></a>时间复杂度?</h3><p>O(n^2)找边,O(n)测试是否在同一侧</p><p>合并,时间复杂度为O(n^3)</p><h2 id="大事化小-gt-Merge"><a href="#大事化小-gt-Merge" class="headerlink" title="大事化小 -&gt; Merge"></a>大事化小 -&gt; Merge</h2><h3 id="如何合并"><a href="#如何合并" class="headerlink" title="如何合并?"></a>如何合并?</h3><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310101017764.png" alt="image-20231010101711728"></p><p>现在有左侧的CH(s1)和右侧的CH(s2),如何合并?</p><p>将左侧的点,从x最大的点开始顺时针编号,记为a1,a2,a3,a4,a5</p><p>右侧的点反之,记为b1,b2,b3</p><p>将ai,bj连线与中间直线L的交点y大小记为y(i,j)</p><h3 id="下面开始查找最佳线段-上檐部分"><a href="#下面开始查找最佳线段-上檐部分" class="headerlink" title="下面开始查找最佳线段(上檐部分)"></a>下面开始查找最佳线段(<strong>上檐部分</strong>)</h3><ol><li>连接a1,b1,交点记为y(1,1)</li><li>对右侧点进行顺时针替换,即连接a1b2,发现y(1,2)&gt;y(1,1)</li><li>重复2,发现y(1,3)&lt;y(1,2),回退右侧点到b2</li><li>对左侧点进行逆时针替换,发现y(5,2)&gt;y(1,2)</li><li>重复4,y(4,2)&gt;y(5,2)</li><li>继续替换,发现y(3,2)&lt;y(4,2),此时最佳线段确定为(a4,b2)</li></ol><p>下檐部分同理,不过是找最小y(i,j)</p><p>确定新的最佳上下檐为(a4,b2),(a3,b3)</p><h3 id="现在确定合并后新的CH-s"><a href="#现在确定合并后新的CH-s" class="headerlink" title="现在确定合并后新的CH(s)"></a>现在确定合并后新的CH(s)</h3><p>从新的上檐开始</p><p><strong>a4</strong>-&gt;<strong>b2</strong>(继续顺时针)-&gt;<strong>b3</strong>[与新的下檐(a3,b3)对应]-&gt;<strong>a3</strong>-&gt;<strong>a4</strong>(至此,新的CH形成)</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310101028627.png" alt="image-20231010102850566"></p><h2 id="中值查找"><a href="#中值查找" class="headerlink" title="中值查找"></a>中值查找</h2><p><del>这里没太看懂…看6046总是看着看着就不知道老师在研究什么问题了</del></p><p>这里大概的问题就是给定n个数字,求较低的中值和较高的中值</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310101031724.png" alt="image-20231010103124691"></p><p>显然我们可以直接先排序,再直接用索引找到,这样的时间复杂度为nlogn</p><p>我们能在复杂度n的情况下实现吗?</p><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310101040391.png" alt="image-20231010104012341"></p><p>图上的Select(S,i)表示查找S中第i大的数字</p><h4 id="首先研究在有序数列中的查找"><a href="#首先研究在有序数列中的查找" class="headerlink" title="首先研究在有序数列中的查找"></a>首先研究在有序数列中的查找</h4><p>对于一组不重复的有序数列S,设计算法Select(S,i)</p><ol><li>选择一个x进行划分(要cleverly的,尽量选中间值,这样能让左右平衡,让merge更具效率)</li><li>将小于x的数记为集合B,大于x的数记为集合C<br>假设集合B中有k-1个元素,集合C中有n-k个元素</li><li>如果k=i,则i就是x</li><li>如果k&gt;i,则在B部分进行查找,Select(B,i)</li><li>如果k&lt;i,则在C部分查找,Select(C,i-k)</li></ol><h5 id="这个算法好吗"><a href="#这个算法好吗" class="headerlink" title="这个算法好吗?"></a><strong>这个算法好吗?</strong></h5><p>在最坏状态,即x取的很烂的情况下,他的时间复杂度是n^2,且我们更偏向于寻找时间复杂度确定的方法</p><h3 id="再改进"><a href="#再改进" class="headerlink" title="再改进"></a>再改进</h3><p>上面的算法问题在于x的选择</p><h4 id="现在-如何Pick-X-cleverly"><a href="#现在-如何Pick-X-cleverly" class="headerlink" title="现在,如何Pick X cleverly?"></a>现在,如何Pick X cleverly?</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310101058306.png" alt="image-20231010105801229"></p><ul><li><p>将x分为若干长度为5的数列</p></li><li><p>对每个数列进行排序</p></li><li><p>找到每个数列的中值,再找到中值中的中值,将其作为「X」<br>对于每个数组,从左往右,按中值递增排序</p><blockquote><p>这里的5不是固定的,可以换为其他的适当的整数</p></blockquote></li></ul><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310101100340.png" alt="image-20231010110055280"></p><h4 id="有多少个数是确信严格大于x的"><a href="#有多少个数是确信严格大于x的" class="headerlink" title="有多少个数是确信严格大于x的?"></a>有多少个数是确信严格大于x的?</h4><p>下面的这段英文推理我真有点看不懂了,只能知道个大概,就是说至少有若干个大小为5的列能提供大于x的元素,然后那个不足5的数列需要特殊处理</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310101116412.png" alt="image-20231010111647335"></p><h4 id="最后-改进后的时间复杂度"><a href="#最后-改进后的时间复杂度" class="headerlink" title="最后,改进后的时间复杂度"></a>最后,改进后的时间复杂度</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310101117990.png" alt="image-20231010111704925"></p><p>总时间复杂度= 找中值的中值的时间+递归处理的时长(不会算..)+对每个数列的排序时间</p><blockquote><p>课上是这样推递归时间的</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310101119275.png" alt="image-20231010111951227"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础刷题笔记2</title>
      <link href="/2023/10/07/2023-10-7-java%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B02/"/>
      <url>/2023/10/07/2023-10-7-java%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[<h1 id="Java刷题笔记2"><a href="#Java刷题笔记2" class="headerlink" title="Java刷题笔记2"></a>Java刷题笔记2</h1><h2 id="T1-catch异常"><a href="#T1-catch异常" class="headerlink" title="T1 catch异常"></a>T1 catch异常</h2><p>在异常处理中，若try中的代码可能产生多种异常则可以对应多个catch语句，若catch中的参数类型有父类子类关系，此时应该将父类放在后面，子类放在前面。</p><p>-&gt; <strong>错误</strong></p><blockquote><p>所有异常都是Exception的子类,若把Exception放在前面catch,则放在后面子类错误的就永远都抓不到了</p></blockquote><p>T2 Integer自动装箱</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310071548016.png" alt="image-20231007153532259"></p><blockquote><p><strong>选项A</strong>，a1、a2赋值给Integer类型，自动装箱。对于<strong>–128到127</strong>（默认是127）之间的值，Integer.valueOf(int i) 返回的是缓存的Integer对象（并不是新建对象），变量所指向的是同一个对象，<strong>所以a1==a2返回true</strong>。<br><strong>选项B</strong>，Integer和int比较会进行自动拆箱，比较的是数值大小，<strong>所以d1==d2返回true</strong>。<br><strong>选项C</strong>，由于超出自动装箱的范围，return返回的是新建的对象，所以<strong>对象内存地址不同</strong>，<strong>b1==b2返回false。</strong>   <strong>选项D</strong>，普通<strong>new</strong>创建对象，两个new创建两个地址不同的对像，<strong>所以c1==c2返回false</strong>。</p></blockquote><h2 id="T2-补充Java的内存管理机制"><a href="#T2-补充Java的内存管理机制" class="headerlink" title="T2 补充Java的内存管理机制"></a>T2 补充Java的内存管理机制</h2><h3 id="1-内存分配策略"><a href="#1-内存分配策略" class="headerlink" title="1. 内存分配策略"></a><strong>1. 内存分配策略</strong></h3><p>   按照编译原理的观点，程序运行时的内存分配有三种策略，分别是静态的,栈式的,和堆式的。  </p><p>   静态存储分配是指在编译时就能确定每个数据目标在运行时刻的存储空间需求，因而在编译时就可以给他们分配固定的内存空间。这种分配策略要求程序代码中不允许有可变数据结构(比如可变数组)的存在，也不允许有嵌套或者递归的结构出现,因为它们都会导致编译程序无法计算准确的存储空间需求。  </p><p>   栈式存储分配也可称为动态存储分配，是由一个类似于堆栈的运行栈来实现的。和静态存储分配相反，在栈式存储方案中，程序对数据区的需求在编译时是完全未知的，只有到运行的时候才能够知道，但是规定在运行中进入一个程序模块时，必须知道该程序模块所需的数据区大小才能够为其分配内存。和我们在数据结构所熟知的栈一样，栈式存储分配按照先进后出的原则进行分配。  </p><p>   静态存储分配要求在编译时能知道所有变量的存储要求，栈式存储分配要求在过程的入口处必须知道所有的存储要求，而堆式存储分配则专门负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配，比如可变长度串和对象实例。堆由大片的可利用块或空闲块组成，堆中的内存可以按照任意顺序分配和释放。  </p><h3 id="2-JVM中的堆和栈"><a href="#2-JVM中的堆和栈" class="headerlink" title="2. JVM中的堆和栈"></a><strong>2. JVM中的堆和栈</strong></h3><p>   JVM是基于堆栈的虚拟机。JVM为每个新创建的线程都分配一个堆栈，也就是说，对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。  </p><p>   java把内存分两种：一种是栈内存，另一种是堆内存  </p><p>   栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。  </p><p>   栈(stack)：是一个先进后出的数据结构,通常用于保存方法(函数)中的参数，局部变量。  </p><p>   堆(heap)：是一个可动态申请的内存空间(其记录空闲内存空间的链表由操作系统维护)，是一个运行时数据区，C中的malloc语句所产生的内存空间就在堆中。  </p><h3 id="3-堆和栈优缺点比较"><a href="#3-堆和栈优缺点比较" class="headerlink" title="3. 堆和栈优缺点比较"></a><strong>3. 堆和栈优缺点比较</strong></h3><p>   栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享，详见第3点。  </p><p>   堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。  </p><h3 id="4-Java中的数据类型有两种"><a href="#4-Java中的数据类型有两种" class="headerlink" title="4. Java中的数据类型有两种"></a><strong>4. Java中的数据类型有两种</strong></h3><h4 id="一种是基本类型"><a href="#一种是基本类型" class="headerlink" title="一种是基本类型"></a><strong>一种是基本类型</strong></h4><p>   共有8种，即int, short, long, byte, float, double, boolean, char(注意，并没有string的基本类型)。  </p><p>   这种类型的定义是通过诸如int a = 3; long b = 255L;的形式来定义的，称为自动变量。值得注意的是，自动变量存的是字面值，不是类的实例，即不是类的引用，这里并没有类的存在。如int a = 3; 这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。  </p><p>   另外，<strong>栈有一个很重要的特殊性，就是存在栈中的数据可以共享。</strong>假设我们同时定义：  </p><p>   <code>int a = 3;   int b = 3；</code><br> 编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。  </p><p>   特别注意的是，这种字面值的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另一个对象引用变量也即刻反映出这个变化。相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。如上例，我们定义完a与b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。  </p><h4 id="另一种是包装类数据"><a href="#另一种是包装类数据" class="headerlink" title="另一种是包装类数据"></a><strong>另一种是包装类数据</strong></h4><p>   如Integer, String, Double等将相应的基本数据类型包装起来的类。这些类数据全部存在于堆中，Java用new()语句来显示地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间。  </p><p>   String是一个特殊的包装类数据。即可以用String str = new String(“abc”);的形式来创建，也可以用String str = “abc”；的形式来创建(作为对比，在JDK 5.0之前，你从未见过Integer i = 3;的表达式，因为类与字面值是不能通用的，除了String。而在JDK 5.0中，这种表达式是可以的！因为编译器在后台进行Integer i = new Integer(3)的转换)。前者是规范的类的创建过程，即在Java中，一切都是对象，而对象是类的实例，全部通过new()的形式来创建。Java中的有些类，如DateFormat类，可以通过该类的getInstance()方法来返回一个新创建的类，似乎违反了此原则。其实不然。该类运用了单例模式来返回类的实例，只不过这个实例是在该类内部通过new()来创建的，而getInstance()向外部隐藏了此细节。那为什么在String str = “abc”；中，并没有通过new()来创建实例，是不是违反了上述原则？其实没有。  </p><h3 id="5．String在内存中的存放"><a href="#5．String在内存中的存放" class="headerlink" title="5．String在内存中的存放"></a><strong>5．String在内存中的存放</strong></h3><p>   <strong>String是一个特殊的包装类数据，可以用用以下两种方式创建：</strong>  </p><p>   <strong>String str = new String(“abc”)；第一种创建方式是用new()来新建对象的，它会存放于堆中。每调用一次就会创建一个新的对象。</strong>  </p><p>   <strong>String str = “abc”; 第二种创建方式先在栈中创建一个对String类的对象引用变量str，然后在栈中查找有没有存放值为”abc”的地址，如果没有，则开辟一个存放字面值为”abc”的地址，接着创建一个新的String类的对象o，并将o的字符串值指向这个地址，而且在栈中这个地址旁边记下这个引用的对象o。如果已经有了值为”abc”的地址，则查找对象o，并返回o的地址,最后将str指向对象o的地址。</strong>  </p><p>   <strong>值得注意的是，一般String类中字符串值都是直接存值的。但像String str = “abc”；这种场合下，其字符串值却是保存了一个指向存在栈中数据的引用！</strong>  </p><h3 id="6-数组在内存中的存放"><a href="#6-数组在内存中的存放" class="headerlink" title="6.数组在内存中的存放"></a><strong>6.数组在内存中的存放</strong></h3><p>   int x[] 或者int []x 时，在内存栈空间中创建一个数组引用，通过该数组名来引用数组。  </p><p>   x = new int[5] 将在堆内存中分配5个保存int型数据的空间，堆内存的首地址放到栈内存中，每个数组元素被初始化为0。  </p><h3 id="7-static变量在内存中的存放"><a href="#7-static变量在内存中的存放" class="headerlink" title="7.static变量在内存中的存放"></a><strong>7.static变量在内存中的存放</strong></h3><p>   用 static的修饰的变量和方法，实际上是指定了这些变量和方法在内存中的“固定位置”－static storage。既然要有“固定位置”那么他们的 “大小”似乎就是固定的了，有了固定位置和固定大小的特征了，在栈中或堆中开辟空间那就是非常的方便了。如果静态的变量或方法在不出其作用域的情况下，其引用句柄是不会发生改变的。  </p><h3 id="8-java中变量在内存中的分配"><a href="#8-java中变量在内存中的分配" class="headerlink" title="8. java中变量在内存中的分配"></a><strong>8. java中变量在内存中的分配</strong></h3><h4 id="1、类变量（static修饰的变量）"><a href="#1、类变量（static修饰的变量）" class="headerlink" title="1、类变量（static修饰的变量）"></a>1、类变量（static修饰的变量）</h4><p>   在程序加载时系统就为它在堆中开辟了内存，堆中的内存地址存放于栈以便于高速访问。静态变量的生命周期一直持续到整个”系统”关闭  </p><h4 id="2、实例变量"><a href="#2、实例变量" class="headerlink" title="2、实例变量"></a>2、实例变量</h4><p>   当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量（比如说类实例），然后根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”。 实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存  </p><h4 id="3、局部变量"><a href="#3、局部变量" class="headerlink" title="3、局部变量"></a>3、局部变量</h4><p>   局部变量，由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放  </p><blockquote><p> 作者：PlanckStar<br>链接：<a href="https://www.nowcoder.com/exam/test/74584886/submission?examPageSource=Intelligent&amp;pid=53374715&amp;testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fintelligent%3FquestionJobId%3D10">https://www.nowcoder.com/exam/test/74584886/submission?examPageSource=Intelligent&amp;pid=53374715&amp;testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fintelligent%3FquestionJobId%3D10</a><br>来源：牛客网</p></blockquote><h2 id="T3-char-amp-String的引用"><a href="#T3-char-amp-String的引用" class="headerlink" title="T3 char[] &amp; String的引用"></a>T3 char[] &amp; String的引用</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310071552045.png" alt="image-20231007155218013"></p><blockquote><p>这道题里方法修改的都是修改形参，区别是一个通过形参修改堆值，而另一个仅仅只是修改形参的引用指向。</p><p><code>char[] ch = &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;</code>是数组，数组是一个<a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html">对象</a>，因此存放在堆中，所以当方法通过形参修改值时会去堆中修改。当变量ch再去访问时，堆中的值已经修改，所以输出dbc。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础刷题笔记1</title>
      <link href="/2023/10/06/2023-10-6-java%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B01/"/>
      <url>/2023/10/06/2023-10-6-java%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<p>**最近学了些分布式的知识,想要找个项目做做,暂时没找到合适的,先每天练练基础,再学些新知识吧; 正好也要应付学校的Java考试</p><h1 id="java刷题笔记1"><a href="#java刷题笔记1" class="headerlink" title="java刷题笔记1"></a>java刷题笔记1</h1><h2 id="T1-类中各种块的优先级问题"><a href="#T1-类中各种块的优先级问题" class="headerlink" title="T1 类中各种块的优先级问题"></a>T1 类中各种块的优先级问题</h2><p> <img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310061630986.png" alt="image-20231006163029876"></p><ul><li><p>静态块:用static声明,JVM加载类时执行,仅执行一次</p></li><li><p>构造块：类中直接用{}定义，每一次创建对象时执行 </p></li><li><p><strong>执行顺序优先级：静态块&gt;main()&gt;构造块&gt;构造方法</strong> </p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CodeBlock</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;普通代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了main方法&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CodeBlock</span>().sayHello();;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CodeBlock</span>().sayHello();;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>思路:</p><p>开始时JVM加载B.class，对所有的静态成员进行声明，t1  t2被初始化为默认值，为null，又因为t1  t2需要被显式初始化，所以对t1进行显式初始化，初始化代码块→构造函数（没有就是调用默认的构造函数），咦！静态代码块咋不初始化？因为在开始时已经对static部分进行了初始化，虽然只对static变量进行了初始化，但在初始化t1时也不会再执行static块了，因为JVM认为这是第二次加载类B了，所以static会在t1初始化时被忽略掉，所以直接初始化非static部分，也就是构造块部分（输出’’构造块’’）接着构造函数（无输出）。接着对t2进行初始化过程同t1相同（输出’构造块’），此时就对所有的static变量都完成了初始化，接着就执行static块部分（输出’静态块’），接着执行，main方法，同样也，new了对象，调用构造函数输出（’构造块’） … </p><p>作者：MOBIN<br>链接：<a href="https://www.nowcoder.com/exam/test/74549938/submission?examPageSource=Intelligent&amp;pid=53351303&amp;testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fintelligent%3FquestionJobId%3D10">https://www.nowcoder.com/exam/test/74549938/submission?examPageSource=Intelligent&amp;pid=53351303&amp;testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fintelligent%3FquestionJobId%3D10</a><br>来源：牛客网</p><p><strong>总结</strong> : 静态<strong><u>域</u></strong>只会在类第一次加载时才会被初始化，在静态域中对于静态变量和静态块的初始化顺序则由它们的相对位置所决定; <u>静态域中包含静态变量、静态块和静态方法</u></p></blockquote><h2 id="T2-final-amp-String"><a href="#T2-final-amp-String" class="headerlink" title="T2 final &amp; String"></a>T2 final &amp; String</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310061638525.png" alt="image-20231006163846492"></p><p>对于E : final的陈元方法除了能读取类的成员变量,还能读取类变量(<u>static修饰的静态变量</u>)</p><p>对于F :   String <strong><u>不可以</u></strong>修改，StringBuffer 和 StringBuilder 可以修改，String 只能改变指引，如果字符串常量池中没有需要的串，就创建一 个新的字符串，然后让 String 对象指向它。</p><h2 id="T3-数组为空时的默认初始化"><a href="#T3-数组为空时的默认初始化" class="headerlink" title="T3 数组为空时的默认初始化"></a>T3 数组为空时的默认初始化</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310061825286.png" alt="image-20231006182505221"></p><blockquote><p><img src="C:/Users/Hantou/AppData/Roaming/Typora/typora-user-images/image-20231006182816176.png" alt="image-20231006182816176"></p></blockquote><h2 id="T4-Object类方法"><a href="#T4-Object类方法" class="headerlink" title="T4 Object类方法"></a>T4 Object类方法</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310061940810.png" alt="image-20231006194022762"></p><blockquote><p>Object类中存在的方法如下： </p><ol><li>getClass    2. hashCode    3. equals    4. clone    5. toString    6.notify  7. notifyAll    8. wait    9. finalize</li></ol></blockquote><h2 id="T5-基类-amp-派生类"><a href="#T5-基类-amp-派生类" class="headerlink" title="T5 基类&amp;派生类"></a>T5 基类&amp;派生类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面代码的输出结果?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">baseName</span> <span class="operator">=</span> <span class="string">&quot;base&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        callName();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System. out. println(baseName);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">baseName</span> <span class="operator">=</span> <span class="string">&quot;sub&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callName</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            System. out. println (baseName) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在new Sub()时先创建的是基类对象Base,然后才创建派生类对象Sub; 在创建Base时执行构造方法,因为派生类重写了callName()方法,所以此时调用的是派生类Sub中的callName()方法,但是此时派生类还未被构造,变量baseName的值为null;</p><p>总结: 在创造<strong>派生类</strong>的过程中首先构造<strong>基类</strong>对象, 若在<u>实例化</u>派生类时,基类构造函数中调用的方法被派生类重写,则调用派生类中重写后的方法 ; 需要注意的是,此时派生类中的成员变量可能仍未被创建</p></blockquote><h2 id="T6-内部类-amp-外部类"><a href="#T6-内部类-amp-外部类" class="headerlink" title="T6 内部类&amp;外部类"></a>T6 内部类&amp;外部类</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310062015390.png" alt="image-20231006201504335"></p><h3 id="定义-将一个类定义在另一个类或方法中-这个类叫做内部类-可以分为四种"><a href="#定义-将一个类定义在另一个类或方法中-这个类叫做内部类-可以分为四种" class="headerlink" title="定义: 将一个类定义在另一个类或方法中,这个类叫做内部类,可以分为四种"></a>定义: 将一个类定义在另一个类或方法中,这个类叫做内部类,可以分为四种</h3><ul><li><p><strong>成员内部类</strong><br>内部类可以: private、protected、public及包访问权限。如果成员内部类用private修饰，则只能在外部类的内部访问；如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。外部类只能被public和包访问两种权限修饰。</p></li><li><p><strong>局部内部类</strong></p><p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内； </p><p>局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。</p></li><li><p><strong>匿名内部类</strong></p><p>唯一一种没有构造器的类； </p><p>不能有访问修饰符和static修饰符的； </p></li><li><p><strong>内部静态类</strong></p><p>不需要依赖于外部类的，这点和类的静态成员属性有点类似</p><p>不能使用外部类的非static成员变量或者方法。</p></li></ul><h3 id="外部类可用修饰-public、default、abstract、final"><a href="#外部类可用修饰-public、default、abstract、final" class="headerlink" title="外部类可用修饰: public、default、abstract、final"></a>外部类可用修饰: <strong>public、default、abstract、final</strong></h3><blockquote><p>外部类如果用非公开的修饰符修饰了,那谁来调用它,如何调用它…</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ笔记整合</title>
      <link href="/2023/10/04/2023-10-4-RocketMQ%E7%AC%94%E8%AE%B0%E6%95%B4%E5%90%88/"/>
      <url>/2023/10/04/2023-10-4-RocketMQ%E7%AC%94%E8%AE%B0%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="RocketMQ笔记整合"><a href="#RocketMQ笔记整合" class="headerlink" title="RocketMQ笔记整合"></a>RocketMQ笔记整合</h1><h1 id="第一章-RocketMQ概述"><a href="#第一章-RocketMQ概述" class="headerlink" title="第一章 RocketMQ概述"></a>第一章 RocketMQ概述</h1><h2 id="一-、MQ概述"><a href="#一-、MQ概述" class="headerlink" title="一 、MQ概述"></a>一 、MQ概述</h2><h3 id="MQ简介"><a href="#MQ简介" class="headerlink" title="MQ简介"></a>MQ简介</h3><p>Message Queue消息队列,是一种提供消息队列服务的中间件,也称为消息中间件,是一套提供了信息生产,储存,消费全过程的API软甲系统</p><h3 id="MQ用途"><a href="#MQ用途" class="headerlink" title="MQ用途"></a>MQ用途</h3><h4 id="1-流量削峰"><a href="#1-流量削峰" class="headerlink" title="1.流量削峰"></a><strong>1.流量削峰</strong></h4><p>MQ可以将系统的<strong>超量</strong>请求暂存其中,以便后期系统可以慢慢处理,从而避免了请求的丢失或者系统宕机</p><h4 id="2-异步解耦"><a href="#2-异步解耦" class="headerlink" title="2.异步解耦"></a><strong>2.异步解耦</strong></h4><p>上游系统对下游系统的调用若为同步调用,则会大大降低系统的吞吐量与并发度,且系统耦合度太高;异步调用可以通过在上下游间添加一个<strong>MQ层</strong>来解决这些问题</p><h4 id="3-数据收集"><a href="#3-数据收集" class="headerlink" title="3.数据收集"></a>3.<strong>数据收集</strong></h4><p>分布式系统会产生海量数据流,如:业务日志,监控数据,用户行为等;针对这些数据流进行实时或批量采集汇总,然后对这些数据流进行大数据分析,是当前互联网平台的必备技术,通过MQ完成此类数据收集是最好的选择</p><h1 id="第二章-RocketMQ的安装与启动"><a href="#第二章-RocketMQ的安装与启动" class="headerlink" title="第二章 RocketMQ的安装与启动"></a>第二章 RocketMQ的安装与启动</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1-消息-Message"><a href="#1-消息-Message" class="headerlink" title="1.消息 Message"></a>1.消息 Message</h3><p>消息是消息系统所传输信息的物理载体,生产和消费数据的最小单位,每条消息必须属于一个主题</p><h3 id="2-主题-Topic"><a href="#2-主题-Topic" class="headerlink" title="2.主题 Topic"></a>2.主题 Topic</h3><p>Topic表示一类消息的<strong>集合</strong>，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行<strong>消息订阅的基本单位</strong>。</p><p>一个生产者可以同时发送多种Topic的消息;而一个消费者只对某种特定的Topic感兴趣，即<u>一个消费者只可以订阅和消费一种Topic的消息</u>。</p><h3 id="3-标签-Tag"><a href="#3-标签-Tag" class="headerlink" title="3.标签  Tag"></a>3.标签  Tag</h3><p>Tag是为消息设置的标签,用于区别同一Topic下的不同类型的消息;</p><p><u>即Topic是消息的一级分类,Tag是消息的二级分类</u></p><h3 id="4-队列-Queue"><a href="#4-队列-Queue" class="headerlink" title="4.队列 Queue"></a>4.队列 Queue</h3><p>存储消息的物理实体,一个Topic中可以包含多个Queue(一个Queue中的消息只能被一个消费者组中的一个消费者消费;一个Queue中的消息不允许同一个消费者组的多个消费者同时消费),每个Queue中存放的就是该Topic的消息</p><p>一个Topic的Queue也被称为一个Topic中消息的分区</p><blockquote><p>分片:在RocketMQ中,分片指的是存放响应Topic的Broker数量;每个分片会创建相应数量的分区,即Queue,每个Queue的大小应该是相同的</p></blockquote><h3 id="5-消息标示-MessageId-Key"><a href="#5-消息标示-MessageId-Key" class="headerlink" title="5.消息标示 MessageId/Key"></a>5.消息标示 MessageId/Key</h3><p>RocketMQ中每个消息拥有唯一的Messageld，且可以携带具有业务标识的Key，以方使对消息的查询。不过需要注意的是，MessageId有两个:在生产者send()消息时会自动生成一个Messageld (msgld),当消息到达Broker后,其也会自动生成一个MessageId(offsetId)</p><ul><li>msgld: 田producer端生成，具生成规则为:</li></ul><p>​        <strong>producerIp +进程pid + MessageclientIDSetter类的c1assLoader的hashcode +当前时间+ AutomicInteger自增计数器</strong></p><ul><li>offsetMsgld:由broker端生成，其生成规则为: brokerIp +物理分区的offset(Queue中的偏移量)</li><li>key:由用户指定的业务相关的唯一标识</li></ul><h2 id="二、系统架构"><a href="#二、系统架构" class="headerlink" title="二、系统架构"></a>二、系统架构</h2><h3 id="1-Producer-生产者"><a href="#1-Producer-生产者" class="headerlink" title="1.Producer  生产者"></a>1.Producer  生产者</h3><p>消息生产者,负责生产消息,其通过MQ的负载均衡模块选择响应的Broker集群队列进行消息投递,投递过程支持快速失败且低延迟</p><p>RocketMQ中消息生产者都是以<strong>生产者组</strong>的形式出现的,生产者组是同一类生产者的集合,这类Producer<strong>都能(不是仅能)</strong>发送相同Topic类型的消息</p><h3 id="2-Consumer-消费者"><a href="#2-Consumer-消费者" class="headerlink" title="2.Consumer 消费者"></a>2.Consumer 消费者</h3><p>消息消费者,负责消费消息,一个消费者会从Broker服务器中获取消息,并对消息进行相关业务处理</p><p>RocketMQ中的消息消费者都是以<strong>消费者组</strong>的形式出现的,其是同一类消费者的集合,这类Consumer消费的是同一个Topic类型的消息,消费者组的存在使得<strong>负载均衡</strong>(指的是将一个Topic中不同的Queue平均分配给同一个Consumer Group的不同的Consumer,并不是Message的消息负载均衡)和<strong>容错</strong>(一个Consumer挂了,该消费者组中的其他Consumer可以接着消费原Consumer消费的Queue)的实现变得容易</p><blockquote><p>同一个生产者可以生产多种不同消息,而同一个消费者只能生产同一种消息</p><p>不过一个Topic类型的消息可以同时呗多个消费者组同时消费</p></blockquote><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309181321830.png" alt="image-20230918132127582"></p><blockquote><p>注意:</p><p>1)一个消费者组中的消费者必须订阅完全相同的Topic</p><p>2)消费者组只能消费一个Topic的消息,不能同时消费多个Topic消息</p></blockquote><h3 id="3-Name-Server"><a href="#3-Name-Server" class="headerlink" title="3.Name Server"></a>3.Name Server</h3><h4 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h4><p>NameServer是一个Broker与Topic路由的注册中心,支持Broker的动态注册与发现</p><p>主要包括两个功能</p><ul><li><strong>Broker管理</strong>:接受Broker集群的注册信息并保存下来作为路由信息的基本数据;提供心跳检测</li><li><strong>路由信息管理</strong>:每个NameServer中都保存着Broker集群的整个路由信息和用于客户端查询的队列信息;Producer和Consumer通过NameServer可以获取整个Broker集群的路由信息,从而进行消息的投递和消费</li></ul><h4 id="路由注册"><a href="#路由注册" class="headerlink" title="路由注册"></a>路由注册</h4><p>NameServer通常是集群部署,不过NameServer是无状态的(集群中各个节点无差异),集群中各节点间不进行相互的信息通讯</p><p>节点中的数据是如何同步的呢?</p><p>在Broker结点启动时,轮询NameServer结点建立长连接,发起注册请求,在NameServer内部维护者一个Broker列表用来动态存储Broker信息</p><blockquote><p>注意 这是与其他如zk,Eureka,Nacos等注册中心不同的</p><p>NameServer的无状态方式的优缺点</p><ul><li><p>优点:搭建简单,扩容简单-</p></li><li><p>缺点:对于Broker,必须要明确指示所有NameServer地址,否则为指出的NameServer将不会被注册;因此,NameServer并不能随意扩容,因为若Broker不重新配置,新增的NameServer对于Broker不可见</p></li></ul></blockquote><p>Broker节点为了维持自己的存活,为了维护与NameServer的长连接,会将最新消息以<strong>心跳包</strong>的方式上报给NameServer,30s一次;NameServer在收到心跳包后会更新心跳时间戳,记录这个Broker的最新存活时间</p><h4 id="路由剔除"><a href="#路由剔除" class="headerlink" title="路由剔除"></a>路由剔除</h4><p>若NameServer未及时收到Broker的心跳,NameServer可能会将其从Broker列表中剔除</p><p>NameServer每10秒扫描一次Broker表,若发现Broker的心跳时间戳距今超过120s则判定其失效,将其从Broker列表中剔除</p><blockquote><p>扩展:对于Rocket的日常运维,需要暂停Broker的工作,管理员需要怎么做?</p><p>OP需要将Broker的读写权限暂时禁用,若client向broker发送请求,则会收到broker的NO_PERMISSION响应,然后client会向其他Broker发送重试请求</p><p>当OP发现这个Broker没有流量后,再将其关闭,实现Broker从NameServer中的移除</p></blockquote><h4 id="路由发现"><a href="#路由发现" class="headerlink" title="路由发现"></a>路由发现</h4><p>RocketMQ的路由发现采用pull模型;NameServer不会主动推送Topic变动,而是client定时拉去topic最新路由;客户端默认每30s拉取一次最新路由</p><blockquote><p>拓展:</p><p>1)Push模型: 主动推送模型/发布-订阅模型</p><p>其需要维护一个长连接,<strong>实时性好</strong>,但<strong>资源消耗大</strong></p><p>​    适用场景:</p><ul><li>实时性要求高</li><li>Client数量不多,Server数据变化频繁</li></ul><p>2)Pull模型: 拉取模型</p><p>缺点:实时性较差,资源消耗较小</p><p>3)Long Polling模型: 长轮询模型</p><p>是对Push与Pull模型的融合,取长补短,对二者进行了折中</p></blockquote><h4 id="客户端NameServer选择策略"><a href="#客户端NameServer选择策略" class="headerlink" title="客户端NameServer选择策略"></a>客户端NameServer选择策略</h4><p>客户端在配置时必须要写上NameServer集群的地址，那么客户端到底连接的是哪个NameServer节点呢?</p><p>客户端首先会生产一个随机数，然后再与NameServer节点数量取模，此时得到的就是所要连接的节点索引，然后就会进行连接。如果连接失败，则会采用round-robin策略，逐个尝试着去连接其它节点。</p><p><u>首先采用<strong>随机策略</strong>进行选择,失败后采取<strong>轮询策略</strong></u></p><h3 id="4-Broker"><a href="#4-Broker" class="headerlink" title="4.Broker"></a>4.Broker</h3><h4 id="功能介绍-1"><a href="#功能介绍-1" class="headerlink" title="功能介绍"></a>功能介绍</h4><p>Broker充当消息中转角色,负责存储,转发消息;Broker在RocketMQ系统中负责接收并存储从生产者发来的消息,同时为消费者的拉取做准备(中介呗);Broker同时存储着消息相关的元数据,包括消费者组消费进度offset,主题,队列等</p><h4 id="模块构成"><a href="#模块构成" class="headerlink" title="模块构成"></a>模块构成</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309181430000.png" alt="image-20230918143047892"></p><p><strong>Remoting Module</strong>：整个Broker的实体，负责处理来自clients端的请求。而这个Broker实体则由以下模块构成。</p><p><strong>Client Manager</strong>：客户端管理器。负责接收、解析客户端(Producer/Consumer)请求，管理客户端。例如，维护Consumer的Topic订阅信息</p><p><strong>Store Service</strong>：存储服务。提供方便简单的API接口，处理消息存储到物理硬盘和消息查询功能。</p><p><strong>HA Service</strong>：高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能。</p><p><strong>Index Service</strong>：索引服务。根据特定的Message key，对投递到Broker的消息进行索引服务，同时也提供根据Message Key对消息进行快速查询的功能。</p><h4 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309181440907.png" alt="image-20230918144029773"></p><p>为了增强Broker性能与吞吐量，Broker一般都是以集群形式出现的。各集群节点中可能存放着相同Topic的不同Queue。不过，这里有个问题，如果某Broker节点宕机，如何保证数据不丢失呢？其解决方案是，将每个Broker集群节点进行横向扩展，即将Broker节点再建为一个HA集群，解决单点问题。</p><p>Broker节点集群是一个主从集群，即集群中具有Master与Slave两种角色。Master负责处理读写操作请求，Slave负责对Master中的数据进行备份。当Master挂掉了，Slave则会自动切换为Master去工作。所以这个Broker集群是主备集群。一个Master可以包含多个Slave，但一个Slave只能隶属于一个Master。</p><p>Master与Slave 的对应关系是通过指定相同的BrokerName、不同的BrokerId 来确定的。BrokerId为0表示Master，非0表示Slave。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。</p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>1）启动NameServer，NameServer启动后开始监听端口，等待Broker、Producer、Consumer连接。</p><p>2）启动Broker时，Broker会与所有的NameServer建立并保持长连接，然后每30秒向NameServer定时发送心跳包。</p><p>3）发送消息前，可以先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，当然，在创建Topic时也会将Topic与Broker的关系写入到NameServer中。不过，这步是可选的，也可以在发送消息时自动创建Topic。</p><blockquote><p>Topic的<strong>手动</strong>创建有两种方式:</p><ul><li>集群模式:该模式下创建的Topic在该集群中,所有Broker中Queue的数量是<strong>相同</strong>的</li><li>Broker模式:该模式下创建的Topic在该集群中,所有Broker中Queue的数量可以<strong>不同</strong></li></ul><p><strong>自动</strong>创建Topic时,默认采用Broker模式,会为每个Broker默认创建4个Queue</p></blockquote><p>4）Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取路由信息，即当前发送的Topic消息的Queue与Broker的地址（IP+Port）的映射关系。然后根据算法策略从队选择一个Queue，与队列所在的Broker建立长连接从而向Broker发消息。当然，在获取到路由信息后，Producer会首先将路由信息缓存到本地，再每30秒从NameServer更新一次路由信息。</p><p>5）Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取其所订阅Topic的路由信息，然后根据算法策略从路由信息中获取到其所要消费的Queue，然后直接跟Broker建立长连接，开始消费其中的消息。Consumer在获取到路由信息后，同样也会每30秒从NameServer更新一次路由信息。不过不同于Producer的是，Consumer还会向Broker发送心跳，以确保Broker的存活状态。</p><p><strong>读/写队列</strong></p><p>从物理上来讲，读/写队列是同一个队列。所以，不存在读/写队列数据同步问题。读/写队列是逻辑上进行区分的概念。一般情况下，读/写队列数量是相同的。</p><p>例如，创建Topic时设置的写队列数量为8，读队列数量为4，此时系统会创建8个Queue，分别是0 1 2 3 4 5 6 7。Producer会将消息写入到这8个队列，但Consumer只会消费0 1 2 3这4个队列中的消息，4 5 6 7中的消息是不会被消费到的。</p><p>这样设计的目的是为了，方便Topic的Queue的缩容。</p><p>例如，原来创建的Topic中包含16个Queue，如何能够使其Queue缩容为8个，还不会丢失消息？可以动态修改写队列数量为8，读队列数量不变。此时新的消息只能写入到前8个队列，而消费都消费的却是16个队列中的数据。当发现后8个Queue中的消息消费完毕后，就可以再将读队列数量动态设置为8。整个缩容过程，没有丢失任何消息。</p><p>perm用于设置对当前创建Topic的操作权限：2表示只写，4表示只读，6表示读写</p><h2 id="三、系统安装与启动与console图形化控制台的安装与启动"><a href="#三、系统安装与启动与console图形化控制台的安装与启动" class="headerlink" title="三、系统安装与启动与console图形化控制台的安装与启动"></a>三、系统安装与启动与console图形化控制台的安装与启动</h2><p>省略实操步骤</p><p><strong>在linux下配置好了broker和NameServer,就是连不上console,试了十来个小时就是连不上,暂时先跳过</strong></p><h2 id="四、集群搭建理论"><a href="#四、集群搭建理论" class="headerlink" title="四、集群搭建理论"></a>四、集群搭建理论</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309211734870.png" alt="image-20230921173407729"></p><h3 id="数据复制与刷盘策略"><a href="#数据复制与刷盘策略" class="headerlink" title="数据复制与刷盘策略"></a>数据复制与刷盘策略</h3><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309211740953.png" alt="image-20230921174026909"></p><h4 id="复制策略"><a href="#复制策略" class="headerlink" title="复制策略"></a>复制策略</h4><p>复制策略是Broker的Master与Slave间的数据同步方式,分为同步复制和异步复制</p><ul><li>同步复制: 消息写入master后，master会等待slave同步数据成功后才向producer返回成功ACK</li><li>异步复制: 消息写入master后，master立即向producer返回成功ACK，无需等待slave同步数据成功</li></ul><h4 id="刷盘策略"><a href="#刷盘策略" class="headerlink" title="刷盘策略"></a>刷盘策略</h4><p>刷盘策略指的是broker中消息的<strong>落盘</strong>方式，即消息发送到broker内存后消息持久化到磁盘的方式。分为同步刷盘与异步刷盘：</p><ul><li><p>同步刷盘：当消息持久化到broker的<strong>磁盘</strong>后才算是消息写入成功。</p></li><li><p>异步刷盘：当消息写入到broker的<strong>内存</strong>后即表示消息写入成功，无需等待消息持久化到磁盘。</p></li></ul><blockquote><p>1)异步刷盘策略会降低系统的写入延迟,RT减小,提高了系统的吞吐量</p><p>2)消息写入到Broker的内存,一般是写入到了PageCache中</p><p>3)对于异步刷盘策略,消息会在写入到PageCache后立即返回成功ack;单并不会立刻落盘,而是等PageCache达到一定量后再落盘</p></blockquote><h3 id="Broker集群模式"><a href="#Broker集群模式" class="headerlink" title="Broker集群模式"></a>Broker集群模式</h3><p>根据Broker集群中各节点间关系不同,其可分为以下类</p><h4 id="1-单Master"><a href="#1-单Master" class="headerlink" title="1.单Master"></a>1.单Master</h4><p>只有一个broker（其本质上就不能称为集群）。这种方式也只能是在测试时使用，生产环境下不能使用，因为存在单点问题。</p><h4 id="2-多Master"><a href="#2-多Master" class="headerlink" title="2.多Master"></a>2.多Master</h4><p>broker集群仅由多个master构成，不存在Slave。同一Topic的各个Queue会平均分布在各个master节点上。</p><ul><li><p>优点：配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10(非常可靠)时，即使机器宕机不可恢复情况下，消息也不几乎会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；</p></li><li><p>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅（不可消费），消息实时性会受到影响。</p></li></ul><blockquote><p> 以上优点的前提是，这些<em>Master</em>都配置了<em>RAID</em>磁盘阵列。如果没有配置，一旦出现某<em>Master</em>宕机，则会发生大量消息丢失的情况。</p></blockquote><h4 id="3-多Master多Slave模式-异步复制"><a href="#3-多Master多Slave模式-异步复制" class="headerlink" title="3.多Master多Slave模式 - 异步复制"></a>3.多Master多Slave模式 - 异步复制</h4><p>broker集群由多个master构成，每个master又配置了多个slave（在配置了RAID磁盘阵列的情况下，一个master一般配置一个slave即可）。master与slave的关系是主备关系，即master负责处理消息的读写请求，而slave仅负责消息的<u>备份</u>与master宕机后的<u>角色切换</u>。</p><p>异步复制即前面所讲的复制策略中的异步复制策略，即消息写入master成功后，master立即向producer返回成功ACK，无需等待向slave同步数据的成功。</p><p>该模式的最大特点之一是，当master宕机后slave能够<strong>自动切换</strong>为master。不过由于slave从master的同步具有短暂的延迟（毫秒级），所以当master宕机后，这种异步复制方式可能会存在少量消息的丢失问题。</p><blockquote><p>Slave从Master同步的延迟越短,其可能丢失的消息越少(因为在同步的过程中如果master发生宕机,同步延迟越短,在宕机中被截断的数据越少)</p></blockquote><h4 id="4-多Master多Slave模式同步双写"><a href="#4-多Master多Slave模式同步双写" class="headerlink" title="4.多Master多Slave模式同步双写"></a>4.多Master多Slave模式同步双写</h4><p>该模式是多Master多Slave模式的同步复制实现。所谓同步双写，指的是消息写入master成功后，master会等待slave同步数据成功后才向producer返回成功ACK，即master与slave<strong>都</strong>要写入成功后才会返回成功ACK，也即双写。</p><p>该模式与异步复制模式相比，优点是消息的安<strong>全性更高</strong>，不存在消息丢失的情况。但单个消息的RT略高，从而导致<strong>性能略低</strong>（大约低10%）。</p><blockquote><p>该模式存在一个大的问题：对于目前的版本，Master宕机后，Slave<strong>不会自动切换</strong>到Master(截止21/7),这种设计决策是为了确保数据的一致性和可靠性。自动切换Slave节点为新的Master节点可能导致数据冲突和不一致性。</p></blockquote><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>一般会为Master配置RAID10磁盘阵列，然后再为其配置一个Slave。即利用了RAID10磁盘阵列的高效、安全性，又解决了可能会影响订阅的问题。</p><blockquote><p><em>1</em>）<em>RAID</em>磁盘阵列的效率要高于<em>Master-Slave</em>集群。因为<em>RAID</em>是硬件支持的,但其搭建成本较高。</p><p><em>2</em>）多<em>Master+RAID</em>阵列，与多<em>Master</em>多<em>Slave</em>集群的区别是什么？</p><ul><li><p>多<em>Master+RAID</em>阵列，其仅仅可以保证数据不丢失，即不影响消息写入，但其<u>可能会影响到消息的订阅</u>。但其执行效率要<strong>远高于</strong>多Master多Slave集群</p></li><li><p>多<em>Master</em>多<em>Slave</em>集群，其不仅可以保证数据不丢失，也不会影响消息订阅。但其运行效率要低于多Master+RAID阵列</p></li></ul></blockquote><h3 id="五、磁盘阵列RAID-补充扩展"><a href="#五、磁盘阵列RAID-补充扩展" class="headerlink" title="五、磁盘阵列RAID(补充扩展)"></a>五、磁盘阵列RAID(补充扩展)</h3><h3 id="1-RAID历史"><a href="#1-RAID历史" class="headerlink" title="1.RAID历史"></a>1.RAID历史</h3><p>RAID 概念于1988年被提出 ，即廉价冗余磁盘阵列。由于当时大容量磁盘比较昂贵， RAID 的基本思想是将多个容量较小、相对廉价的磁盘进行有机组合，从而以较低的成本获得与昂贵大容量磁盘相当的容量、性能、可靠性。随着磁盘成本和价格的不断降低， “廉价” 已经毫无意义。</p><p>因此， RAID 咨询委员会决定用“ 独立 ” 替代 “ 廉价 ” ，于是 RAID 变成了独立磁盘冗余阵列（ Redundant Array of Independent Disks ）。但这仅仅是名称的变化，实质内容没有改变。</p><h3 id="2-RAID等级"><a href="#2-RAID等级" class="headerlink" title="2.RAID等级"></a>2.RAID等级</h3><p>RAID 这种设计思想很快被业界接纳， RAID 技术作为高性能、高可靠的存储技术，得到了非常广泛的应用。 RAID 主要利用镜像、数据条带和数据校验三种技术来获取高性能、可靠性、容错能力和扩展性，根据对这三种技术的使用策略和组合架构，可以把 RAID 分为不同的等级，以满足不同数据应用的需求。</p><h1 id="第三章-RocketMQ工作原理"><a href="#第三章-RocketMQ工作原理" class="headerlink" title="第三章 RocketMQ工作原理"></a>第三章 RocketMQ工作原理</h1><h2 id="一、消息的生产"><a href="#一、消息的生产" class="headerlink" title="一、消息的生产"></a>一、消息的生产</h2><h3 id="1-消息的生产过程"><a href="#1-消息的生产过程" class="headerlink" title="1.消息的生产过程"></a>1.消息的生产过程</h3><p>Producer可以将消息写入到某Broker的某Queue中,过程如下</p><ul><li><p>Producer发送消息之前，会先向NameServer发出请求来获取<strong>消息Topic的路由信息</strong></p></li><li><p>NameServer返回该<strong>Topic的路由表</strong>及<strong>Broker列表</strong></p></li><li><p>Producer根据代码中指定的Queue选择策略，从Queue列表中选出一个队列，用于后续存储消息</p></li><li><p>Producer对消息做一些特殊处理，例如，消息本身超过4M，则会对其进行压缩</p></li><li><p>Producer向选择出的Queue所在的Broker发出RPC请求，将消息发送到选择出的Queue</p></li></ul><blockquote><p>路由表:实际上是一个Map,key为Topic名称,value是一个QueueData的实例列表(所有涉及该Topic的BrokerName列表)</p><p>Broker列表:其实际上也是一个Map,key为brokerName,value为BrokerData; 一套BrokerName相同的Master-Slave小集群对应一个BrokerData; BrokerData中包含brokerName及一个map; 该Map的key为brokerId, value为broker对应的地址; brokerId为0表示为master,非0表示slave</p></blockquote><h3 id="2-Queue选择算法"><a href="#2-Queue选择算法" class="headerlink" title="2.Queue选择算法"></a>2.Queue选择算法</h3><h4 id="轮询算法"><a href="#轮询算法" class="headerlink" title="轮询算法"></a>轮询算法</h4><p>默认选择算法; 其保证了每个Queue都可以均匀地获取到消息,避免了饥饿</p><blockquote><p>缺点:若某些Broker的Queue投递时延较高,会导致Producer的缓存队列消息挤压,降低性能</p></blockquote><h4 id="最小投递延迟算法"><a href="#最小投递延迟算法" class="headerlink" title="最小投递延迟算法"></a>最小投递延迟算法</h4><p>根据统计的每次消息投递的时间延迟,将消息投递到时延最小的Queue; 若延迟相同,则采取轮询算法投递</p><blockquote><p>缺点:消息在Queue上分配不均</p></blockquote><h2 id="二、消息的存储"><a href="#二、消息的存储" class="headerlink" title="二、消息的存储"></a>二、消息的存储</h2><p>RocketMQ的消息默认存储在本地文件系统的主目录下store目录中</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309242036005.png" alt="image-20230924203630910"></p><ul><li>abort：该文件在Broker启动后会自动创建，正常关闭Broker，该文件会自动消失。若在没有启动</li><li>Broker的情况下，发现这个文件是存在的，则说明之前Broker的关闭是非正常关闭。</li><li>checkpoint：其中存储着commitlog、consumequeue、index文件的最后刷盘时间戳</li><li>commitlog：其中存放着commitlog文件，而消息是写在commitlog文件中的</li><li>config：存放着Broker运行期间的一些配置数据</li><li>consumequeue：其中存放着consumequeue文件，队列就存放在这个目录中</li><li>index：其中存放着消息索引文件indexFile</li><li>lock：运行期间使用到的全局资源锁</li></ul><h3 id="1-commitlog文件"><a href="#1-commitlog文件" class="headerlink" title="1.commitlog文件"></a>1.commitlog文件</h3><p><del>在很多资料中<em>commitlog</em>目录中的文件简称为<em>commitlog</em>文件。但在源码中，该文件被命名为<em>mappedFile</em>。</del></p><h4 id="目录与文件"><a href="#目录与文件" class="headerlink" title="目录与文件"></a>目录与文件</h4><p>commitlog目录中存放着很多的mappedFile文件，当前Broker中的所有消息都是落盘到这些mappedFile文件中的。mappedFile文件最大大小为1G，文件名由20位十进制数构成，表示当前文件的第一条消息的起始位移偏移量。</p><blockquote><p>一个<em>Broker</em>中所有<em>mappedFile</em>文件的<em>commitlog offset</em>是连续的, 第<em>n</em>个文件名应该是前<em>n-1</em>个文件大小之和。</p></blockquote><p>需要注意的是，一个Broker中仅包含一个commitlog目录，所有的mappedFile文件都是存放在该目录中的。即无论当前Broker中存放着多少Topic的消息，这些消息都是被顺序写入到了mappedFile文件中的。也就是说,<del>因为用顺序读写效率高</del>，这些消息在Broker中存放时并没有被按照Topic进行分类存放。</p><h4 id="消息单元"><a href="#消息单元" class="headerlink" title="消息单元"></a>消息单元</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309242116980.png" alt="image-20230924211625897"></p><p>mappedFile文件内容由一个个的消息单元构成。每个消息单元中包含消息总长度MsgLen、消息的物理位置physicalOffset、消息体内容Body、消息体长度BodyLength、消息主题Topic、Topic长度TopicLength、消息生产者BornHost、消息发送时间戳BornTimestamp、消息所在的队列QueueId、消息在Queue中存储的偏移量QueueOffset等近20余项消息相关属性。</p><blockquote><p>commitlog与queue的关系</p><p>一个mappedFile文件中第m+1个消息单元的commitlog offset偏移量:</p><p>L(m+1)=L(m)+MsgLen(m)  (m&gt;0)</p></blockquote><h3 id="2-consumequeue"><a href="#2-consumequeue" class="headerlink" title="2.consumequeue"></a>2.consumequeue</h3><p>存储消息在CommitLog中的位置信息,可以看作是commitlog关于消息消费的索引文件</p><h4 id="目录与文件-1"><a href="#目录与文件-1" class="headerlink" title="目录与文件"></a>目录与文件</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309252130546.png" alt="image-20230925213011483"></p><p>为了提高效率，会为每个Topic在~/store/consumequeue中创建一个目录，目录名为Topic名称。在该Topic目录下，会再为每个该Topic的Queue建立一个目录，目录名为queueId。每个目录中存放着若干consumequeue文件，consumequeue文件是commitlog的索引文件，可以根据consumequeue定位到具体的消息。</p><p>consumequeue文件名也由20位数字构成，表示当前文件的第一个索引条目的起始位移偏移量。与mappedFile文件名不同的是，其后续文件名是固定的。因为consumequeue文件大小是固定不变的。</p><h4 id="索引条目"><a href="#索引条目" class="headerlink" title="索引条目"></a>索引条目</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309252131574.png" alt="image-20230925213120532"></p><p>每个consumequeue文件可以包含30w个索引条目，每个索引条目包含了三个消息重要属性：消息在mappedFile文件中的偏移量CommitLog Offset、消息长度、消息Tag的hashcode值。这三个属性占20个字节，所以每个文件的最大大小是固定的30w * 20字节。</p><blockquote><p>一个<em>consumequeue</em>文件中所有消息的<em>Topic</em>一定是相同的。但每条消息的<em>Tag</em>可能是不同的。</p></blockquote><h3 id="3-对文件的读写"><a href="#3-对文件的读写" class="headerlink" title="3.对文件的读写"></a>3.对文件的读写</h3><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309252136726.png" alt="image-20230925213657682"></p><h4 id="消息写入"><a href="#消息写入" class="headerlink" title="消息写入"></a>消息写入</h4><p>一条消息进入到Broker后经历了以下几个过程才最终被持久化。</p><ul><li><p>Broker根据queueId，获取到该消息对应索引条目要在consumequeue目录中的写入偏移量，即QueueOffset</p></li><li><p>将queueId、queueOffset等数据，与消息一起封装为消息单元</p></li><li><p>将消息单元写入到commitlog</p></li><li><p>同时，形成消息索引条目</p></li><li><p>将消息索引条目分发到相应的consumequeue</p></li></ul><h4 id="消息拉取"><a href="#消息拉取" class="headerlink" title="消息拉取"></a>消息拉取</h4><p>当Consumer来拉取消息时会经历以下几个步骤：</p><ul><li>Consumer获取到其要消费消息所在Queue的消费偏移量offset，计算出其要消费消息的消息offset</li></ul><blockquote><p>消费<em>offset</em>即消费进度，<em>consumer</em>对某个<em>Queue</em>的消费<em>offset</em>，即消费到了该<em>Queue</em>的第几条消息</p><p>消息<em>offset =</em> 消费<em>offset + 1</em></p></blockquote><ul><li><p>Consumer向Broker发送拉取请求，其中会包含其要拉取消息的Queue、消息offset及消息Tag。</p></li><li><p>Broker计算在该consumequeue中的queueOffset。</p></li></ul><blockquote><p>queueOffset =消息offset * 20字节</p></blockquote><ul><li><p>从该queueOffset处开始向后查找第一个指定Tag的索引条目。</p></li><li><p>解析该索引条目的前8个字节，即可定位到该消息在commitlog中的commitlog offset</p></li><li><p>从对应commitlog offset中读取消息单元，并发送给Consumer</p></li></ul><h4 id="性能提升"><a href="#性能提升" class="headerlink" title="性能提升"></a>性能提升</h4><p>RocketMQ中，无论是消息本身还是消息索引，都是存储在磁盘上的。其不会影响消息的消费吗？当然不会。其实RocketMQ的性能在目前的MQ产品中性能是非常高的。因为系统通过一系列相关机制大大提升了性能。</p><p>首先，RocketMQ对文件的读写操作是通过<strong>mmap零拷贝</strong>进行的，将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率。</p><p>其次，consumequeue中的数据是顺序存放的，还引入了<strong>PageCache的预读取机制</strong>，使得对consumequeue文件的读取几乎接近于内存读取，即使在有消息堆积情况下也不会影响性能</p><blockquote><p><em>PageCache</em>机制，页缓存机制，是<em>OS</em>对文件的缓存机制，用于加速对文件的读写操作。一般来说，程序对文件进行<strong>顺序读写</strong>的速度几乎接近于内存读写速度，主要原因是由于<em>OS</em>使用<em>PageCache</em>机制对读写访问操作进行性能优化，将一部分的内存用作<em>PageCache</em>。</p><ul><li><p>写操作：<em>OS</em>会先将数据写入到<em>PageCache</em>中，随后会以异步方式由<em>pdflush</em>（<em>page dirty flush)</em>内核线程将<em>Cache</em>中的数据刷盘到物理磁盘</p></li><li><p>读操作：若用户要读取数据，其首先会从<em>PageCache</em>中读取，若没有命中，则<em>OS</em>在从物理磁盘上加载该数据到<em>PageCache</em>的同时，也会顺序对其相邻数据块中的数据进行<strong>预读取</strong>。</p></li></ul></blockquote><p>RocketMQ中可能会影响性能的是对commitlog文件的读取。因为对commitlog文件来说，读取消息时会产生大量的随机访问(在commitlog中找想要的消息)，而随机访问会严重影响性能。不过，如果选择合适的系统IO调度算法，比如设置调度算法为Deadline（采用SSD固态硬盘的话），随机读的性能也会有所提升。</p><h2 id="三、indexFile"><a href="#三、indexFile" class="headerlink" title="三、indexFile"></a>三、indexFile</h2><p>除了通过通常的指定Topic进行消息消费外，RocketMQ还提供了根据key进行消息查询的功能。该查询是通过store目录中的index子目录中的indexFile进行索引实现的快速查询。当然，这个indexFile中的索引数据是在<strong>包含了key的消息</strong>被发送到Broker时写入的。如果消息中没有包含key，则不会写入。</p><h3 id="1-indexFile结构"><a href="#1-indexFile结构" class="headerlink" title="1.indexFile结构"></a>1.indexFile结构</h3><p>每个Broker中会包含一组indexFile，每个indexFile都是以一个<strong>时间戳</strong>命名的（这个indexFile被创建时的时间戳）。每个indexFile文件由三部分构成：indexHeader，slots槽位，indexes索引数据。每个indexFile文件中包含500w个slot槽。而每个slot槽又可能会挂载很多的index索引单元</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309252217818.png" alt="image-20230925221749771"></p><p>indexHeader固定40个字节，其中存放着如下数据：</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309252218067.png" alt="image-20230925221844032"></p><ul><li>beginTimestamp：该indexFile中第一条消息的存储时间</li><li>endTimestamp：该indexFile中最后一条消息存储时间</li><li>beginPhyoffset：该indexFile中第一条消息在commitlog中的偏移量commitlog offset</li><li>endPhyoffset：该indexFile中最后一条消息在commitlog中的偏移量commitlog offset</li><li>hashSlotCount：已经填充有index的slot数量（并不是每个slot槽下都挂载有index索引单元，这里统计的是所有挂载了index索引单元的slot槽的数量）</li><li>indexCount：该indexFile中包含的索引单元个数（统计出当前indexFile中所有slot槽下挂载的<strong>所有</strong>index索引单元的数量之和）</li></ul><p>Slots与Indexes间的关系:</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309252221053.png" alt="image-20230925222152967"></p><p><strong>key的hash值 % 500w</strong>的结果即为slot槽位，然后将该slot值修改为该index索引单元的indexNo，根据这个indexNo可以计算出该index单元在indexFile中的位置。不过，该取模结果的重复率是很高的，为了解决该问题，在每个index索引单元中增加了preIndexNo，用于指定该slot中当前index索引单元的前一个index索引单元。而slot中始终存放的是其下最新的index索引单元的indexNo，这样的话，<strong>只要找到了slot就可以找到其最新的index索引单元，而通过这个index索引单元就可以找到其之前的所有index索引单元</strong>。</p><blockquote><p><em>indexNo</em>是一个在<em>indexFile</em>中的流水号，从<em>0</em>开始依次递增。即在一个<em>indexFile</em>中所有<em>indexNo</em>是依次递增的。<em>indexNo</em>在<em>index</em>索引单元中是没有体现的，其是通过<em>indexes</em>中依次数出来的。</p></blockquote><p>index索引单元有20个字节，其中存放着以下四个属性：</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309252227550.png" alt="image-20230925222743506"></p><h3 id="2-indexFile的创建"><a href="#2-indexFile的创建" class="headerlink" title="2.indexFile的创建"></a>2.indexFile的创建</h3><h4 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h4><p>indexFile的文件名为当前文件被创建时的时间戳。这个时间戳有什么用处呢？</p><p>根据业务key进行查询时，查询条件除了key之外，还需要指定一个要查询的时间戳，表示要查询不大于该时间戳的最新的消息，即查询指定时间戳之前存储的最新消息。这个时间戳文件名可以简化查询，提高查询效率。</p><h4 id="创建时机"><a href="#创建时机" class="headerlink" title="创建时机"></a>创建时机</h4><p>indexFile文件是何时创建的？其创建的条件（时机）有两个：</p><ul><li>当第一条带key的消息发送来后，系统发现没有indexFile，此时会创建第一个indexFile文件</li><li>当一个indexFile中挂载的index索引单元数量超出2000w个时，会创建新的indexFile。当带key的消息发送到来后，系统会找到最新的indexFile，并从其indexHeader的最后4字节中读取到indexCount。若indexCount &gt;= 2000w时，会创建新的indexFile。</li></ul><blockquote><p> 由于可以推算出，一个<em>indexFile</em>的最大大小是：<em>(40 + 500w \</em> 4 + 2000w * 20)*字节</p></blockquote><h3 id="3-查询流程"><a href="#3-查询流程" class="headerlink" title="3.查询流程"></a>3.查询流程</h3><p>当消费者通过业务key来查询相应的消息时，其需要经过一个相对较复杂的查询流程。不过，在分析查</p><p>询流程之前，首先要清楚几个定位计算式子：</p><ul><li><p>计算指定消息key的slot槽位序号:  <code>slot槽位序号 = key的hash%500w</code></p></li><li><p>计算槽位序号为n的slot在indexFile中的起始位置: <code>slot(n)位置=40+(n-1)*4</code></p></li><li><p>计算indexNo为m的index在indexFile中的位置:  <code>index(x)的位置=40+500w*4+(m-1)*20</code></p></li></ul><p>具体的查询流程如下:</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309252351654.png" alt="image-20230925235145545"></p><h2 id="四、消息的消费"><a href="#四、消息的消费" class="headerlink" title="四、消息的消费"></a>四、消息的消费</h2><p>消费者从Broker中获取消息的方式有两种：pull拉取方式和push推动方式。</p><p>消费者组对于消息消费的模式又分为两种：集群消费Clustering和广播消费Broadcasting。</p><h3 id="1-推拉消费类型"><a href="#1-推拉消费类型" class="headerlink" title="1.推拉消费类型"></a>1.推拉消费类型</h3><h4 id="拉取push式消费"><a href="#拉取push式消费" class="headerlink" title="拉取push式消费"></a>拉取push式消费</h4><p>Consumer主动从Broker中拉取消息，主动权由Consumer控制。一旦获取了批量消息，就会启动消费过程。不过，该方式的实时性较弱，即Broker中有了新的消息时消费者并不能及时发现并消费。</p><blockquote><p>由于拉取时间间隔是由用户指定的，所以在设置该间隔时需要注意平稳：间隔太短，空请求比例会增加；间隔太长，消息的实时性太差</p></blockquote><h4 id="推送pull式消费"><a href="#推送pull式消费" class="headerlink" title="推送pull式消费"></a>推送pull式消费</h4><p>该模式下Broker收到数据后会主动推送给Consumer。该获取方式一般实时性较高。</p><p>该获取方式是典型的发布-订阅模式，即Consumer向其关联的Queue注册了监听器，一旦发现有新的消息到来就会触发回调的执行，回调方法是Consumer去Queue中拉取消息。而这些都是基于Consumer与Broker间的长连接的。长连接的维护需要消耗系统资源</p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ul><li><p>pull：需要应用去实现对关联Queue的遍历，实时性差；但便于应用控制消息的拉取</p></li><li><p>push：封装了对关联Queue的遍历，实时性强，但会占用较多的系统资源</p></li></ul><h3 id="2-消费模式"><a href="#2-消费模式" class="headerlink" title="2.消费模式"></a>2.消费模式</h3><h4 id="广播消费"><a href="#广播消费" class="headerlink" title="广播消费"></a>广播消费</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309261502889.png" alt="image-20230926145526581"></p><p>广播消费模式下，相同Consumer Group的每个Consumer实例都接收同一个Topic的全量消息。即每条消息都会被发送到Consumer Group中的<strong>每个</strong>Consumer。</p><h4 id="集群消费"><a href="#集群消费" class="headerlink" title="集群消费"></a>集群消费</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309261502689.png" alt="image-20230926145710024"></p><p>集群消费模式下，相同Consumer Group的每个Consumer实例<strong>平均分摊</strong>同一个Topic的消息。即每条消息只会被发送到Consumer Group中的<strong>某个</strong>Consumer。</p><h4 id="消息进度保存"><a href="#消息进度保存" class="headerlink" title="消息进度保存"></a>消息进度保存</h4><ul><li><p>广播模式：消费进度保存在consumer端。因为广播模式下consumer group中每个consumer都会消费所有消息，但它们的消费进度是不同。所以consumer各自保存各自的消费进度。</p></li><li><p>集群模式：消费进度保存在broker中。consumer group中的所有consumer共同消费同一个Topic中的消息，同一条消息只会被消费一次。消费进度会参与到了消费的负载均衡中，故消费进度是需要共享的。</p></li></ul><h3 id="3-Rebalance机制"><a href="#3-Rebalance机制" class="headerlink" title="3.Rebalance机制"></a>3.Rebalance机制</h3><p>Rebalance机制需要在集群消费模式下部署</p><h4 id="Rebalance概念"><a href="#Rebalance概念" class="headerlink" title="Rebalance概念"></a>Rebalance概念</h4><p>Rebalance机制将一个Topic下的多个Queue在同一个Consumer Group中的多个Consumer间重新进行分配的过程</p><p>其是为了提升<strong>并行</strong>消费能力,动态地将Topic分配给Consumer集群</p><h4 id="Rebalance限制"><a href="#Rebalance限制" class="headerlink" title="Rebalance限制"></a>Rebalance限制</h4><p>由于一个队列最多只能分配给一个消费者,因此当某个消费者组下的消费者数大于Topic队列的数量时,多余的消费者实例将被闲置,造成资源的浪费</p><h4 id="Rebanlance缺点"><a href="#Rebanlance缺点" class="headerlink" title="Rebanlance缺点"></a>Rebanlance缺点</h4><ul><li><strong>消费暂停</strong>: 当新增Consumer时,正在进行消费的Consumer会被暂停,并在重新分配topic队列完成后再继续运行</li><li><strong>消费重复</strong>: Consumer 在消费新分配给自己的队列时，必须接着之前Consumer 提交的消费进度的offset继续消费。然而默认情况下，offset是<strong>异步提交</strong>的，这个异步性导致提交到Broker的offset与Consumer实际消费的消息并不一致。这个不一致的差值就是可能会重复消费的消息。</li></ul><blockquote><p>同步提交：<em>consumer</em>提交了其消费完毕的一批消息的<em>offset</em>给<em>broker</em>后，需要等待<em>broker</em>的成功ACK<em>。当收到</em>ACK<em>后，</em>consumer<em>才会继续获取并消费下一批消息。在等待</em>ACK<em>期间，</em>consumer是阻塞的。</p><p>异步提交：<em>consumer</em>提交了其消费完毕的一批消息的<em>offset</em>给<em>broker</em>后，不需要等待<em>broker</em>的成功<em>ACK</em>。<em>consumer</em>可以直接获取并消费下一批消息。</p><p>对于一次性读取消息的数量，需要根据具体业务场景选择一个相对均衡的是很有必要的。因为数量过大，系统性能提升了，但产生重复消费的消息数量可能会增加；数量过小，系统性能会下降，但被重复消费的消息数量可能会减少。</p></blockquote><p><strong>消费突刺</strong>: 如果Rebalance积累的消息重复过多或暂停时间过长导致消息大量积压,可能导致Rebalance结束之后瞬间需要消费大量消息</p><h4 id="Rebalance产生原因"><a href="#Rebalance产生原因" class="headerlink" title="Rebalance产生原因"></a>Rebalance产生原因</h4><ul><li>消费者订阅的Topic的Queue数量变化 (Broker容量调整/升级运维/与NameServer网络异常,Queue容量调整)</li><li>消费者组中消费者数量变化 (Consumer group容量调整/升级运维/与NameServer网络异常)</li></ul><h4 id="Rebalance过程"><a href="#Rebalance过程" class="headerlink" title="Rebalance过程"></a>Rebalance过程</h4><p>在Broker中维护着多个Map集合，这些集合中动态存放着当前Topic中Queue的信息、Consumer Group中Consumer实例的信息。一旦发现消费者所订阅的Queue数量发生变化，或消费者组中消费者的数量发生变化，立即向Consumer Group中的每个实例发出Rebalance通知。</p><p>Consumer实例在接收到通知后会采用Queue分配算法自己获取到相应的Queue，即由Consumer实例自主进行Rebalance。</p><h3 id="4-Queue分配算法"><a href="#4-Queue分配算法" class="headerlink" title="4.Queue分配算法"></a>4.Queue分配算法</h3><p>一个Topic中的Queue只能由Consumer Group中的一个Consumer进行消费，而一个Consumer可以同时消费多个Queue中的消息。那么Queue与Consumer间的配对关系是如何确定的，即Queue要分配给哪个Consumer进行消费，也是有算法策略的。常见的有四种策略。这些策略是通过在创建Consumer时的构造器传进去的。</p><h4 id="平均分配策略"><a href="#平均分配策略" class="headerlink" title="平均分配策略"></a>平均分配策略</h4><p><img src="C:/Users/Hantou/AppData/Roaming/Typora/typora-user-images/image-20230926221043803.png" alt="image-20230926221043803"></p><p>该算法是要根据<code>avg = QueueCount / ConsumerCount</code> 的计算结果进行分配的。如果能够整除，则按顺序将avg个Queue逐个分配Consumer；如果不能整除，则将多余出的Queue按照Consumer顺序逐个分配。(先算再分)</p><h4 id="环形平均策略"><a href="#环形平均策略" class="headerlink" title="环形平均策略"></a>环形平均策略</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309262212580.png" alt="image-20230926221233496"></p><p>环形平均算法是指，根据消费者的顺序，依次在由queue队列组成的环形图中逐个分配。(直接轮流来)</p><h4 id="一致性hash策略"><a href="#一致性hash策略" class="headerlink" title="一致性hash策略"></a>一致性hash策略</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309262214544.png" alt="image-20230926221413488"></p><p>该算法会将consumer的hash值作为Node节点存放到hash环上，然后将queue的hash值也放到hash环上，通过<strong>顺时针</strong>方向，距离queue最近的那个consumer就是该queue要分配的consumer。</p><blockquote><p>缺点:分配不均</p></blockquote><h4 id="同机房策略"><a href="#同机房策略" class="headerlink" title="同机房策略"></a>同机房策略</h4><p>该算法会根据queue的部署机房位置和consumer的位置，过滤出当前consumer相同机房的queue。然后按照平均分配策略或环形平均策略对同机房queue进行分配。如果没有同机房queue，则按照平均分配策略或环形平均策略对所有queue进行分配。</p><h3 id="5-至少一次原则"><a href="#5-至少一次原则" class="headerlink" title="5.至少一次原则"></a>5.至少一次原则</h3><p>RocketMQ有一个原则：每条消息必须要被<strong>成功消费</strong>一次。</p><p>那么什么是成功消费呢？Consumer在消费完消息后会向其<strong>消费进度记录器</strong> (在广播模式中就是Consumer本身,在集群消费模式中就是Broker) 提交其消费消息的offset，offset被成功记录到记录器中，那么这条消费就被成功消费了。</p><h2 id="五、订阅关系的一致性"><a href="#五、订阅关系的一致性" class="headerlink" title="五、订阅关系的一致性"></a>五、订阅关系的一致性</h2><p>订阅关系的一致性指的是，<strong>同一个</strong>消费者组（Group ID相同）下所有Consumer实例所订阅的Topic与Tag及对消息的处理逻辑必须完全一致。否则，消息消费的逻辑就会混乱，甚至导致消息丢失。</p><h3 id="1-正确订阅关系"><a href="#1-正确订阅关系" class="headerlink" title="1 正确订阅关系"></a>1 正确订阅关系</h3><p>多个消费者组订阅了多个Topic，并且每个消费者组里的多个消费者实例的订阅关系<strong><u>(Topic+Tag+其数量)</u></strong>保持了一致。</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309262225866.png" alt="image-20230926222549803"></p><h3 id="2-错误订阅关系"><a href="#2-错误订阅关系" class="headerlink" title="2 错误订阅关系"></a>2 错误订阅关系</h3><p>一个消费者组订阅了多个Topic，但是该消费者组里的多个Consumer实例的订阅关系并没有保持一致。</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309262226443.png" alt="image-20230926222627399"></p><h2 id="六、offset管理"><a href="#六、offset管理" class="headerlink" title="六、offset管理"></a>六、offset管理</h2><blockquote><p>此处offset指Consumer的消费进度offset</p></blockquote><p>消费进度offset是用来记录每个Queue的不同消费组的消费进度的。根据消费进度记录器的不同，可以分为两种模式：本地模式和远程模式。</p><h3 id="1-offset本地管理模式"><a href="#1-offset本地管理模式" class="headerlink" title="1. offset本地管理模式"></a>1. offset<strong>本地管理模式</strong></h3><p>当消费模式为<strong>广播消费</strong>时，offset使用本地模式存储。因为每条消息会被所有的消费者消费，每个消费者管理自己的消费进度，各个消费者之间不存在消费进度的交集。</p><p>Consumer在广播消费模式下offset相关数据以json的形式持久化到Consumer本地磁盘文件中，默认文件路径为当前用户主目录下的<code>.rocketmq_offsets/$&#123;clientId&#125;/$&#123;group&#125;/Offsets.json</code> </p><p>其中${clientId}为当前消费者id，默认为ip@DEFAULT；${group}为消费者组名称。</p><h3 id="2-offset远程管理模式"><a href="#2-offset远程管理模式" class="headerlink" title="2.offset远程管理模式"></a>2.offset远程管理模式</h3><p>当消费模式为<strong>集群消费</strong>时，offset使用远程模式管理。因为所有Cosnumer实例对消息采用的是均衡消费，所有Consumer共享Queue的消费进度。</p><p>Consumer在集群消费模式下offset相关数据以json的形式持久化到<strong>Broker</strong>磁盘文件中，文件路径为当前用户主目录下的<code>store/config/consumerOffset.json</code> </p><p>Broker启动时会加载这个文件，并写入到一个双层Map（ConsumerOffsetManager）。外层map的key为topic@group，value为内层map。内层map的key为queueId，value为offset。当发生Rebalance时，新的Consumer会从该Map中获取到相应的数据来继续消费。</p><p>集群模式下offset采用远程管理模式，主要是为了保证Rebalance机制。</p><h3 id="3-offset用途"><a href="#3-offset用途" class="headerlink" title="3.offset用途"></a>3.offset用途</h3><p>消费者是如何从最开始持续消费消息的？消费者要消费的第一条消息的起始位置是用户自己通过consumer.setConsumeFromWhere()方法指定的。</p><p>在Consumer启动后，其要消费的第一条消息的起始位置常用的有三种，这三种位置可以通过枚举类型常量设置。这个枚举类型为ConsumeFromWhere。</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309262238675.png" alt="image-20230926223846591"></p><blockquote><p><em>CONSUME_FROM_LAST_OFFSET</em>：从<em>queue</em>的当前最后一条消息开始消费</p><p><em>CONSUME_FROM_FIRST_OFFSET</em>：从<em>queue</em>的第一条消息开始消费</p><p><em>CONSUME_FROM_TIMESTAMP</em>：从指定的具体时间戳位置的消息开始消费。这个具体时间戳是通过另外一个语句指定的 。</p><p><em>consumer.setConsumeTimestamp(“20230902680000”) yyyyMMddHHmmss</em></p></blockquote><p>当消费完一批消息后，Consumer会提交其消费进度offset给Broker，Broker在收到消费进度后会将其更新到那个双层Map（ConsumerOffsetManager）及consumerOffset.json文件中，然后向该Consumer进行ACK，而ACK内容中包含三项数据：当前消费队列的最小offset（minOffset）、最大offset（maxOffset）、及下次消费的起始offset（nextBeginOffset）</p><h3 id="4-重试队列"><a href="#4-重试队列" class="headerlink" title="4.重试队列"></a>4.重试队列</h3><p>当rocketMQ对消息的消费出现异常时，会将发生异常的消息的offset提交到Broker中的重试队列。系统在发生消息消费异常时会为当前的topic@group创建一个重试队列，该队列以%RETRY%开头，到达重试时间后进行消费重试。</p><h3 id="5-offset的同步-异步提交"><a href="#5-offset的同步-异步提交" class="headerlink" title="5.offset的同步/异步提交"></a>5.offset的同步/异步提交</h3><p>集群消费模式下，Consumer消费完消息后会向Broker提交消费进度offset，其提交方式分为两种：</p><ul><li><p><strong>同步提交</strong>：消费者在消费完一批消息后会向broker提交这些消息的offset，然后等待broker的成功响应。若在等待超时之前收到了成功响应，则继续读取下一批消息进行消费（从ACK中获取nextBeginOffset）。若没有收到响应，则会重新提交，直到获取到响应。而在这个等待过程中，消费者是阻塞的。其严重影响了消费者的吞吐量。</p></li><li><p><strong>异步提交</strong>：消费者在消费完一批消息后向broker提交offset，但无需等待Broker的成功响应，可以继续读取并消费下一批消息。这种方式增加了消费者的吞吐量。但需要注意，broker在收到提交的offset后，还是会向消费者进行响应的。可能还没有收到ACK，此时Consumer会从Broker中直接获取nextBeginOffset。</p></li></ul><h2 id="七、消费幂"><a href="#七、消费幂" class="headerlink" title="七、消费幂"></a>七、消费幂</h2><h3 id="1-消费幂的概念"><a href="#1-消费幂的概念" class="headerlink" title="1.消费幂的概念"></a>1.消费幂的概念</h3><p>当出现消费者对某条消息重复消费的情况时，重复消费的结果与消费一次的结果是相同的，并且多次消费并未对业务系统产生任何负面影响，那么这个消费过程就是消费幂等的。</p><blockquote><p>幂等：若某操作执行多次与执行一次对系统产生的影响是相同的，则称该操作是幂等的。</p></blockquote><p>在互联网应用中，尤其在网络不稳定的情况下，消息很有可能会出现重复发送或重复消费。如果重复的消息可能会影响业务处理，那么就应该对消息做幂等处理。</p><h3 id="2-消息重复的可能场景"><a href="#2-消息重复的可能场景" class="headerlink" title="2.消息重复的可能场景"></a>2.消息重复的可能场景</h3><h4 id="发送时消息重复"><a href="#发送时消息重复" class="headerlink" title="发送时消息重复"></a>发送时消息重复</h4><p>当Broker已经收到了Producer发来的消息并且完成持久化后,网络产生异常,导致Broker对Producer无法应答; 若Producer认为发送未成功并重试,此时Broker中可能产生两条相同的信息,之后Consumer也会消费两次一样的信息</p><h4 id="消费时消息重复"><a href="#消费时消息重复" class="headerlink" title="消费时消息重复"></a>消费时消息重复</h4><p>当Consumer已经收到了Broker发来的消息并完成处理后,网络产生异常,Broker未收到消费成功响应; 本着消息至少被消费一次的原则,Broker在网络回复后会再发送一次消息,此时Consumer又消费了一次相同的消息</p><h4 id="Rebalance时消息重复"><a href="#Rebalance时消息重复" class="headerlink" title="Rebalance时消息重复"></a>Rebalance时消息重复</h4><p>当消费者组中消费者数量变化或其订阅的topic的queue数量变化时,会触发Rebalance,此时消费者可能会收到曾经消费过的消息</p><h3 id="3-通用处理方案"><a href="#3-通用处理方案" class="headerlink" title="3.通用处理方案"></a>3.通用处理方案</h3><h4 id="两要素"><a href="#两要素" class="headerlink" title="两要素"></a>两要素</h4><ul><li><strong>幂等令牌</strong>: 是生产者和消费者两者中的既定协议,通常指具备唯一业务标示的字符串(eg: 订单号,流水号),一般是由Produce随着消息一同发送的</li><li><strong>唯一性处理</strong>: 服务端通过一定的算法策略,保证同一个业务不会被重复执行多次(eg:单笔订单支付操作)</li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li><p>首先通过<strong>缓存</strong>去重; 在缓存中若存在某幂等令牌,则说明本次操作是重复操作; 若缓存未命中,则进入下一步</p></li><li><p>在唯一性处理之前,现在<strong>数据库</strong>中查询幂等令牌作为索引的数据是否存在; 若存在,说明本次操作为重复操作; 若不存在,进入下一步</p></li><li>在同一事务中完成三项操作:唯一性处理-&gt;将幂等令牌写入缓存-&gt;将幂等令牌作为唯一索引,把数据写入数据库</li></ol><blockquote><p>两次查询一次是查缓存,一次是查数据库</p></blockquote><h2 id="八、消息堆积与消息延迟"><a href="#八、消息堆积与消息延迟" class="headerlink" title="八、消息堆积与消息延迟"></a>八、消息堆积与消息延迟</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>消息处理流程中,若Consumer的消费速度跟不上Producer的发送速度(进多出少),MQ中未处理的消息会越来越长,产生消息堆积; 消息出现堆积会发生消息延迟;</p><p>以下场景需要重点关注消息堆积和消费延迟问题:</p><ul><li><p>业务系统上下游能力不匹配导致消费堆积,且无法自行恢复</p></li><li><p>业务系统对消息的实时性要求高,无法接受消息堆积造成的延迟</p></li></ul><h3 id="2-产生原因分析"><a href="#2-产生原因分析" class="headerlink" title="2.产生原因分析"></a>2.产生原因分析</h3><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309271413333.png" alt="image-20230927141309207"></p><p>Consumer使用长轮询Pull模式消费消息,分为以下两个阶段:</p><h4 id="拉取消息"><a href="#拉取消息" class="headerlink" title="拉取消息"></a>拉取消息</h4><p>Consumer通过长轮询Pull模式批量拉取的方式从服务端获取消息,将拉取到的消息缓存到本地缓冲队列中; 对于拉取式消费,在内网下吞吐量较高,一般不会在此阶段堆积消息</p><h4 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h4><p>Consumer将本地缓存的消息提交到消费线程中，使用业务消费逻辑对消息进行处理，处理完毕后获取到一个结果。这是真正的消息消费过程。此时Consumer的消费能力就完全依赖于消息的消费耗时和消费并发度了。如果由于业务处理逻辑复杂等原因，导致处理单条消息的耗时较长，则整体的消息吞吐量肯定不会高，此时就会导致Consumer本地缓冲队列达到上限，停止从服务端拉取消息。</p><blockquote><p>消息堆积的主要原因是客户端的消费能力不足,而消费能力由<strong>消费耗时</strong>(高优先)和<strong>消费并发度</strong>(低优先)决定</p></blockquote><h3 id="3-消费耗时"><a href="#3-消费耗时" class="headerlink" title="3.消费耗时"></a>3.消费耗时</h3><p>影响消费耗时的主要因素是代码逻辑;而代码中影响处理市场的主要为<strong>CPU内部计算型代码</strong>和<strong>外部IO操作型代码</strong></p><blockquote><p>外部IO型代码是影响消息处理市场的主要原因</p><p>外部IO举例: 读写外部数据库/缓存/下游系统调用</p><p>对于下游系统的调用逻辑,需要提前梳理调用操作的耗时预期,以判断消费逻辑中IO操作是否合理; 消息堆积通常是由下游的<strong>服务异常</strong>或<strong>达到了DBMS的流量阈值</strong>,导致消费耗时增加</p></blockquote><h3 id="4-消息并发度"><a href="#4-消息并发度" class="headerlink" title="4.消息并发度"></a>4.消息并发度</h3><p>一般情况下,消费者端的消息并发度由<strong>单节点线程数</strong>和<strong>节点数量</strong>共同决定,值为<code>单节点线程数*节点数量</code>; 不过,通常需要优先调整单节点的线程数,若单机硬件资源达到上限,再通过横向扩展来提高消息并发度</p><blockquote><p>单节点线程数:单个消费者所包含的线程数量</p><p>节点数量:消费者组中消费者数量</p><p>对于普通/延时/事务消息,并发度都是<code>单节点线程数*节点数量</code>; 但对于顺序消息,并发度为<code>Topic的Queue分区数量</code></p></blockquote><h3 id="5-单机线程数计算"><a href="#5-单机线程数计算" class="headerlink" title="5.单机线程数计算"></a>5.单机线程数计算</h3><p>对于一台主机中线程池中线程数的设置需要谨慎对待,不能盲目的增加线程数; 设置太大会导致不必要的线程切换开销; 理想环境下单节点的最优线程数计算模型为: <code>C*(T1+T2)/T1</code></p><ul><li>C: CPU内核数</li><li>T1: CPU内部逻辑计算耗时</li><li>T2: 外部IO操作耗时</li></ul><h3 id="6-如何避免"><a href="#6-如何避免" class="headerlink" title="6.如何避免"></a>6.如何避免</h3><p>梳理消息的消费耗时+设置消息消费并发度</p><h4 id="梳理消息的消费耗时"><a href="#梳理消息的消费耗时" class="headerlink" title="梳理消息的消费耗时"></a>梳理消息的消费耗时</h4><p>通过压测获取消息的消费耗时，并对耗时较高的操作的代码逻辑进行分析。梳理消息的消费耗时需要关注以下信息：</p><ul><li>消息消费逻辑的计算复杂度是否过高，代码是否存在无限循环和递归等缺陷。</li><li>消息消费逻辑中的I/O操作是否是必须的，能否用本地缓存等方案规避。</li><li>消费逻辑中的复杂耗时的操作是否可以做异步化处理。如果可以，是否会造成逻辑错乱。</li></ul><h4 id="设置消费并发度"><a href="#设置消费并发度" class="headerlink" title="设置消费并发度"></a>设置消费并发度</h4><p>对于消息消费并发度的计算，可以通过以下两步实施：</p><ul><li><p>逐步调大单个Consumer节点的线程数，并观测节点的系统指标，得到单个节点最优的消费线程数和消息吞吐量。</p></li><li><p>根据上下游链路的流量<strong>峰值</strong>计算出需要设置的节点数</p></li></ul><blockquote><p>节点数 <em>=</em> 流量峰值 <em>/</em> 单个节点消息吞吐量 </p></blockquote><h2 id="九、消息的清理"><a href="#九、消息的清理" class="headerlink" title="九、消息的清理"></a>九、消息的清理</h2><p>消息被消费过后会被清理掉吗？不会。</p><p>消息是被顺序存储在commitlog文件的，且消息大小不定长，所以消息的清理是不可能以消息为单位进行清理的，而是以commitlog文件为单位进行清理的。否则会急剧下降清理效率，并实现逻辑复杂。</p><p>commitlog文件存在一个过期时间，默认为72小时，即三天。除了用户手动清理外，在以下情况下也会被自动清理，无论文件中的消息是否被消费过：</p><ul><li>文件过期，且到达清理时间点（默认为凌晨4点）后，自动清理过期文件</li><li>文件过期，且磁盘空间占用率已达过期清理警戒线（默认75%）后，无论是否达到清理时间点，都会自动清理过期文件</li><li>磁盘占用率达到清理警戒线（默认85%）后，开始按照设定好的规则清理文件，无论是否过期。默认会从最老的文件开始清理</li><li>磁盘占用率达到系统危险警戒线（默认90%）后，Broker将拒绝消息写入</li></ul><blockquote><p>需要注意以下几点：</p><p><em>1</em>）对于<em>RocketMQ</em>系统来说，删除一个<em>1G</em>大小的文件，是一个压力巨大的<em>IO</em>操作。在删除过程中，系统性能会骤然下降。所以，其默认清理时间点为凌晨<em>4</em>点，访问量最小的时间。也正因如果，我们要保障磁盘空间的空闲率，不要使系统出现在其它时间点删除<em>commitlog</em>文件的情况。</p><p><em>2</em>）官方建议<em>RocketMQ</em>服务的<em>Linux</em>文件系统采用<em>ext4</em>。因为对于文件删除操作，<em>ext4</em>要比<em>ext3</em>性能更好</p></blockquote><h1 id="第4章-rocketMQ应用"><a href="#第4章-rocketMQ应用" class="headerlink" title="第4章 rocketMQ应用"></a>第4章 rocketMQ应用</h1><h2 id="一、普通消息"><a href="#一、普通消息" class="headerlink" title="一、普通消息"></a>一、普通消息</h2><h3 id="1-消息发送分类"><a href="#1-消息发送分类" class="headerlink" title="1.消息发送分类"></a>1.消息发送分类</h3><h4 id="同步发送消息"><a href="#同步发送消息" class="headerlink" title="同步发送消息"></a>同步发送消息</h4><p>Producer在发出一条消息后,在收到MQ返回的ACK后才会发送下一条消息</p><p>该方法可靠性最高,但是效率低</p><h4 id="异步发送消息"><a href="#异步发送消息" class="headerlink" title="异步发送消息"></a>异步发送消息</h4><p>Producer在发出一条消息后,不需要收到MQ返回的ACK后,直接发送下一条消息</p><p>该方法可靠性上课,效率也不错</p><h4 id="单向发送消息"><a href="#单向发送消息" class="headerlink" title="单向发送消息"></a>单向发送消息</h4><p>Producer仅负责发送消息,不等待,不处理MQ的ACK; MQ不返回ACK</p><p>该方法效率最高,但是可靠性差</p><h3 id="2-代码举例"><a href="#2-代码举例" class="headerlink" title="2.代码举例"></a>2.代码举例</h3><p>省去具体代码…</p><h2 id="二、顺序消息"><a href="#二、顺序消息" class="headerlink" title="二、顺序消息"></a>二、顺序消息</h2><h3 id="1-什么是顺序消息"><a href="#1-什么是顺序消息" class="headerlink" title="1.什么是顺序消息"></a>1.什么是顺序消息</h3><p>严格按照消息的发送顺序进行消费的消息</p><p>默认方式下生产者会以轮询的方式把消息发送到不同的Queue队列,这样会导致消息消费顺序和发送顺序不一致; 若仅将消息发送到同一个Queue中,同时在消费时也仅从这个Queue上拉取消息,就能保证消息的顺序性</p><h3 id="2-有序性分类"><a href="#2-有序性分类" class="headerlink" title="2.有序性分类"></a>2.有序性分类</h3><h4 id="全局有序"><a href="#全局有序" class="headerlink" title="全局有序"></a>全局有序</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309302235131.png" alt="image-20230930223533959"></p><p>当发送和消费参与的Queue只有一个时所保证的有序是整个Topic中消息的顺序,称为<strong>全局有序</strong></p><blockquote><p>在创建Topic时指定Queue的数量,有三种指定方式</p><p><em>1</em>）在代码中创建<em>Producer</em>时，可以指定其自动创建的<em>Topic</em>的<em>Queue</em>数量<br><em>2</em>）在<em>RocketMQ</em>可视化控制台中手动创建<em>Topic</em>时指定<em>Queue</em>数量<br><em>3</em>）使用<em>mqadmin</em>命令手动创建<em>Topic</em>时指定<em>Queue</em>数量</p></blockquote><h4 id="分区有序"><a href="#分区有序" class="headerlink" title="分区有序"></a>分区有序</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309302252931.png" alt="image-20230930225257871"></p><p>若有多个Queue参与,其仅可保证在该Queue分区队列上的消息顺序,称为分区有序</p><blockquote><p>如何实现<em>Queue</em>的选择？在定义<em>Producer</em>时我们可以指定消息队列选择器，而这个选择器是我们自己实现了<em>MessageQueueSelector</em>接口定义的。</p><p>在定义选择器的选择算法时，一般需要使用选择<em>key</em>。这个选择<em>key</em>可以是消息<em>key</em>也可以是其它数据。但无论谁做选择<em>key</em>，都不能重复，都是唯一的。一般性的选择算法是，让选择<em>key</em>（或其<em>hash</em>值）与该<em>Topic</em>所包含的<em>Queue</em>的数量取模，其结果即为选择出的<em>Queue</em>的<em>QueueId</em>。</p><p>取模算法存在一个问题：不同选择<em>key</em>与<em>Queue</em>数量取模结果可能会是相同的，即不同选择<em>key</em>的消息可能会出现在相同的<em>Queue</em>，即同一个<em>Consuemr</em>可能会消费到不同选择<em>key</em>的消息。这个问题如何解决？一般性的作法是，从消息中获取到选择<em>key</em>，对其进行判断。若是当前<em>Consumer</em>需要消费的消息，则直接消费，否则，什么也不做。这种做法要求选择<em>key</em>要能够随着消息一起被<em>Consumer</em>获取到。此时使用消息<em>key</em>作为选择<em>key</em>是比较好的做法。</p><p>以上做法会不会出现如下新的问题呢？不属于那个<em>Consumer</em>的消息被拉取走了，那么应该消费该消息的<em>Consumer</em>是否还能再消费该消息呢？同一个<em>Queue</em>中的消息不可能被同一个<em>Group</em>中的不同<em>Consumer</em>同时消费。所以，消费现一个<em>Queue</em>的不同选择<em>key</em>的消息的<em>Consumer</em>一定属于不同的<em>Group</em>。而不同的<em>Group</em>中的<em>Consumer</em>间的消费是相互隔离的，互不影响的。</p></blockquote><h2 id="三、延时消息"><a href="#三、延时消息" class="headerlink" title="三、延时消息"></a>三、延时消息</h2><h3 id="1-什么是延时消息"><a href="#1-什么是延时消息" class="headerlink" title="1.什么是延时消息"></a>1.什么是延时消息</h3><p>当消息写入到Broker后,在指定的时长才可被处理的消息,称为延时消息</p><p>采用RocketMQ的延时消息可以实现<strong>定时任务</strong>的功能，而无需使用定时器。</p><h3 id="2-延时等级"><a href="#2-延时等级" class="headerlink" title="2.延时等级"></a>2.延时等级</h3><p>延时消息的延迟市场<strong>不支持设置任意时长</strong>,是通过特定的延时等级来指定的;延时等级定义在RocketMQ服务端的MessageStoreConfig的messageDelayLevel中 </p><p>如果需要自定义的延时等级，可以通过在broker加载的配置中新增messageDelayLevel的配置(配置文件在RocketMQ安装目录下的conf目录中)</p><h3 id="3-延时消息实现原理"><a href="#3-延时消息实现原理" class="headerlink" title="3.延时消息实现原理"></a>3.延时消息实现原理</h3><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310031231233.png" alt="image-20231003123145129"></p><h4 id="修改消息"><a href="#修改消息" class="headerlink" title="修改消息"></a>修改消息</h4><p>Producer将消息发送到Broker后，Broker会首先将消息写入到commitlog文件，然后需要将其分发到相应的consumequeue。不过，在分发之前，系统会先判断消息中是否带有延时等级。若没有，则直接正常分发；若有则需要经历一个复杂的过程：</p><ul><li><p>修改消息的Topic为SCHEDULE_TOPIC_XXXX</p></li><li><p>根据延时等级，在consumequeue目录中SCHEDULE_TOPIC_XXXX主题下创建出相应的queueId目录与consumequeue文件（如果没有这些目录与文件的话）</p></li></ul><blockquote><p>延迟等级<em>delayLevel</em>与<em>queueId</em>的对应关系为<em>queueId = delayLevel -1</em></p><p>需要注意，在创建<em>queueId</em>目录时，并不是一次性地将所有延迟等级对应的目录全部创建完毕，而是用到哪个延迟等级创建哪个目录</p></blockquote><ul><li>修改消息索引单元内容; </li><li>索引单元中的Message Tag HashCode部分原本存放的是消息的Tag的Hash值。现修改为消息的投递时间。投递时间是指该消息被重新修改为原Topic后再次被写入到commitlog中的时间。投递时间 = 消息存储时间 + 延时等级时间。消息存储时间指的是消息被发送到Broker时的时间戳</li><li>将消息索引写入到SCHEDULE_TOPIC_XXXX主题下相应的consumequeue中</li></ul><blockquote><p><em>SCHEDULE_TOPIC_XXXX</em>目录中各个延时等级<em>Queue</em>中的消息是如何排序的？</p><p>是按照消息投递时间排序的。一个<em>Broker</em>中同一等级的所有延时消息会被写入到<em>consumequeue</em>目录中<em>SCHEDULE_TOPIC_XXXX</em>目录下相同<em>Queue</em>中。即一个<em>Queue</em>中消息投递时间的延迟等级时间是相同的。那么投递时间就取决于于消息存储时间了。即按照消息被发送到<em>Broker</em>的时间进行排序的。</p></blockquote><h4 id="投递延时消息"><a href="#投递延时消息" class="headerlink" title="投递延时消息"></a>投递延时消息</h4><p>Broker内部有⼀个延迟消息服务类ScheuleMessageService，其会消费SCHEDULE_TOPIC_XXXX中的消息，即按照每条消息的投递时间，将延时消息投递到⽬标Topic中。不过，在投递之前会从commitlog中将原来写入的消息再次读出，并将其原来的延时等级设置为0，即原消息变为了一条不延迟的普通消息。然后再次将消息投递到目标Topic中</p><blockquote><p><em>ScheuleMessageService</em>在<em>Broker</em>启动时，会创建并启动一个定时器<em>Timer</em>，用于执行相应的定时任务。系统会根据延时等级的个数，定义相应数量的<em>TimerTask</em>，每个<em>TimerTask</em>负责一个延迟等级消息的消费与投递。每个<em>TimerTask</em>都会检测相应<em>Queue</em>队列的第一条消息是否到期。若第一条消息未到期，则后面的所有消息更不会到期（消息是按照投递时间排序的）；若第一条消息到期了，则将该消息投递到目标<em>Topic</em>，即消费该消息。</p></blockquote><h4 id="将消息重新写入commitlog"><a href="#将消息重新写入commitlog" class="headerlink" title="将消息重新写入commitlog"></a>将消息重新写入commitlog</h4><p>延迟消息服务类ScheuleMessageService将延迟消息再次发送给了commitlog，并再次形成新的消息索引条目，分发到相应Queue。</p><blockquote><p>这其实就是一次普通消息发送。只不过这次的消息<em>Producer</em>是延迟消息服务类<em>ScheuleMessageService</em>。</p></blockquote><h2 id="四、事务消息"><a href="#四、事务消息" class="headerlink" title="四、事务消息"></a>四、事务消息</h2><h3 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h3><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>通俗来讲,分布式事务就是一次操作由若干分支操作组成,这些操作分属不同应用和不同服务器; 分布式事务需要保证这些分支的一致性,即要么<u>全部成功,要么全部失败</u>; 分布式事务与普通事务一样,是为了保证结果的一致性</p><h4 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h4><p>RocketMQ提供了类似X/Open XA的分布式事务功能, 通过事务消息能达到分布式事务的最终一致; XA是一种分布式事务解决方案, 一种分布式事务处理模式</p><h4 id="半事务消息"><a href="#半事务消息" class="headerlink" title="半事务消息"></a>半事务消息</h4><p>暂不能投递的消息,发送方已经成功地将消息发送到了Broker, 但是Broker未收到最终确认指令, 此时该消息被标记成”暂不能投递”状态,其不会被消费者看到</p><h4 id="本地事务状态"><a href="#本地事务状态" class="headerlink" title="本地事务状态"></a>本地事务状态</h4><p>Producer<strong>回调操作</strong>执行的结果为本地事务状态,其会发送给TC, 而TC会再发送给TM; TM会根据TC发送来的本地事务状态来决定全局事务确认指令</p><h4 id="消息回查"><a href="#消息回查" class="headerlink" title="消息回查"></a>消息回查</h4><p>即重新查询本地事务的执行状态</p><blockquote><p>注意，消息回查不是重新执行回调操作。以银行转账为例, 回调操作是进行预扣款操作，而消息回查则是查看预扣款操作执行的结果。</p><p>引发消息回查的原因最常见的有两个：</p><p><em>1)</em>回调操作返回<em>UNKNWON</em><br><em>2)TC</em>没有接收到<em>TM</em>的最终全局事务确认指令</p></blockquote><h4 id="RocketMQ中的消息回查设置"><a href="#RocketMQ中的消息回查设置" class="headerlink" title="RocketMQ中的消息回查设置"></a>RocketMQ中的消息回查设置</h4><p>关于消息回查,有三个主要的属性设置,其都在broker加载的配置文件中设置</p><ul><li><p>transactionTimeout=20，指定TM在20秒内应将最终确认状态发送给TC，否则引发消息回查。默认为60秒</p></li><li><p>transactionCheckMax=5，指定最多回查5次，超过后将丢弃消息并记录错误日志。默认15次。</p></li><li><p>transactionCheckInterval=10，指定设置的多次消息回查的时间间隔为10秒。默认为60秒。</p></li></ul><h3 id="2-XA模式三剑客"><a href="#2-XA模式三剑客" class="headerlink" title="2.XA模式三剑客"></a>2.XA模式三剑客</h3><h4 id="XA协议"><a href="#XA协议" class="headerlink" title="XA协议"></a>XA协议</h4><p>XA是一种分布式事务解决方案,它有三个重要组件:TC、TM、RM</p><h4 id="TC"><a href="#TC" class="headerlink" title="TC"></a>TC</h4><p>Transaction Coordinator 事务协调者; 维护全局和分支事务的状态,驱动全局事务提交或回滚</p><blockquote><p>在RocketMQ中Broker充当TC的角色</p></blockquote><h4 id="TM"><a href="#TM" class="headerlink" title="TM"></a>TM</h4><p>Transaction Manager 事务管理器; 定义全局事务的范围: 开始全局事务、提交或回滚全局事务; 它实际上是全局事务的发起者</p><blockquote><p>RocketMQ中事务消息的Producer充当TM的角色</p></blockquote><h4 id="RM"><a href="#RM" class="headerlink" title="RM"></a>RM</h4><p>Resource Manager, 资源管理器; 管理分支事务处理的资源, 与TC交谈以注册分支事务和报告分支事务的状态,并驱动分支事务提交或回滚</p><blockquote><p>RocketMQ中事务消息的Producer和Broker都是RM</p></blockquote><h3 id="3-XA模式架构"><a href="#3-XA模式架构" class="headerlink" title="3.XA模式架构"></a>3.XA模式架构</h3><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310032005177.png" alt="image-20231003200523117"></p><p>XA模式是一个典型的2PC,其执行原理如下</p><ol><li>TM向TC发起指令，开启一个全局事务。</li><li>根据业务要求，各个RM会逐个向TC注册分支事务，然后TC会逐个向RM发出预执行指令。</li><li>各个RM在接收到指令后会在进行本地事务预执行。</li><li>RM将预执行结果Report给TC。当然，这个结果可能是成功，也可能是失败。</li><li>TC在接收到各个RM的Report后会将汇总结果上报给TM，根据汇总结果TM会向TC发出确认指令。<ul><li>若所有结果都是成功响应，则向TC发送Global Commit指令。</li><li>只要有结果是失败响应，则向TC发送Global Rollback指令。</li></ul></li><li>TC在接收到指令后再次向RM发送确认指令。</li></ol><blockquote><p>事务消息方案并不是一个典型的<em>XA</em>模式。因为<em>XA</em>模式中的分支事务是异步的，而事务消息方案</p><p>中的消息预提交与预扣款操作间是同步的。</p></blockquote><h3 id="4-注意"><a href="#4-注意" class="headerlink" title="4.注意"></a>4.注意</h3><ul><li>事务消息不支持延迟消息</li><li>对于事务消息要做好幂等性检查,因为事务消息可能被多次消费(可能在回滚后被再次消费)</li></ul><h2 id="五、批量消息"><a href="#五、批量消息" class="headerlink" title="五、批量消息"></a>五、批量消息</h2><h3 id="1-批量发送消息"><a href="#1-批量发送消息" class="headerlink" title="1.批量发送消息"></a>1.批量发送消息</h3><h4 id="发送限制"><a href="#发送限制" class="headerlink" title="发送限制"></a>发送限制</h4><p>生产者在发送消息时可以一次性发送多条消息,这可以大大提升Producer的效率,不过批量发送的消息需要注意以下几点</p><ul><li>Topic必须相同</li><li>刷盘策略必须相同</li><li>不能是延时消息和事务消息</li></ul><h4 id="批量发送大小"><a href="#批量发送大小" class="headerlink" title="批量发送大小"></a>批量发送大小</h4><p>默认情况下,总大小不能超过4MB</p><p>若要一次批量发送超过4MB的消息,有两种方法</p><ul><li><p>①将批量消息进行拆分,拆成若干大小小于等于4m的消息集合分多次批量发送</p></li><li><p>②在Producer端和Broker端修改属性</p><blockquote><p> Producer端需要在发送之前设置Producer的maxMessageSize属性</p><p> Broker端需要修改其加载的配置文件中的maxMessageSize属性</p></blockquote></li></ul><h4 id="生产者发送消息的大小"><a href="#生产者发送消息的大小" class="headerlink" title="生产者发送消息的大小"></a>生产者发送消息的大小</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310032021734.png" alt="image-20231003202115698"></p><p>生产者通过send()方法发送的Message，并不是直接将Message序列化后发送到网络上的，而是通过这个Message生成了一个字符串发送出去的。这个字符串由四部分构成：Topic、消息Body、消息日志（占20字节），及用于描述消息的一堆属性key-value。这些属性中包含例如生产者地址、生产时间、要发送的QueueId等。最终写入到Broker中消息单元中的数据都是来自于这些属性。</p><h3 id="2-批量消费消息"><a href="#2-批量消费消息" class="headerlink" title="2.批量消费消息"></a>2.批量消费消息</h3><h4 id="修改批量属性"><a href="#修改批量属性" class="headerlink" title="修改批量属性"></a>修改批量属性</h4><p>Consumer的MessageListenerConcurrently监听接口的consumeMessage()方法的第一个参数为消息列表，但默认情况下每次只能消费一条消息。</p><p>若要使其一次可以消费多条消息，则可以通过修改Consumer的consumeMessageBatchMaxSize属性来指定。不过，该值不能超过32。因为默认情况下消费者每次可以拉取的消息最多是32条。</p><p>若要修改一次拉取的最大值，则可通过修改Consumer的pullBatchSize属性来指定</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>Consumer的pullBatchSize属性与consumeMessageBatchMaxSize属性如何设置合适</p><ul><li><p>pullBatchSize值设置的越大，Consumer每拉取一次需要的时间就会越长，且在网络上传输出现问题的可能性就越高。若在拉取过程中若出现了问题，那么本批次所有消息都需要全部重新拉取。</p></li><li><p>consumeMessageBatchMaxSize值设置的越大，Consumer的消息并发消费能力越低，且这批被消费的消息具有相同的消费结果。因为consumeMessageBatchMaxSize指定的一批消息只会使用一个线程进行处理，且在处理过程中只要有一个消息处理异常，则这批消息需要全部重新再次消费处理</p></li></ul><h2 id="六、消息过滤"><a href="#六、消息过滤" class="headerlink" title="六、消息过滤"></a>六、消息过滤</h2><p>消费者在可以订阅Topic的同时,对Topic中的消息进行条件过滤</p><h3 id="1-Tag过滤"><a href="#1-Tag过滤" class="headerlink" title="1.Tag过滤"></a>1.Tag过滤</h3><p>通过consumer的subscribe()方法制定要订阅消息的Tag; 若订阅多个Tag的消息, Tag用”||”连接</p><h4 id="2-SQL过滤"><a href="#2-SQL过滤" class="headerlink" title="2.SQL过滤"></a>2.SQL过滤</h4><p>SQL过滤是一种通过特定表达式对事先埋入到消息中的<strong>用户属性</strong>进行筛选过滤的方式; 通过SQL过滤,可以实现对消息的较复杂的过滤; 不过,只有通过<strong>Push模式</strong>的消费者才能使用SQL过滤</p><p>SQL过滤表达式支持多种常量类型与运算符</p><p>支持的常量类型 :</p><ul><li>数值</li><li>字符: 必须用单引号包裹</li><li>布尔类型</li><li>NULL</li></ul><p>支持的运算符 :</p><ul><li>数值比较：&gt;，&gt;=，&lt;，&lt;=，BETWEEN，=</li><li>字符比较：=，&lt;&gt;，IN</li><li>逻辑运算 ：AND，OR，NOT</li><li>NULL判断：IS NULL 或者 IS NOT NULL</li></ul><p>默认情况下Broker没有开启消息的SQL过滤功能，需要在Broker加载的配置文件中添加如下属性，以开启该功能：<code>enablePropertyFilter = true</code></p><p>在启动Broker时需要指定这个修改过的配置文件。例如对于单机Broker的启动，其修改的配置文件是conf/broker.conf，启动时使用如下命令：<code>sh bin/mqbroker -n localhost:9876 -c conf/broker.conf &amp;</code></p><h2 id="七、消息发送重试机制"><a href="#七、消息发送重试机制" class="headerlink" title="七、消息发送重试机制"></a>七、消息发送重试机制</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>Producer对发送失败的消息进行重新发送的机制,称为消息发送重试机制,又称消息重投机制</p><p>需要注意以下几点</p><ul><li>生产者若采用<strong>同步/异步</strong>发送方式, 发送失败后会<strong>重试</strong>, 但oneway消息发送方式在消息发送失败后是没有重试机制的</li><li><strong>只有</strong>普通消息发送具有重试机制</li><li>消息重投只保证消息尽可能发送成功,不丢失,但不保证消息不重复;</li><li>在RocketMQ中无法避免消息重复,但要避免消息的重复消费</li><li>消息重复在一般情况下不会发生,但在消息量大、网络抖动时,消息重复可能会十分频繁</li><li>Producer主动重发、consumer负载变化时也可能会导致消息重复(Rebalance不会导致消息重复,但可能会产生重复消费)</li><li>避免消息重复消费的方法: 为消息添加唯一标示(key), 让消费者对消息进行消费判断来避免重复消费</li><li>消息发送重试有三种策略: 同步发送失败策略、异步发送失败策略、消息刷盘失败策略</li></ul><h3 id="2-同步发送失败策略"><a href="#2-同步发送失败策略" class="headerlink" title="2.同步发送失败策略"></a>2.同步发送失败策略</h3><p>对于普通消息，消息发送默认采用轮询策略来选择所发送到的队列。如果发送失败，默认重试2次。但在重试时是不会选择上次发送失败的Broker，而是选择其它Broker。当然，若只有一个Broker其也只能发送到该Broker，但其会尽量发送到该Broker上的其它Queue。</p><p>同时，Broker还具有<strong>失败隔离</strong>功能，使Producer尽量选择未发生过发送失败的Broker作为目标Broker。其可以保证其它消息尽量不发送到问题Broker，为了提升消息发送效率，降低消息发送耗时。</p><p>如果超过重试次数，则抛出异常，由Producer去<strong>保证消息不丢</strong>。当然当生产者出现RemotingException、MQClientException和MQBrokerException时，Producer会自动重投消息。</p><h3 id="3-异步发送失败策略"><a href="#3-异步发送失败策略" class="headerlink" title="3.异步发送失败策略"></a>3.异步发送失败策略</h3><p>异步发送失败时,重试时不会选择其他Broker,而是仅在一个Broker上进行重试,所以<strong>无法保证消息不丢</strong></p><h3 id="4-消息刷盘失败策略"><a href="#4-消息刷盘失败策略" class="headerlink" title="4.消息刷盘失败策略"></a>4.消息刷盘失败策略</h3><p>消息刷盘超市或slave不可用(slave在数据同步时向master返回状态不是SEND_OK)时,默认是不会将消息尝试发送到其他Broker的; 不过,对于重要消息可以通过在Broker的配置文件设置retryAnotherBrokerWhenNotStoreOK为true来开启</p><h2 id="八、消息消费重试机制"><a href="#八、消息消费重试机制" class="headerlink" title="八、消息消费重试机制"></a>八、消息消费重试机制</h2><h3 id="1-顺序消息的消费重试"><a href="#1-顺序消息的消费重试" class="headerlink" title="1.顺序消息的消费重试"></a>1.顺序消息的消费重试</h3><p>对于顺序消息,当Consumer消费消息失败后,为保证消息的顺序性,会不断地进行消息重试,直到成功消费; 消费重试默认时间间隔为1000ms; 重试期间应用会出现消息消费被阻塞的情况</p><blockquote><p>因为顺序消费的重试是不间断的,为避免消费被永久阻塞, 要保证应用能及时监控并处理消费失败的情况</p><p>顺序消息没有发送失败重试机制, 但有消费失败重试机制</p></blockquote><h3 id="2-无序消息的消费重试"><a href="#2-无序消息的消费重试" class="headerlink" title="2.无序消息的消费重试"></a>2.无序消息的消费重试</h3><p>对于无序消息(普通消息、延时消息、事务消息), 当Consumer消费消息失败时，可以通过设置返回状态达到消息重试的效果。需要注意的是，无序消息的重试只对集群消费方式生效，广播消费方式不提供失败重试特性。即对于广播消费，消费失败后，失败消息不再重试，继续消费后续消息。</p><h3 id="3-消费重试次数与间隔"><a href="#3-消费重试次数与间隔" class="headerlink" title="3.消费重试次数与间隔"></a>3.消费重试次数与间隔</h3><p>对于无序消息集群消费下的重试消费，每条消息默认最多重试16次，但每次重试的间隔时间是不同的，会逐渐变长。每次重试的间隔时间如下表:</p><div class="table-container"><table><thead><tr><th>重试次数</th><th>重试的时间间隔</th><th>重试次数</th><th>重试的时间间隔</th></tr></thead><tbody><tr><td>1</td><td>10s</td><td>9</td><td>7m</td></tr><tr><td>2</td><td>30s</td><td>10</td><td>8m</td></tr><tr><td>3</td><td>1m</td><td>11</td><td>9m</td></tr><tr><td>4</td><td>2m</td><td>12</td><td>10m</td></tr><tr><td>5</td><td>3m</td><td>13</td><td>20m</td></tr><tr><td>6</td><td>4m</td><td>14</td><td>30m</td></tr><tr><td>7</td><td>5m</td><td>15</td><td>1h</td></tr><tr><td>8</td><td>6m</td><td>16</td><td>2h</td></tr></tbody></table></div><blockquote><p>一条消息在消费失败次数达到上限后,会将该消息投递到<strong>死信队列</strong></p></blockquote><h3 id="3-重试队列"><a href="#3-重试队列" class="headerlink" title="3.重试队列"></a>3.重试队列</h3><p>对于需要重试消费的消息，并不是Consumer在等待了指定时长后再次去拉取原来的消息进行消费，而是将这些需要重试消费的消息放入到了一个特殊Topic的队列中，而后进行再次消费的。这个特殊的队列就是重试队列。</p><p>当出现需要进行重试消费的消息时，Broker会为每个消费组都设置一个Topic名称为%RETRY%consumerGroup@consumerGroup 的重试队列。</p><p>Broker对于重试消息的处理是通过<strong>延时消息</strong>实现的。先将消息保存到SCHEDULE_TOPIC_XXXX延迟队列中，延迟时间到后，会将消息投递到%RETRY%consumerGroup@consumerGroup重试队列中。</p><blockquote><p><em>1</em>）这个重试队列是针对消息组的，而不是针对每个<em>Topic</em>设置的（一个<em>Topic</em>的消息可以让多个消费者组进行消费，所以会为这些消费者组各创建一个重试队列）<br><em>2</em>）只有当出现需要进行重试消费的消息时，才会为该消费者组创建重试队列</p></blockquote><h2 id="九、死信队列"><a href="#九、死信队列" class="headerlink" title="九、死信队列"></a>九、死信队列</h2><h3 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1.概念"></a>1.概念</h3><p>达到最大重试次数后，消费依然失败的消息会被发送到该消费者对应的特殊队列中, 即死信队列, 其中的消息称为死信消息</p><h3 id="2-特征"><a href="#2-特征" class="headerlink" title="2.特征"></a>2.特征</h3><ul><li>死信队列中的消息不会再被消费者正常消费，即DLQ对于消费者是<strong>不可见</strong>的</li><li>死信存储有效期与正常消息相同，均为 3 天（commitlog文件的过期时间），3 天后会被自动删除</li><li>死信队列就是一个特殊的Topic，名称为%DLQ%consumerGroup@consumerGroup ，即每个消费者组都有一个死信队列</li><li>如果⼀个消费者组未产生死信消息，则不会为其创建相应的死信队列</li></ul><h3 id="3-死信消息的处理"><a href="#3-死信消息的处理" class="headerlink" title="3.死信消息的处理"></a>3.死信消息的处理</h3><p>实际上，当⼀条消息进入死信队列，就意味着系统中某些地方出现了问题，从而导致消费者无法正常消费该消息，比如代码中原本就存在Bug。因此，对于死信消息，通常需要开发人员进行特殊处理。最关键的步骤是要排查可疑因素，解决代码中可能存在的Bug，然后再将原来的死信消息再次进行投递消费。</p>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ 四、rocketMQ应用笔记</title>
      <link href="/2023/09/29/2023-10-4-rocketMQ-%E4%B8%89%E3%80%81%E5%BA%94%E7%94%A8/"/>
      <url>/2023/09/29/2023-10-4-rocketMQ-%E4%B8%89%E3%80%81%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="第4章-rocketMQ应用"><a href="#第4章-rocketMQ应用" class="headerlink" title="第4章 rocketMQ应用"></a>第4章 rocketMQ应用</h1><h2 id="一、普通消息"><a href="#一、普通消息" class="headerlink" title="一、普通消息"></a>一、普通消息</h2><h3 id="1-消息发送分类"><a href="#1-消息发送分类" class="headerlink" title="1.消息发送分类"></a>1.消息发送分类</h3><h4 id="同步发送消息"><a href="#同步发送消息" class="headerlink" title="同步发送消息"></a>同步发送消息</h4><p>Producer在发出一条消息后,在收到MQ返回的ACK后才会发送下一条消息</p><p>该方法可靠性最高,但是效率低</p><h4 id="异步发送消息"><a href="#异步发送消息" class="headerlink" title="异步发送消息"></a>异步发送消息</h4><p>Producer在发出一条消息后,不需要收到MQ返回的ACK后,直接发送下一条消息</p><p>该方法可靠性上课,效率也不错</p><h4 id="单向发送消息"><a href="#单向发送消息" class="headerlink" title="单向发送消息"></a>单向发送消息</h4><p>Producer仅负责发送消息,不等待,不处理MQ的ACK; MQ不返回ACK</p><p>该方法效率最高,但是可靠性差</p><h3 id="2-代码举例"><a href="#2-代码举例" class="headerlink" title="2.代码举例"></a>2.代码举例</h3><p>省去具体代码…</p><h2 id="二、顺序消息"><a href="#二、顺序消息" class="headerlink" title="二、顺序消息"></a>二、顺序消息</h2><h3 id="1-什么是顺序消息"><a href="#1-什么是顺序消息" class="headerlink" title="1.什么是顺序消息"></a>1.什么是顺序消息</h3><p>严格按照消息的发送顺序进行消费的消息</p><p>默认方式下生产者会以轮询的方式把消息发送到不同的Queue队列,这样会导致消息消费顺序和发送顺序不一致; 若仅将消息发送到同一个Queue中,同时在消费时也仅从这个Queue上拉取消息,就能保证消息的顺序性</p><h3 id="2-有序性分类"><a href="#2-有序性分类" class="headerlink" title="2.有序性分类"></a>2.有序性分类</h3><h4 id="全局有序"><a href="#全局有序" class="headerlink" title="全局有序"></a>全局有序</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309302235131.png" alt="image-20230930223533959"></p><p>当发送和消费参与的Queue只有一个时所保证的有序是整个Topic中消息的顺序,称为<strong>全局有序</strong></p><blockquote><p>在创建Topic时指定Queue的数量,有三种指定方式</p><p><em>1</em>）在代码中创建<em>Producer</em>时，可以指定其自动创建的<em>Topic</em>的<em>Queue</em>数量<br><em>2</em>）在<em>RocketMQ</em>可视化控制台中手动创建<em>Topic</em>时指定<em>Queue</em>数量<br><em>3</em>）使用<em>mqadmin</em>命令手动创建<em>Topic</em>时指定<em>Queue</em>数量</p></blockquote><h4 id="分区有序"><a href="#分区有序" class="headerlink" title="分区有序"></a>分区有序</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309302252931.png" alt="image-20230930225257871"></p><p>若有多个Queue参与,其仅可保证在该Queue分区队列上的消息顺序,称为分区有序</p><blockquote><p>如何实现<em>Queue</em>的选择？在定义<em>Producer</em>时我们可以指定消息队列选择器，而这个选择器是我们自己实现了<em>MessageQueueSelector</em>接口定义的。</p><p>在定义选择器的选择算法时，一般需要使用选择<em>key</em>。这个选择<em>key</em>可以是消息<em>key</em>也可以是其它数据。但无论谁做选择<em>key</em>，都不能重复，都是唯一的。一般性的选择算法是，让选择<em>key</em>（或其<em>hash</em>值）与该<em>Topic</em>所包含的<em>Queue</em>的数量取模，其结果即为选择出的<em>Queue</em>的<em>QueueId</em>。</p><p>取模算法存在一个问题：不同选择<em>key</em>与<em>Queue</em>数量取模结果可能会是相同的，即不同选择<em>key</em>的消息可能会出现在相同的<em>Queue</em>，即同一个<em>Consuemr</em>可能会消费到不同选择<em>key</em>的消息。这个问题如何解决？一般性的作法是，从消息中获取到选择<em>key</em>，对其进行判断。若是当前<em>Consumer</em>需要消费的消息，则直接消费，否则，什么也不做。这种做法要求选择<em>key</em>要能够随着消息一起被<em>Consumer</em>获取到。此时使用消息<em>key</em>作为选择<em>key</em>是比较好的做法。</p><p>以上做法会不会出现如下新的问题呢？不属于那个<em>Consumer</em>的消息被拉取走了，那么应该消费该消息的<em>Consumer</em>是否还能再消费该消息呢？同一个<em>Queue</em>中的消息不可能被同一个<em>Group</em>中的不同<em>Consumer</em>同时消费。所以，消费现一个<em>Queue</em>的不同选择<em>key</em>的消息的<em>Consumer</em>一定属于不同的<em>Group</em>。而不同的<em>Group</em>中的<em>Consumer</em>间的消费是相互隔离的，互不影响的。</p></blockquote><h2 id="三、延时消息"><a href="#三、延时消息" class="headerlink" title="三、延时消息"></a>三、延时消息</h2><h3 id="1-什么是延时消息"><a href="#1-什么是延时消息" class="headerlink" title="1.什么是延时消息"></a>1.什么是延时消息</h3><p>当消息写入到Broker后,在指定的时长才可被处理的消息,称为延时消息</p><p>采用RocketMQ的延时消息可以实现<strong>定时任务</strong>的功能，而无需使用定时器。</p><h3 id="2-延时等级"><a href="#2-延时等级" class="headerlink" title="2.延时等级"></a>2.延时等级</h3><p>延时消息的延迟市场<strong>不支持设置任意时长</strong>,是通过特定的延时等级来指定的;延时等级定义在RocketMQ服务端的MessageStoreConfig的messageDelayLevel中 </p><p>如果需要自定义的延时等级，可以通过在broker加载的配置中新增messageDelayLevel的配置(配置文件在RocketMQ安装目录下的conf目录中)</p><h3 id="3-延时消息实现原理"><a href="#3-延时消息实现原理" class="headerlink" title="3.延时消息实现原理"></a>3.延时消息实现原理</h3><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310031231233.png" alt="image-20231003123145129"></p><h4 id="修改消息"><a href="#修改消息" class="headerlink" title="修改消息"></a>修改消息</h4><p>Producer将消息发送到Broker后，Broker会首先将消息写入到commitlog文件，然后需要将其分发到相应的consumequeue。不过，在分发之前，系统会先判断消息中是否带有延时等级。若没有，则直接正常分发；若有则需要经历一个复杂的过程：</p><ul><li><p>修改消息的Topic为SCHEDULE_TOPIC_XXXX</p></li><li><p>根据延时等级，在consumequeue目录中SCHEDULE_TOPIC_XXXX主题下创建出相应的queueId目录与consumequeue文件（如果没有这些目录与文件的话）</p></li></ul><blockquote><p>延迟等级<em>delayLevel</em>与<em>queueId</em>的对应关系为<em>queueId = delayLevel -1</em></p><p>需要注意，在创建<em>queueId</em>目录时，并不是一次性地将所有延迟等级对应的目录全部创建完毕，而是用到哪个延迟等级创建哪个目录</p></blockquote><ul><li>修改消息索引单元内容; </li><li>索引单元中的Message Tag HashCode部分原本存放的是消息的Tag的Hash值。现修改为消息的投递时间。投递时间是指该消息被重新修改为原Topic后再次被写入到commitlog中的时间。投递时间 = 消息存储时间 + 延时等级时间。消息存储时间指的是消息被发送到Broker时的时间戳</li><li>将消息索引写入到SCHEDULE_TOPIC_XXXX主题下相应的consumequeue中</li></ul><blockquote><p><em>SCHEDULE_TOPIC_XXXX</em>目录中各个延时等级<em>Queue</em>中的消息是如何排序的？</p><p>是按照消息投递时间排序的。一个<em>Broker</em>中同一等级的所有延时消息会被写入到<em>consumequeue</em>目录中<em>SCHEDULE_TOPIC_XXXX</em>目录下相同<em>Queue</em>中。即一个<em>Queue</em>中消息投递时间的延迟等级时间是相同的。那么投递时间就取决于于消息存储时间了。即按照消息被发送到<em>Broker</em>的时间进行排序的。</p></blockquote><h4 id="投递延时消息"><a href="#投递延时消息" class="headerlink" title="投递延时消息"></a>投递延时消息</h4><p>Broker内部有⼀个延迟消息服务类ScheuleMessageService，其会消费SCHEDULE_TOPIC_XXXX中的消息，即按照每条消息的投递时间，将延时消息投递到⽬标Topic中。不过，在投递之前会从commitlog中将原来写入的消息再次读出，并将其原来的延时等级设置为0，即原消息变为了一条不延迟的普通消息。然后再次将消息投递到目标Topic中</p><blockquote><p><em>ScheuleMessageService</em>在<em>Broker</em>启动时，会创建并启动一个定时器<em>Timer</em>，用于执行相应的定时任务。系统会根据延时等级的个数，定义相应数量的<em>TimerTask</em>，每个<em>TimerTask</em>负责一个延迟等级消息的消费与投递。每个<em>TimerTask</em>都会检测相应<em>Queue</em>队列的第一条消息是否到期。若第一条消息未到期，则后面的所有消息更不会到期（消息是按照投递时间排序的）；若第一条消息到期了，则将该消息投递到目标<em>Topic</em>，即消费该消息。</p></blockquote><h4 id="将消息重新写入commitlog"><a href="#将消息重新写入commitlog" class="headerlink" title="将消息重新写入commitlog"></a>将消息重新写入commitlog</h4><p>延迟消息服务类ScheuleMessageService将延迟消息再次发送给了commitlog，并再次形成新的消息索引条目，分发到相应Queue。</p><blockquote><p>这其实就是一次普通消息发送。只不过这次的消息<em>Producer</em>是延迟消息服务类<em>ScheuleMessageService</em>。</p></blockquote><h2 id="四、事务消息"><a href="#四、事务消息" class="headerlink" title="四、事务消息"></a>四、事务消息</h2><h3 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h3><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>通俗来讲,分布式事务就是一次操作由若干分支操作组成,这些操作分属不同应用和不同服务器; 分布式事务需要保证这些分支的一致性,即要么<u>全部成功,要么全部失败</u>; 分布式事务与普通事务一样,是为了保证结果的一致性</p><h4 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h4><p>RocketMQ提供了类似X/Open XA的分布式事务功能, 通过事务消息能达到分布式事务的最终一致; XA是一种分布式事务解决方案, 一种分布式事务处理模式</p><h4 id="半事务消息"><a href="#半事务消息" class="headerlink" title="半事务消息"></a>半事务消息</h4><p>暂不能投递的消息,发送方已经成功地将消息发送到了Broker, 但是Broker未收到最终确认指令, 此时该消息被标记成”暂不能投递”状态,其不会被消费者看到</p><h4 id="本地事务状态"><a href="#本地事务状态" class="headerlink" title="本地事务状态"></a>本地事务状态</h4><p>Producer<strong>回调操作</strong>执行的结果为本地事务状态,其会发送给TC, 而TC会再发送给TM; TM会根据TC发送来的本地事务状态来决定全局事务确认指令</p><h4 id="消息回查"><a href="#消息回查" class="headerlink" title="消息回查"></a>消息回查</h4><p>即重新查询本地事务的执行状态</p><blockquote><p>注意，消息回查不是重新执行回调操作。以银行转账为例, 回调操作是进行预扣款操作，而消息回查则是查看预扣款操作执行的结果。</p><p>引发消息回查的原因最常见的有两个：</p><p><em>1)</em>回调操作返回<em>UNKNWON</em><br><em>2)TC</em>没有接收到<em>TM</em>的最终全局事务确认指令</p></blockquote><h4 id="RocketMQ中的消息回查设置"><a href="#RocketMQ中的消息回查设置" class="headerlink" title="RocketMQ中的消息回查设置"></a>RocketMQ中的消息回查设置</h4><p>关于消息回查,有三个主要的属性设置,其都在broker加载的配置文件中设置</p><ul><li><p>transactionTimeout=20，指定TM在20秒内应将最终确认状态发送给TC，否则引发消息回查。默认为60秒</p></li><li><p>transactionCheckMax=5，指定最多回查5次，超过后将丢弃消息并记录错误日志。默认15次。</p></li><li><p>transactionCheckInterval=10，指定设置的多次消息回查的时间间隔为10秒。默认为60秒。</p></li></ul><h3 id="2-XA模式三剑客"><a href="#2-XA模式三剑客" class="headerlink" title="2.XA模式三剑客"></a>2.XA模式三剑客</h3><h4 id="XA协议"><a href="#XA协议" class="headerlink" title="XA协议"></a>XA协议</h4><p>XA是一种分布式事务解决方案,它有三个重要组件:TC、TM、RM</p><h4 id="TC"><a href="#TC" class="headerlink" title="TC"></a>TC</h4><p>Transaction Coordinator 事务协调者; 维护全局和分支事务的状态,驱动全局事务提交或回滚</p><blockquote><p>在RocketMQ中Broker充当TC的角色</p></blockquote><h4 id="TM"><a href="#TM" class="headerlink" title="TM"></a>TM</h4><p>Transaction Manager 事务管理器; 定义全局事务的范围: 开始全局事务、提交或回滚全局事务; 它实际上是全局事务的发起者</p><blockquote><p>RocketMQ中事务消息的Producer充当TM的角色</p></blockquote><h4 id="RM"><a href="#RM" class="headerlink" title="RM"></a>RM</h4><p>Resource Manager, 资源管理器; 管理分支事务处理的资源, 与TC交谈以注册分支事务和报告分支事务的状态,并驱动分支事务提交或回滚</p><blockquote><p>RocketMQ中事务消息的Producer和Broker都是RM</p></blockquote><h3 id="3-XA模式架构"><a href="#3-XA模式架构" class="headerlink" title="3.XA模式架构"></a>3.XA模式架构</h3><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310032005177.png" alt="image-20231003200523117"></p><p>XA模式是一个典型的2PC,其执行原理如下</p><ol><li>TM向TC发起指令，开启一个全局事务。</li><li>根据业务要求，各个RM会逐个向TC注册分支事务，然后TC会逐个向RM发出预执行指令。</li><li>各个RM在接收到指令后会在进行本地事务预执行。</li><li>RM将预执行结果Report给TC。当然，这个结果可能是成功，也可能是失败。</li><li>TC在接收到各个RM的Report后会将汇总结果上报给TM，根据汇总结果TM会向TC发出确认指令。<ul><li>若所有结果都是成功响应，则向TC发送Global Commit指令。</li><li>只要有结果是失败响应，则向TC发送Global Rollback指令。</li></ul></li><li>TC在接收到指令后再次向RM发送确认指令。</li></ol><blockquote><p>事务消息方案并不是一个典型的<em>XA</em>模式。因为<em>XA</em>模式中的分支事务是异步的，而事务消息方案</p><p>中的消息预提交与预扣款操作间是同步的。</p></blockquote><h3 id="4-注意"><a href="#4-注意" class="headerlink" title="4.注意"></a>4.注意</h3><ul><li>事务消息不支持延迟消息</li><li>对于事务消息要做好幂等性检查,因为事务消息可能被多次消费(可能在回滚后被再次消费)</li></ul><h2 id="五、批量消息"><a href="#五、批量消息" class="headerlink" title="五、批量消息"></a>五、批量消息</h2><h3 id="1-批量发送消息"><a href="#1-批量发送消息" class="headerlink" title="1.批量发送消息"></a>1.批量发送消息</h3><h4 id="发送限制"><a href="#发送限制" class="headerlink" title="发送限制"></a>发送限制</h4><p>生产者在发送消息时可以一次性发送多条消息,这可以大大提升Producer的效率,不过批量发送的消息需要注意以下几点</p><ul><li>Topic必须相同</li><li>刷盘策略必须相同</li><li>不能是延时消息和事务消息</li></ul><h4 id="批量发送大小"><a href="#批量发送大小" class="headerlink" title="批量发送大小"></a>批量发送大小</h4><p>默认情况下,总大小不能超过4MB</p><p>若要一次批量发送超过4MB的消息,有两种方法</p><ul><li><p>①将批量消息进行拆分,拆成若干大小小于等于4m的消息集合分多次批量发送</p></li><li><p>②在Producer端和Broker端修改属性</p><blockquote><p> Producer端需要在发送之前设置Producer的maxMessageSize属性</p><p> Broker端需要修改其加载的配置文件中的maxMessageSize属性</p></blockquote></li></ul><h4 id="生产者发送消息的大小"><a href="#生产者发送消息的大小" class="headerlink" title="生产者发送消息的大小"></a>生产者发送消息的大小</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202310032021734.png" alt="image-20231003202115698"></p><p>生产者通过send()方法发送的Message，并不是直接将Message序列化后发送到网络上的，而是通过这个Message生成了一个字符串发送出去的。这个字符串由四部分构成：Topic、消息Body、消息日志（占20字节），及用于描述消息的一堆属性key-value。这些属性中包含例如生产者地址、生产时间、要发送的QueueId等。最终写入到Broker中消息单元中的数据都是来自于这些属性。</p><h3 id="2-批量消费消息"><a href="#2-批量消费消息" class="headerlink" title="2.批量消费消息"></a>2.批量消费消息</h3><h4 id="修改批量属性"><a href="#修改批量属性" class="headerlink" title="修改批量属性"></a>修改批量属性</h4><p>Consumer的MessageListenerConcurrently监听接口的consumeMessage()方法的第一个参数为消息列表，但默认情况下每次只能消费一条消息。</p><p>若要使其一次可以消费多条消息，则可以通过修改Consumer的consumeMessageBatchMaxSize属性来指定。不过，该值不能超过32。因为默认情况下消费者每次可以拉取的消息最多是32条。</p><p>若要修改一次拉取的最大值，则可通过修改Consumer的pullBatchSize属性来指定</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>Consumer的pullBatchSize属性与consumeMessageBatchMaxSize属性如何设置合适</p><ul><li><p>pullBatchSize值设置的越大，Consumer每拉取一次需要的时间就会越长，且在网络上传输出现问题的可能性就越高。若在拉取过程中若出现了问题，那么本批次所有消息都需要全部重新拉取。</p></li><li><p>consumeMessageBatchMaxSize值设置的越大，Consumer的消息并发消费能力越低，且这批被消费的消息具有相同的消费结果。因为consumeMessageBatchMaxSize指定的一批消息只会使用一个线程进行处理，且在处理过程中只要有一个消息处理异常，则这批消息需要全部重新再次消费处理</p></li></ul><h2 id="六、消息过滤"><a href="#六、消息过滤" class="headerlink" title="六、消息过滤"></a>六、消息过滤</h2><p>消费者在可以订阅Topic的同时,对Topic中的消息进行条件过滤</p><h3 id="1-Tag过滤"><a href="#1-Tag过滤" class="headerlink" title="1.Tag过滤"></a>1.Tag过滤</h3><p>通过consumer的subscribe()方法制定要订阅消息的Tag; 若订阅多个Tag的消息, Tag用”||”连接</p><h4 id="2-SQL过滤"><a href="#2-SQL过滤" class="headerlink" title="2.SQL过滤"></a>2.SQL过滤</h4><p>SQL过滤是一种通过特定表达式对事先埋入到消息中的<strong>用户属性</strong>进行筛选过滤的方式; 通过SQL过滤,可以实现对消息的较复杂的过滤; 不过,只有通过<strong>Push模式</strong>的消费者才能使用SQL过滤</p><p>SQL过滤表达式支持多种常量类型与运算符</p><p>支持的常量类型 :</p><ul><li>数值</li><li>字符: 必须用单引号包裹</li><li>布尔类型</li><li>NULL</li></ul><p>支持的运算符 :</p><ul><li>数值比较：&gt;，&gt;=，&lt;，&lt;=，BETWEEN，=</li><li>字符比较：=，&lt;&gt;，IN</li><li>逻辑运算 ：AND，OR，NOT</li><li>NULL判断：IS NULL 或者 IS NOT NULL</li></ul><p>默认情况下Broker没有开启消息的SQL过滤功能，需要在Broker加载的配置文件中添加如下属性，以开启该功能：<code>enablePropertyFilter = true</code></p><p>在启动Broker时需要指定这个修改过的配置文件。例如对于单机Broker的启动，其修改的配置文件是conf/broker.conf，启动时使用如下命令：<code>sh bin/mqbroker -n localhost:9876 -c conf/broker.conf &amp;</code></p><h2 id="七、消息发送重试机制"><a href="#七、消息发送重试机制" class="headerlink" title="七、消息发送重试机制"></a>七、消息发送重试机制</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>Producer对发送失败的消息进行重新发送的机制,称为消息发送重试机制,又称消息重投机制</p><p>需要注意以下几点</p><ul><li>生产者若采用<strong>同步/异步</strong>发送方式, 发送失败后会<strong>重试</strong>, 但oneway消息发送方式在消息发送失败后是没有重试机制的</li><li><strong>只有</strong>普通消息发送具有重试机制</li><li>消息重投只保证消息尽可能发送成功,不丢失,但不保证消息不重复;</li><li>在RocketMQ中无法避免消息重复,但要避免消息的重复消费</li><li>消息重复在一般情况下不会发生,但在消息量大、网络抖动时,消息重复可能会十分频繁</li><li>Producer主动重发、consumer负载变化时也可能会导致消息重复(Rebalance不会导致消息重复,但可能会产生重复消费)</li><li>避免消息重复消费的方法: 为消息添加唯一标示(key), 让消费者对消息进行消费判断来避免重复消费</li><li>消息发送重试有三种策略: 同步发送失败策略、异步发送失败策略、消息刷盘失败策略</li></ul><h3 id="2-同步发送失败策略"><a href="#2-同步发送失败策略" class="headerlink" title="2.同步发送失败策略"></a>2.同步发送失败策略</h3><p>对于普通消息，消息发送默认采用轮询策略来选择所发送到的队列。如果发送失败，默认重试2次。但在重试时是不会选择上次发送失败的Broker，而是选择其它Broker。当然，若只有一个Broker其也只能发送到该Broker，但其会尽量发送到该Broker上的其它Queue。</p><p>同时，Broker还具有<strong>失败隔离</strong>功能，使Producer尽量选择未发生过发送失败的Broker作为目标Broker。其可以保证其它消息尽量不发送到问题Broker，为了提升消息发送效率，降低消息发送耗时。</p><p>如果超过重试次数，则抛出异常，由Producer去<strong>保证消息不丢</strong>。当然当生产者出现RemotingException、MQClientException和MQBrokerException时，Producer会自动重投消息。</p><h3 id="3-异步发送失败策略"><a href="#3-异步发送失败策略" class="headerlink" title="3.异步发送失败策略"></a>3.异步发送失败策略</h3><p>异步发送失败时,重试时不会选择其他Broker,而是仅在一个Broker上进行重试,所以<strong>无法保证消息不丢</strong></p><h3 id="4-消息刷盘失败策略"><a href="#4-消息刷盘失败策略" class="headerlink" title="4.消息刷盘失败策略"></a>4.消息刷盘失败策略</h3><p>消息刷盘超市或slave不可用(slave在数据同步时向master返回状态不是SEND_OK)时,默认是不会将消息尝试发送到其他Broker的; 不过,对于重要消息可以通过在Broker的配置文件设置retryAnotherBrokerWhenNotStoreOK为true来开启</p><h2 id="八、消息消费重试机制"><a href="#八、消息消费重试机制" class="headerlink" title="八、消息消费重试机制"></a>八、消息消费重试机制</h2><h3 id="1-顺序消息的消费重试"><a href="#1-顺序消息的消费重试" class="headerlink" title="1.顺序消息的消费重试"></a>1.顺序消息的消费重试</h3><p>对于顺序消息,当Consumer消费消息失败后,为保证消息的顺序性,会不断地进行消息重试,直到成功消费; 消费重试默认时间间隔为1000ms; 重试期间应用会出现消息消费被阻塞的情况</p><blockquote><p>因为顺序消费的重试是不间断的,为避免消费被永久阻塞, 要保证应用能及时监控并处理消费失败的情况</p><p>顺序消息没有发送失败重试机制, 但有消费失败重试机制</p></blockquote><h3 id="2-无序消息的消费重试"><a href="#2-无序消息的消费重试" class="headerlink" title="2.无序消息的消费重试"></a>2.无序消息的消费重试</h3><p>对于无序消息(普通消息、延时消息、事务消息), 当Consumer消费消息失败时，可以通过设置返回状态达到消息重试的效果。需要注意的是，无序消息的重试只对集群消费方式生效，广播消费方式不提供失败重试特性。即对于广播消费，消费失败后，失败消息不再重试，继续消费后续消息。</p><h3 id="3-消费重试次数与间隔"><a href="#3-消费重试次数与间隔" class="headerlink" title="3.消费重试次数与间隔"></a>3.消费重试次数与间隔</h3><p>对于无序消息集群消费下的重试消费，每条消息默认最多重试16次，但每次重试的间隔时间是不同的，会逐渐变长。每次重试的间隔时间如下表:</p><div class="table-container"><table><thead><tr><th>重试次数</th><th>重试的时间间隔</th><th>重试次数</th><th>重试的时间间隔</th></tr></thead><tbody><tr><td>1</td><td>10s</td><td>9</td><td>7m</td></tr><tr><td>2</td><td>30s</td><td>10</td><td>8m</td></tr><tr><td>3</td><td>1m</td><td>11</td><td>9m</td></tr><tr><td>4</td><td>2m</td><td>12</td><td>10m</td></tr><tr><td>5</td><td>3m</td><td>13</td><td>20m</td></tr><tr><td>6</td><td>4m</td><td>14</td><td>30m</td></tr><tr><td>7</td><td>5m</td><td>15</td><td>1h</td></tr><tr><td>8</td><td>6m</td><td>16</td><td>2h</td></tr></tbody></table></div><blockquote><p>一条消息在消费失败次数达到上限后,会将该消息投递到<strong>死信队列</strong></p></blockquote><h3 id="3-重试队列"><a href="#3-重试队列" class="headerlink" title="3.重试队列"></a>3.重试队列</h3><p>对于需要重试消费的消息，并不是Consumer在等待了指定时长后再次去拉取原来的消息进行消费，而是将这些需要重试消费的消息放入到了一个特殊Topic的队列中，而后进行再次消费的。这个特殊的队列就是重试队列。</p><p>当出现需要进行重试消费的消息时，Broker会为每个消费组都设置一个Topic名称为%RETRY%consumerGroup@consumerGroup 的重试队列。</p><p>Broker对于重试消息的处理是通过<strong>延时消息</strong>实现的。先将消息保存到SCHEDULE_TOPIC_XXXX延迟队列中，延迟时间到后，会将消息投递到%RETRY%consumerGroup@consumerGroup重试队列中。</p><blockquote><p><em>1</em>）这个重试队列是针对消息组的，而不是针对每个<em>Topic</em>设置的（一个<em>Topic</em>的消息可以让多个消费者组进行消费，所以会为这些消费者组各创建一个重试队列）<br><em>2</em>）只有当出现需要进行重试消费的消息时，才会为该消费者组创建重试队列</p></blockquote><h2 id="九、死信队列"><a href="#九、死信队列" class="headerlink" title="九、死信队列"></a>九、死信队列</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>达到最大重试次数后，消费依然失败的消息会被发送到该消费者对应的特殊队列中, 即死信队列, 其中的消息称为死信消息</p><h3 id="2-特征"><a href="#2-特征" class="headerlink" title="2.特征"></a>2.特征</h3><ul><li>死信队列中的消息不会再被消费者正常消费，即DLQ对于消费者是<strong>不可见</strong>的</li><li>死信存储有效期与正常消息相同，均为 3 天（commitlog文件的过期时间），3 天后会被自动删除</li><li>死信队列就是一个特殊的Topic，名称为%DLQ%consumerGroup@consumerGroup ，即每个消费者组都有一个死信队列</li><li>如果⼀个消费者组未产生死信消息，则不会为其创建相应的死信队列</li></ul><h3 id="3-死信消息的处理"><a href="#3-死信消息的处理" class="headerlink" title="3.死信消息的处理"></a>3.死信消息的处理</h3><p>实际上，当⼀条消息进入死信队列，就意味着系统中某些地方出现了问题，从而导致消费者无法正常消费该消息，比如代码中原本就存在Bug。因此，对于死信消息，通常需要开发人员进行特殊处理。最关键的步骤是要排查可疑因素，解决代码中可能存在的Bug，然后再将原来的死信消息再次进行投递消费。</p>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spirng-cloud </tag>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ 三、工作原理笔记</title>
      <link href="/2023/09/24/2023-9-27-rocketMQ%E7%AC%AC%E4%B8%89%E7%AB%A0-rocketMQ%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2023/09/24/2023-9-27-rocketMQ%E7%AC%AC%E4%B8%89%E7%AB%A0-rocketMQ%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-RocketMQ工作原理"><a href="#第三章-RocketMQ工作原理" class="headerlink" title="第三章 RocketMQ工作原理"></a>第三章 RocketMQ工作原理</h1><h2 id="一、消息的生产"><a href="#一、消息的生产" class="headerlink" title="一、消息的生产"></a>一、消息的生产</h2><h3 id="1-消息的生产过程"><a href="#1-消息的生产过程" class="headerlink" title="1.消息的生产过程"></a>1.消息的生产过程</h3><p>Producer可以将消息写入到某Broker的某Queue中,过程如下</p><ul><li><p>Producer发送消息之前，会先向NameServer发出请求来获取<strong>消息Topic的路由信息</strong></p></li><li><p>NameServer返回该<strong>Topic的路由表</strong>及<strong>Broker列表</strong></p></li><li><p>Producer根据代码中指定的Queue选择策略，从Queue列表中选出一个队列，用于后续存储消息</p></li><li><p>Producer对消息做一些特殊处理，例如，消息本身超过4M，则会对其进行压缩</p></li><li><p>Producer向选择出的Queue所在的Broker发出RPC请求，将消息发送到选择出的Queue</p></li></ul><blockquote><p>路由表:实际上是一个Map,key为Topic名称,value是一个QueueData的实例列表(所有涉及该Topic的BrokerName列表)</p><p>Broker列表:其实际上也是一个Map,key为brokerName,value为BrokerData; 一套BrokerName相同的Master-Slave小集群对应一个BrokerData; BrokerData中包含brokerName及一个map; 该Map的key为brokerId, value为broker对应的地址; brokerId为0表示为master,非0表示slave</p></blockquote><h3 id="2-Queue选择算法"><a href="#2-Queue选择算法" class="headerlink" title="2.Queue选择算法"></a>2.Queue选择算法</h3><h4 id="轮询算法"><a href="#轮询算法" class="headerlink" title="轮询算法"></a>轮询算法</h4><p>默认选择算法; 其保证了每个Queue都可以均匀地获取到消息,避免了饥饿</p><blockquote><p>缺点:若某些Broker的Queue投递时延较高,会导致Producer的缓存队列消息挤压,降低性能</p></blockquote><h4 id="最小投递延迟算法"><a href="#最小投递延迟算法" class="headerlink" title="最小投递延迟算法"></a>最小投递延迟算法</h4><p>根据统计的每次消息投递的时间延迟,将消息投递到时延最小的Queue; 若延迟相同,则采取轮询算法投递</p><blockquote><p>缺点:消息在Queue上分配不均</p></blockquote><h2 id="二、消息的存储"><a href="#二、消息的存储" class="headerlink" title="二、消息的存储"></a>二、消息的存储</h2><p>RocketMQ的消息默认存储在本地文件系统的主目录下store目录中</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309242036005.png" alt="image-20230924203630910"></p><ul><li>abort：该文件在Broker启动后会自动创建，正常关闭Broker，该文件会自动消失。若在没有启动</li><li>Broker的情况下，发现这个文件是存在的，则说明之前Broker的关闭是非正常关闭。</li><li>checkpoint：其中存储着commitlog、consumequeue、index文件的最后刷盘时间戳</li><li>commitlog：其中存放着commitlog文件，而消息是写在commitlog文件中的</li><li>config：存放着Broker运行期间的一些配置数据</li><li>consumequeue：其中存放着consumequeue文件，队列就存放在这个目录中</li><li>index：其中存放着消息索引文件indexFile</li><li>lock：运行期间使用到的全局资源锁</li></ul><h3 id="1-commitlog文件"><a href="#1-commitlog文件" class="headerlink" title="1.commitlog文件"></a>1.commitlog文件</h3><p><del>在很多资料中<em>commitlog</em>目录中的文件简称为<em>commitlog</em>文件。但在源码中，该文件被命名为<em>mappedFile</em>。</del></p><h4 id="目录与文件"><a href="#目录与文件" class="headerlink" title="目录与文件"></a>目录与文件</h4><p>commitlog目录中存放着很多的mappedFile文件，当前Broker中的所有消息都是落盘到这些mappedFile文件中的。mappedFile文件最大大小为1G，文件名由20位十进制数构成，表示当前文件的第一条消息的起始位移偏移量。</p><blockquote><p>一个<em>Broker</em>中所有<em>mappedFile</em>文件的<em>commitlog offset</em>是连续的, 第<em>n</em>个文件名应该是前<em>n-1</em>个文件大小之和。</p></blockquote><p>需要注意的是，一个Broker中仅包含一个commitlog目录，所有的mappedFile文件都是存放在该目录中的。即无论当前Broker中存放着多少Topic的消息，这些消息都是被顺序写入到了mappedFile文件中的。也就是说,<del>因为用顺序读写效率高</del>，这些消息在Broker中存放时并没有被按照Topic进行分类存放。</p><h4 id="消息单元"><a href="#消息单元" class="headerlink" title="消息单元"></a>消息单元</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309242116980.png" alt="image-20230924211625897"></p><p>mappedFile文件内容由一个个的消息单元构成。每个消息单元中包含消息总长度MsgLen、消息的物理位置physicalOffset、消息体内容Body、消息体长度BodyLength、消息主题Topic、Topic长度TopicLength、消息生产者BornHost、消息发送时间戳BornTimestamp、消息所在的队列QueueId、消息在Queue中存储的偏移量QueueOffset等近20余项消息相关属性。</p><blockquote><p>commitlog与queue的关系</p><p>一个mappedFile文件中第m+1个消息单元的commitlog offset偏移量:</p><p>L(m+1)=L(m)+MsgLen(m)  (m&gt;0)</p></blockquote><h3 id="2-consumequeue"><a href="#2-consumequeue" class="headerlink" title="2.consumequeue"></a>2.consumequeue</h3><p>存储消息在CommitLog中的位置信息,可以看作是commitlog关于消息消费的索引文件</p><h4 id="目录与文件-1"><a href="#目录与文件-1" class="headerlink" title="目录与文件"></a>目录与文件</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309252130546.png" alt="image-20230925213011483"></p><p>为了提高效率，会为每个Topic在~/store/consumequeue中创建一个目录，目录名为Topic名称。在该Topic目录下，会再为每个该Topic的Queue建立一个目录，目录名为queueId。每个目录中存放着若干consumequeue文件，consumequeue文件是commitlog的索引文件，可以根据consumequeue定位到具体的消息。</p><p>consumequeue文件名也由20位数字构成，表示当前文件的第一个索引条目的起始位移偏移量。与mappedFile文件名不同的是，其后续文件名是固定的。因为consumequeue文件大小是固定不变的。</p><h4 id="索引条目"><a href="#索引条目" class="headerlink" title="索引条目"></a>索引条目</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309252131574.png" alt="image-20230925213120532"></p><p>每个consumequeue文件可以包含30w个索引条目，每个索引条目包含了三个消息重要属性：消息在mappedFile文件中的偏移量CommitLog Offset、消息长度、消息Tag的hashcode值。这三个属性占20个字节，所以每个文件的最大大小是固定的30w * 20字节。</p><blockquote><p>一个<em>consumequeue</em>文件中所有消息的<em>Topic</em>一定是相同的。但每条消息的<em>Tag</em>可能是不同的。</p></blockquote><h3 id="3-对文件的读写"><a href="#3-对文件的读写" class="headerlink" title="3.对文件的读写"></a>3.对文件的读写</h3><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309252136726.png" alt="image-20230925213657682"></p><h4 id="消息写入"><a href="#消息写入" class="headerlink" title="消息写入"></a>消息写入</h4><p>一条消息进入到Broker后经历了以下几个过程才最终被持久化。</p><ul><li><p>Broker根据queueId，获取到该消息对应索引条目要在consumequeue目录中的写入偏移量，即QueueOffset</p></li><li><p>将queueId、queueOffset等数据，与消息一起封装为消息单元</p></li><li><p>将消息单元写入到commitlog</p></li><li><p>同时，形成消息索引条目</p></li><li><p>将消息索引条目分发到相应的consumequeue</p></li></ul><h4 id="消息拉取"><a href="#消息拉取" class="headerlink" title="消息拉取"></a>消息拉取</h4><p>当Consumer来拉取消息时会经历以下几个步骤：</p><ul><li>Consumer获取到其要消费消息所在Queue的消费偏移量offset，计算出其要消费消息的消息offset</li></ul><blockquote><p>消费<em>offset</em>即消费进度，<em>consumer</em>对某个<em>Queue</em>的消费<em>offset</em>，即消费到了该<em>Queue</em>的第几条消息</p><p>消息<em>offset =</em> 消费<em>offset + 1</em></p></blockquote><ul><li><p>Consumer向Broker发送拉取请求，其中会包含其要拉取消息的Queue、消息offset及消息Tag。</p></li><li><p>Broker计算在该consumequeue中的queueOffset。</p></li></ul><blockquote><p>queueOffset =消息offset * 20字节</p></blockquote><ul><li><p>从该queueOffset处开始向后查找第一个指定Tag的索引条目。</p></li><li><p>解析该索引条目的前8个字节，即可定位到该消息在commitlog中的commitlog offset</p></li><li><p>从对应commitlog offset中读取消息单元，并发送给Consumer</p></li></ul><h4 id="性能提升"><a href="#性能提升" class="headerlink" title="性能提升"></a>性能提升</h4><p>RocketMQ中，无论是消息本身还是消息索引，都是存储在磁盘上的。其不会影响消息的消费吗？当然不会。其实RocketMQ的性能在目前的MQ产品中性能是非常高的。因为系统通过一系列相关机制大大提升了性能。</p><p>首先，RocketMQ对文件的读写操作是通过<strong>mmap零拷贝</strong>进行的，将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率。</p><p>其次，consumequeue中的数据是顺序存放的，还引入了<strong>PageCache的预读取机制</strong>，使得对consumequeue文件的读取几乎接近于内存读取，即使在有消息堆积情况下也不会影响性能</p><blockquote><p><em>PageCache</em>机制，页缓存机制，是<em>OS</em>对文件的缓存机制，用于加速对文件的读写操作。一般来说，程序对文件进行<strong>顺序读写</strong>的速度几乎接近于内存读写速度，主要原因是由于<em>OS</em>使用<em>PageCache</em>机制对读写访问操作进行性能优化，将一部分的内存用作<em>PageCache</em>。</p><ul><li><p>写操作：<em>OS</em>会先将数据写入到<em>PageCache</em>中，随后会以异步方式由<em>pdflush</em>（<em>page dirty flush)</em>内核线程将<em>Cache</em>中的数据刷盘到物理磁盘</p></li><li><p>读操作：若用户要读取数据，其首先会从<em>PageCache</em>中读取，若没有命中，则<em>OS</em>在从物理磁盘上加载该数据到<em>PageCache</em>的同时，也会顺序对其相邻数据块中的数据进行<strong>预读取</strong>。</p></li></ul></blockquote><p>RocketMQ中可能会影响性能的是对commitlog文件的读取。因为对commitlog文件来说，读取消息时会产生大量的随机访问(在commitlog中找想要的消息)，而随机访问会严重影响性能。不过，如果选择合适的系统IO调度算法，比如设置调度算法为Deadline（采用SSD固态硬盘的话），随机读的性能也会有所提升。</p><h2 id="三、indexFile"><a href="#三、indexFile" class="headerlink" title="三、indexFile"></a>三、indexFile</h2><p>除了通过通常的指定Topic进行消息消费外，RocketMQ还提供了根据key进行消息查询的功能。该查询是通过store目录中的index子目录中的indexFile进行索引实现的快速查询。当然，这个indexFile中的索引数据是在<strong>包含了key的消息</strong>被发送到Broker时写入的。如果消息中没有包含key，则不会写入。</p><h3 id="1-indexFile结构"><a href="#1-indexFile结构" class="headerlink" title="1.indexFile结构"></a>1.indexFile结构</h3><p>每个Broker中会包含一组indexFile，每个indexFile都是以一个<strong>时间戳</strong>命名的（这个indexFile被创建时的时间戳）。每个indexFile文件由三部分构成：indexHeader，slots槽位，indexes索引数据。每个indexFile文件中包含500w个slot槽。而每个slot槽又可能会挂载很多的index索引单元</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309252217818.png" alt="image-20230925221749771"></p><p>indexHeader固定40个字节，其中存放着如下数据：</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309252218067.png" alt="image-20230925221844032"></p><ul><li>beginTimestamp：该indexFile中第一条消息的存储时间</li><li>endTimestamp：该indexFile中最后一条消息存储时间</li><li>beginPhyoffset：该indexFile中第一条消息在commitlog中的偏移量commitlog offset</li><li>endPhyoffset：该indexFile中最后一条消息在commitlog中的偏移量commitlog offset</li><li>hashSlotCount：已经填充有index的slot数量（并不是每个slot槽下都挂载有index索引单元，这里统计的是所有挂载了index索引单元的slot槽的数量）</li><li>indexCount：该indexFile中包含的索引单元个数（统计出当前indexFile中所有slot槽下挂载的<strong>所有</strong>index索引单元的数量之和）</li></ul><p>Slots与Indexes间的关系:</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309252221053.png" alt="image-20230925222152967"></p><p><strong>key的hash值 % 500w</strong>的结果即为slot槽位，然后将该slot值修改为该index索引单元的indexNo，根据这个indexNo可以计算出该index单元在indexFile中的位置。不过，该取模结果的重复率是很高的，为了解决该问题，在每个index索引单元中增加了preIndexNo，用于指定该slot中当前index索引单元的前一个index索引单元。而slot中始终存放的是其下最新的index索引单元的indexNo，这样的话，<strong>只要找到了slot就可以找到其最新的index索引单元，而通过这个index索引单元就可以找到其之前的所有index索引单元</strong>。</p><blockquote><p><em>indexNo</em>是一个在<em>indexFile</em>中的流水号，从<em>0</em>开始依次递增。即在一个<em>indexFile</em>中所有<em>indexNo</em>是依次递增的。<em>indexNo</em>在<em>index</em>索引单元中是没有体现的，其是通过<em>indexes</em>中依次数出来的。</p></blockquote><p>index索引单元有20个字节，其中存放着以下四个属性：</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309252227550.png" alt="image-20230925222743506"></p><h3 id="2-indexFile的创建"><a href="#2-indexFile的创建" class="headerlink" title="2.indexFile的创建"></a>2.indexFile的创建</h3><h4 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h4><p>indexFile的文件名为当前文件被创建时的时间戳。这个时间戳有什么用处呢？</p><p>根据业务key进行查询时，查询条件除了key之外，还需要指定一个要查询的时间戳，表示要查询不大于该时间戳的最新的消息，即查询指定时间戳之前存储的最新消息。这个时间戳文件名可以简化查询，提高查询效率。</p><h4 id="创建时机"><a href="#创建时机" class="headerlink" title="创建时机"></a>创建时机</h4><p>indexFile文件是何时创建的？其创建的条件（时机）有两个：</p><ul><li>当第一条带key的消息发送来后，系统发现没有indexFile，此时会创建第一个indexFile文件</li><li>当一个indexFile中挂载的index索引单元数量超出2000w个时，会创建新的indexFile。当带key的消息发送到来后，系统会找到最新的indexFile，并从其indexHeader的最后4字节中读取到indexCount。若indexCount &gt;= 2000w时，会创建新的indexFile。</li></ul><blockquote><p> 由于可以推算出，一个<em>indexFile</em>的最大大小是：<em>(40 + 500w \</em> 4 + 2000w * 20)*字节</p></blockquote><h3 id="3-查询流程"><a href="#3-查询流程" class="headerlink" title="3.查询流程"></a>3.查询流程</h3><p>当消费者通过业务key来查询相应的消息时，其需要经过一个相对较复杂的查询流程。不过，在分析查</p><p>询流程之前，首先要清楚几个定位计算式子：</p><ul><li><p>计算指定消息key的slot槽位序号:  <code>slot槽位序号 = key的hash%500w</code></p></li><li><p>计算槽位序号为n的slot在indexFile中的起始位置: <code>slot(n)位置=40+(n-1)*4</code></p></li><li><p>计算indexNo为m的index在indexFile中的位置:  <code>index(x)的位置=40+500w*4+(m-1)*20</code></p></li></ul><p>具体的查询流程如下:</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309252351654.png" alt="image-20230925235145545"></p><h2 id="四、消息的消费"><a href="#四、消息的消费" class="headerlink" title="四、消息的消费"></a>四、消息的消费</h2><p>消费者从Broker中获取消息的方式有两种：pull拉取方式和push推动方式。</p><p>消费者组对于消息消费的模式又分为两种：集群消费Clustering和广播消费Broadcasting。</p><h3 id="1-推拉消费类型"><a href="#1-推拉消费类型" class="headerlink" title="1.推拉消费类型"></a>1.推拉消费类型</h3><h4 id="拉取push式消费"><a href="#拉取push式消费" class="headerlink" title="拉取push式消费"></a>拉取push式消费</h4><p>Consumer主动从Broker中拉取消息，主动权由Consumer控制。一旦获取了批量消息，就会启动消费过程。不过，该方式的实时性较弱，即Broker中有了新的消息时消费者并不能及时发现并消费。</p><blockquote><p>由于拉取时间间隔是由用户指定的，所以在设置该间隔时需要注意平稳：间隔太短，空请求比例会增加；间隔太长，消息的实时性太差</p></blockquote><h4 id="推送pull式消费"><a href="#推送pull式消费" class="headerlink" title="推送pull式消费"></a>推送pull式消费</h4><p>该模式下Broker收到数据后会主动推送给Consumer。该获取方式一般实时性较高。</p><p>该获取方式是典型的发布-订阅模式，即Consumer向其关联的Queue注册了监听器，一旦发现有新的消息到来就会触发回调的执行，回调方法是Consumer去Queue中拉取消息。而这些都是基于Consumer与Broker间的长连接的。长连接的维护需要消耗系统资源</p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ul><li><p>pull：需要应用去实现对关联Queue的遍历，实时性差；但便于应用控制消息的拉取</p></li><li><p>push：封装了对关联Queue的遍历，实时性强，但会占用较多的系统资源</p></li></ul><h3 id="2-消费模式"><a href="#2-消费模式" class="headerlink" title="2.消费模式"></a>2.消费模式</h3><h4 id="广播消费"><a href="#广播消费" class="headerlink" title="广播消费"></a>广播消费</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309261502889.png" alt="image-20230926145526581"></p><p>广播消费模式下，相同Consumer Group的每个Consumer实例都接收同一个Topic的全量消息。即每条消息都会被发送到Consumer Group中的<strong>每个</strong>Consumer。</p><h4 id="集群消费"><a href="#集群消费" class="headerlink" title="集群消费"></a>集群消费</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309261502689.png" alt="image-20230926145710024"></p><p>集群消费模式下，相同Consumer Group的每个Consumer实例<strong>平均分摊</strong>同一个Topic的消息。即每条消息只会被发送到Consumer Group中的<strong>某个</strong>Consumer。</p><h4 id="消息进度保存"><a href="#消息进度保存" class="headerlink" title="消息进度保存"></a>消息进度保存</h4><ul><li><p>广播模式：消费进度保存在consumer端。因为广播模式下consumer group中每个consumer都会消费所有消息，但它们的消费进度是不同。所以consumer各自保存各自的消费进度。</p></li><li><p>集群模式：消费进度保存在broker中。consumer group中的所有consumer共同消费同一个Topic中的消息，同一条消息只会被消费一次。消费进度会参与到了消费的负载均衡中，故消费进度是需要共享的。</p></li></ul><h3 id="3-Rebalance机制"><a href="#3-Rebalance机制" class="headerlink" title="3.Rebalance机制"></a>3.Rebalance机制</h3><p>Rebalance机制需要在集群消费模式下部署</p><h4 id="Rebalance概念"><a href="#Rebalance概念" class="headerlink" title="Rebalance概念"></a>Rebalance概念</h4><p>Rebalance机制将一个Topic下的多个Queue在同一个Consumer Group中的多个Consumer间重新进行分配的过程</p><p>其是为了提升<strong>并行</strong>消费能力,动态地将Topic分配给Consumer集群</p><h4 id="Rebalance限制"><a href="#Rebalance限制" class="headerlink" title="Rebalance限制"></a>Rebalance限制</h4><p>由于一个队列最多只能分配给一个消费者,因此当某个消费者组下的消费者数大于Topic队列的数量时,多余的消费者实例将被闲置,造成资源的浪费</p><h4 id="Rebanlance缺点"><a href="#Rebanlance缺点" class="headerlink" title="Rebanlance缺点"></a>Rebanlance缺点</h4><ul><li><strong>消费暂停</strong>: 当新增Consumer时,正在进行消费的Consumer会被暂停,并在重新分配topic队列完成后再继续运行</li><li><strong>消费重复</strong>: Consumer 在消费新分配给自己的队列时，必须接着之前Consumer 提交的消费进度的offset继续消费。然而默认情况下，offset是<strong>异步提交</strong>的，这个异步性导致提交到Broker的offset与Consumer实际消费的消息并不一致。这个不一致的差值就是可能会重复消费的消息。</li></ul><blockquote><p>同步提交：<em>consumer</em>提交了其消费完毕的一批消息的<em>offset</em>给<em>broker</em>后，需要等待<em>broker</em>的成功ACK<em>。当收到</em>ACK<em>后，</em>consumer<em>才会继续获取并消费下一批消息。在等待</em>ACK<em>期间，</em>consumer是阻塞的。</p><p>异步提交：<em>consumer</em>提交了其消费完毕的一批消息的<em>offset</em>给<em>broker</em>后，不需要等待<em>broker</em>的成功<em>ACK</em>。<em>consumer</em>可以直接获取并消费下一批消息。</p><p>对于一次性读取消息的数量，需要根据具体业务场景选择一个相对均衡的是很有必要的。因为数量过大，系统性能提升了，但产生重复消费的消息数量可能会增加；数量过小，系统性能会下降，但被重复消费的消息数量可能会减少。</p></blockquote><p><strong>消费突刺</strong>: 如果Rebalance积累的消息重复过多或暂停时间过长导致消息大量积压,可能导致Rebalance结束之后瞬间需要消费大量消息</p><h4 id="Rebalance产生原因"><a href="#Rebalance产生原因" class="headerlink" title="Rebalance产生原因"></a>Rebalance产生原因</h4><ul><li>消费者订阅的Topic的Queue数量变化 (Broker容量调整/升级运维/与NameServer网络异常,Queue容量调整)</li><li>消费者组中消费者数量变化 (Consumer group容量调整/升级运维/与NameServer网络异常)</li></ul><h4 id="Rebalance过程"><a href="#Rebalance过程" class="headerlink" title="Rebalance过程"></a>Rebalance过程</h4><p>在Broker中维护着多个Map集合，这些集合中动态存放着当前Topic中Queue的信息、Consumer Group中Consumer实例的信息。一旦发现消费者所订阅的Queue数量发生变化，或消费者组中消费者的数量发生变化，立即向Consumer Group中的每个实例发出Rebalance通知。</p><p>Consumer实例在接收到通知后会采用Queue分配算法自己获取到相应的Queue，即由Consumer实例自主进行Rebalance。</p><h3 id="4-Queue分配算法"><a href="#4-Queue分配算法" class="headerlink" title="4.Queue分配算法"></a>4.Queue分配算法</h3><p>一个Topic中的Queue只能由Consumer Group中的一个Consumer进行消费，而一个Consumer可以同时消费多个Queue中的消息。那么Queue与Consumer间的配对关系是如何确定的，即Queue要分配给哪个Consumer进行消费，也是有算法策略的。常见的有四种策略。这些策略是通过在创建Consumer时的构造器传进去的。</p><h4 id="平均分配策略"><a href="#平均分配策略" class="headerlink" title="平均分配策略"></a>平均分配策略</h4><p><img src="C:/Users/Hantou/AppData/Roaming/Typora/typora-user-images/image-20230926221043803.png" alt="image-20230926221043803"></p><p>该算法是要根据<code>avg = QueueCount / ConsumerCount</code> 的计算结果进行分配的。如果能够整除，则按顺序将avg个Queue逐个分配Consumer；如果不能整除，则将多余出的Queue按照Consumer顺序逐个分配。(先算再分)</p><h4 id="环形平均策略"><a href="#环形平均策略" class="headerlink" title="环形平均策略"></a>环形平均策略</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309262212580.png" alt="image-20230926221233496"></p><p>环形平均算法是指，根据消费者的顺序，依次在由queue队列组成的环形图中逐个分配。(直接轮流来)</p><h4 id="一致性hash策略"><a href="#一致性hash策略" class="headerlink" title="一致性hash策略"></a>一致性hash策略</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309262214544.png" alt="image-20230926221413488"></p><p>该算法会将consumer的hash值作为Node节点存放到hash环上，然后将queue的hash值也放到hash环上，通过<strong>顺时针</strong>方向，距离queue最近的那个consumer就是该queue要分配的consumer。</p><blockquote><p>缺点:分配不均</p></blockquote><h4 id="同机房策略"><a href="#同机房策略" class="headerlink" title="同机房策略"></a>同机房策略</h4><p>该算法会根据queue的部署机房位置和consumer的位置，过滤出当前consumer相同机房的queue。然后按照平均分配策略或环形平均策略对同机房queue进行分配。如果没有同机房queue，则按照平均分配策略或环形平均策略对所有queue进行分配。</p><h3 id="5-至少一次原则"><a href="#5-至少一次原则" class="headerlink" title="5.至少一次原则"></a>5.至少一次原则</h3><p>RocketMQ有一个原则：每条消息必须要被<strong>成功消费</strong>一次。</p><p>那么什么是成功消费呢？Consumer在消费完消息后会向其<strong>消费进度记录器</strong> (在广播模式中就是Consumer本身,在集群消费模式中就是Broker) 提交其消费消息的offset，offset被成功记录到记录器中，那么这条消费就被成功消费了。</p><h2 id="五、订阅关系的一致性"><a href="#五、订阅关系的一致性" class="headerlink" title="五、订阅关系的一致性"></a>五、订阅关系的一致性</h2><p>订阅关系的一致性指的是，<strong>同一个</strong>消费者组（Group ID相同）下所有Consumer实例所订阅的Topic与Tag及对消息的处理逻辑必须完全一致。否则，消息消费的逻辑就会混乱，甚至导致消息丢失。</p><h3 id="1-正确订阅关系"><a href="#1-正确订阅关系" class="headerlink" title="1 正确订阅关系"></a>1 正确订阅关系</h3><p>多个消费者组订阅了多个Topic，并且每个消费者组里的多个消费者实例的订阅关系<strong><u>(Topic+Tag+其数量)</u></strong>保持了一致。</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309262225866.png" alt="image-20230926222549803"></p><h3 id="2-错误订阅关系"><a href="#2-错误订阅关系" class="headerlink" title="2 错误订阅关系"></a>2 错误订阅关系</h3><p>一个消费者组订阅了多个Topic，但是该消费者组里的多个Consumer实例的订阅关系并没有保持一致。</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309262226443.png" alt="image-20230926222627399"></p><h2 id="六、offset管理"><a href="#六、offset管理" class="headerlink" title="六、offset管理"></a>六、offset管理</h2><blockquote><p>此处offset指Consumer的消费进度offset</p></blockquote><p>消费进度offset是用来记录每个Queue的不同消费组的消费进度的。根据消费进度记录器的不同，可以分为两种模式：本地模式和远程模式。</p><h3 id="1-offset本地管理模式"><a href="#1-offset本地管理模式" class="headerlink" title="1. offset本地管理模式"></a>1. offset<strong>本地管理模式</strong></h3><p>当消费模式为<strong>广播消费</strong>时，offset使用本地模式存储。因为每条消息会被所有的消费者消费，每个消费者管理自己的消费进度，各个消费者之间不存在消费进度的交集。</p><p>Consumer在广播消费模式下offset相关数据以json的形式持久化到Consumer本地磁盘文件中，默认文件路径为当前用户主目录下的<code>.rocketmq_offsets/$&#123;clientId&#125;/$&#123;group&#125;/Offsets.json</code> </p><p>其中${clientId}为当前消费者id，默认为ip@DEFAULT；${group}为消费者组名称。</p><h3 id="2-offset远程管理模式"><a href="#2-offset远程管理模式" class="headerlink" title="2.offset远程管理模式"></a>2.offset远程管理模式</h3><p>当消费模式为<strong>集群消费</strong>时，offset使用远程模式管理。因为所有Cosnumer实例对消息采用的是均衡消费，所有Consumer共享Queue的消费进度。</p><p>Consumer在集群消费模式下offset相关数据以json的形式持久化到<strong>Broker</strong>磁盘文件中，文件路径为当前用户主目录下的<code>store/config/consumerOffset.json</code> </p><p>Broker启动时会加载这个文件，并写入到一个双层Map（ConsumerOffsetManager）。外层map的key为topic@group，value为内层map。内层map的key为queueId，value为offset。当发生Rebalance时，新的Consumer会从该Map中获取到相应的数据来继续消费。</p><p>集群模式下offset采用远程管理模式，主要是为了保证Rebalance机制。</p><h3 id="3-offset用途"><a href="#3-offset用途" class="headerlink" title="3.offset用途"></a>3.offset用途</h3><p>消费者是如何从最开始持续消费消息的？消费者要消费的第一条消息的起始位置是用户自己通过consumer.setConsumeFromWhere()方法指定的。</p><p>在Consumer启动后，其要消费的第一条消息的起始位置常用的有三种，这三种位置可以通过枚举类型常量设置。这个枚举类型为ConsumeFromWhere。</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309262238675.png" alt="image-20230926223846591"></p><blockquote><p><em>CONSUME_FROM_LAST_OFFSET</em>：从<em>queue</em>的当前最后一条消息开始消费</p><p><em>CONSUME_FROM_FIRST_OFFSET</em>：从<em>queue</em>的第一条消息开始消费</p><p><em>CONSUME_FROM_TIMESTAMP</em>：从指定的具体时间戳位置的消息开始消费。这个具体时间戳是通过另外一个语句指定的 。</p><p><em>consumer.setConsumeTimestamp(“20230902680000”) yyyyMMddHHmmss</em></p></blockquote><p>当消费完一批消息后，Consumer会提交其消费进度offset给Broker，Broker在收到消费进度后会将其更新到那个双层Map（ConsumerOffsetManager）及consumerOffset.json文件中，然后向该Consumer进行ACK，而ACK内容中包含三项数据：当前消费队列的最小offset（minOffset）、最大offset（maxOffset）、及下次消费的起始offset（nextBeginOffset）</p><h3 id="4-重试队列"><a href="#4-重试队列" class="headerlink" title="4.重试队列"></a>4.重试队列</h3><p>当rocketMQ对消息的消费出现异常时，会将发生异常的消息的offset提交到Broker中的重试队列。系统在发生消息消费异常时会为当前的topic@group创建一个重试队列，该队列以%RETRY%开头，到达重试时间后进行消费重试。</p><h3 id="5-offset的同步-异步提交"><a href="#5-offset的同步-异步提交" class="headerlink" title="5.offset的同步/异步提交"></a>5.offset的同步/异步提交</h3><p>集群消费模式下，Consumer消费完消息后会向Broker提交消费进度offset，其提交方式分为两种：</p><ul><li><p><strong>同步提交</strong>：消费者在消费完一批消息后会向broker提交这些消息的offset，然后等待broker的成功响应。若在等待超时之前收到了成功响应，则继续读取下一批消息进行消费（从ACK中获取nextBeginOffset）。若没有收到响应，则会重新提交，直到获取到响应。而在这个等待过程中，消费者是阻塞的。其严重影响了消费者的吞吐量。</p></li><li><p><strong>异步提交</strong>：消费者在消费完一批消息后向broker提交offset，但无需等待Broker的成功响应，可以继续读取并消费下一批消息。这种方式增加了消费者的吞吐量。但需要注意，broker在收到提交的offset后，还是会向消费者进行响应的。可能还没有收到ACK，此时Consumer会从Broker中直接获取nextBeginOffset。</p></li></ul><h2 id="七、消费幂"><a href="#七、消费幂" class="headerlink" title="七、消费幂"></a>七、消费幂</h2><h3 id="1-消费幂的概念"><a href="#1-消费幂的概念" class="headerlink" title="1.消费幂的概念"></a>1.消费幂的概念</h3><p>当出现消费者对某条消息重复消费的情况时，重复消费的结果与消费一次的结果是相同的，并且多次消费并未对业务系统产生任何负面影响，那么这个消费过程就是消费幂等的。</p><blockquote><p>幂等：若某操作执行多次与执行一次对系统产生的影响是相同的，则称该操作是幂等的。</p></blockquote><p>在互联网应用中，尤其在网络不稳定的情况下，消息很有可能会出现重复发送或重复消费。如果重复的消息可能会影响业务处理，那么就应该对消息做幂等处理。</p><h3 id="2-消息重复的可能场景"><a href="#2-消息重复的可能场景" class="headerlink" title="2.消息重复的可能场景"></a>2.消息重复的可能场景</h3><h4 id="发送时消息重复"><a href="#发送时消息重复" class="headerlink" title="发送时消息重复"></a>发送时消息重复</h4><p>当Broker已经收到了Producer发来的消息并且完成持久化后,网络产生异常,导致Broker对Producer无法应答; 若Producer认为发送未成功并重试,此时Broker中可能产生两条相同的信息,之后Consumer也会消费两次一样的信息</p><h4 id="消费时消息重复"><a href="#消费时消息重复" class="headerlink" title="消费时消息重复"></a>消费时消息重复</h4><p>当Consumer已经收到了Broker发来的消息并完成处理后,网络产生异常,Broker未收到消费成功响应; 本着消息至少被消费一次的原则,Broker在网络回复后会再发送一次消息,此时Consumer又消费了一次相同的消息</p><h4 id="Rebalance时消息重复"><a href="#Rebalance时消息重复" class="headerlink" title="Rebalance时消息重复"></a>Rebalance时消息重复</h4><p>当消费者组中消费者数量变化或其订阅的topic的queue数量变化时,会触发Rebalance,此时消费者可能会收到曾经消费过的消息</p><h3 id="3-通用处理方案"><a href="#3-通用处理方案" class="headerlink" title="3.通用处理方案"></a>3.通用处理方案</h3><h4 id="两要素"><a href="#两要素" class="headerlink" title="两要素"></a>两要素</h4><ul><li><strong>幂等令牌</strong>: 是生产者和消费者两者中的既定协议,通常指具备唯一业务标示的字符串(eg: 订单号,流水号),一般是由Produce随着消息一同发送的</li><li><strong>唯一性处理</strong>: 服务端通过一定的算法策略,保证同一个业务不会被重复执行多次(eg:单笔订单支付操作)</li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li><p>首先通过<strong>缓存</strong>去重; 在缓存中若存在某幂等令牌,则说明本次操作是重复操作; 若缓存未命中,则进入下一步</p></li><li><p>在唯一性处理之前,现在<strong>数据库</strong>中查询幂等令牌作为索引的数据是否存在; 若存在,说明本次操作为重复操作; 若不存在,进入下一步</p></li><li>在同一事务中完成三项操作:唯一性处理-&gt;将幂等令牌写入缓存-&gt;将幂等令牌作为唯一索引,把数据写入数据库</li></ol><blockquote><p>两次查询一次是查缓存,一次是查数据库</p></blockquote><h2 id="八、消息堆积与消息延迟"><a href="#八、消息堆积与消息延迟" class="headerlink" title="八、消息堆积与消息延迟"></a>八、消息堆积与消息延迟</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>消息处理流程中,若Consumer的消费速度跟不上Producer的发送速度(进多出少),MQ中未处理的消息会越来越长,产生消息堆积; 消息出现堆积会发生消息延迟;</p><p>以下场景需要重点关注消息堆积和消费延迟问题:</p><ul><li><p>业务系统上下游能力不匹配导致消费堆积,且无法自行恢复</p></li><li><p>业务系统对消息的实时性要求高,无法接受消息堆积造成的延迟</p></li></ul><h3 id="2-产生原因分析"><a href="#2-产生原因分析" class="headerlink" title="2.产生原因分析"></a>2.产生原因分析</h3><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309271413333.png" alt="image-20230927141309207"></p><p>Consumer使用长轮询Pull模式消费消息,分为以下两个阶段:</p><h4 id="拉取消息"><a href="#拉取消息" class="headerlink" title="拉取消息"></a>拉取消息</h4><p>Consumer通过长轮询Pull模式批量拉取的方式从服务端获取消息,将拉取到的消息缓存到本地缓冲队列中; 对于拉取式消费,在内网下吞吐量较高,一般不会在此阶段堆积消息</p><h4 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h4><p>Consumer将本地缓存的消息提交到消费线程中，使用业务消费逻辑对消息进行处理，处理完毕后获取到一个结果。这是真正的消息消费过程。此时Consumer的消费能力就完全依赖于消息的消费耗时和消费并发度了。如果由于业务处理逻辑复杂等原因，导致处理单条消息的耗时较长，则整体的消息吞吐量肯定不会高，此时就会导致Consumer本地缓冲队列达到上限，停止从服务端拉取消息。</p><blockquote><p>消息堆积的主要原因是客户端的消费能力不足,而消费能力由<strong>消费耗时</strong>(高优先)和<strong>消费并发度</strong>(低优先)决定</p></blockquote><h3 id="3-消费耗时"><a href="#3-消费耗时" class="headerlink" title="3.消费耗时"></a>3.消费耗时</h3><p>影响消费耗时的主要因素是代码逻辑;而代码中影响处理市场的主要为<strong>CPU内部计算型代码</strong>和<strong>外部IO操作型代码</strong></p><blockquote><p>外部IO型代码是影响消息处理市场的主要原因</p><p>外部IO举例: 读写外部数据库/缓存/下游系统调用</p><p>对于下游系统的调用逻辑,需要提前梳理调用操作的耗时预期,以判断消费逻辑中IO操作是否合理; 消息堆积通常是由下游的<strong>服务异常</strong>或<strong>达到了DBMS的流量阈值</strong>,导致消费耗时增加</p></blockquote><h3 id="4-消息并发度"><a href="#4-消息并发度" class="headerlink" title="4.消息并发度"></a>4.消息并发度</h3><p>一般情况下,消费者端的消息并发度由<strong>单节点线程数</strong>和<strong>节点数量</strong>共同决定,值为<code>单节点线程数*节点数量</code>; 不过,通常需要优先调整单节点的线程数,若单机硬件资源达到上限,再通过横向扩展来提高消息并发度</p><blockquote><p>单节点线程数:单个消费者所包含的线程数量</p><p>节点数量:消费者组中消费者数量</p><p>对于普通/延时/事务消息,并发度都是<code>单节点线程数*节点数量</code>; 但对于顺序消息,并发度为<code>Topic的Queue分区数量</code></p></blockquote><h3 id="5-单机线程数计算"><a href="#5-单机线程数计算" class="headerlink" title="5.单机线程数计算"></a>5.单机线程数计算</h3><p>对于一台主机中线程池中线程数的设置需要谨慎对待,不能盲目的增加线程数; 设置太大会导致不必要的线程切换开销; 理想环境下单节点的最优线程数计算模型为: <code>C*(T1+T2)/T1</code></p><ul><li>C: CPU内核数</li><li>T1: CPU内部逻辑计算耗时</li><li>T2: 外部IO操作耗时</li></ul><h3 id="6-如何避免"><a href="#6-如何避免" class="headerlink" title="6.如何避免"></a>6.如何避免</h3><p>梳理消息的消费耗时+设置消息消费并发度</p><h4 id="梳理消息的消费耗时"><a href="#梳理消息的消费耗时" class="headerlink" title="梳理消息的消费耗时"></a>梳理消息的消费耗时</h4><p>通过压测获取消息的消费耗时，并对耗时较高的操作的代码逻辑进行分析。梳理消息的消费耗时需要关注以下信息：</p><ul><li>消息消费逻辑的计算复杂度是否过高，代码是否存在无限循环和递归等缺陷。</li><li>消息消费逻辑中的I/O操作是否是必须的，能否用本地缓存等方案规避。</li><li>消费逻辑中的复杂耗时的操作是否可以做异步化处理。如果可以，是否会造成逻辑错乱。</li></ul><h4 id="设置消费并发度"><a href="#设置消费并发度" class="headerlink" title="设置消费并发度"></a>设置消费并发度</h4><p>对于消息消费并发度的计算，可以通过以下两步实施：</p><ul><li><p>逐步调大单个Consumer节点的线程数，并观测节点的系统指标，得到单个节点最优的消费线程数和消息吞吐量。</p></li><li><p>根据上下游链路的流量<strong>峰值</strong>计算出需要设置的节点数</p></li></ul><blockquote><p>节点数 <em>=</em> 流量峰值 <em>/</em> 单个节点消息吞吐量 </p></blockquote><h2 id="九、消息的清理"><a href="#九、消息的清理" class="headerlink" title="九、消息的清理"></a>九、消息的清理</h2><p>消息被消费过后会被清理掉吗？不会。</p><p>消息是被顺序存储在commitlog文件的，且消息大小不定长，所以消息的清理是不可能以消息为单位进行清理的，而是以commitlog文件为单位进行清理的。否则会急剧下降清理效率，并实现逻辑复杂。</p><p>commitlog文件存在一个过期时间，默认为72小时，即三天。除了用户手动清理外，在以下情况下也会被自动清理，无论文件中的消息是否被消费过：</p><ul><li>文件过期，且到达清理时间点（默认为凌晨4点）后，自动清理过期文件</li><li>文件过期，且磁盘空间占用率已达过期清理警戒线（默认75%）后，无论是否达到清理时间点，都会自动清理过期文件</li><li>磁盘占用率达到清理警戒线（默认85%）后，开始按照设定好的规则清理文件，无论是否过期。默认会从最老的文件开始清理</li><li>磁盘占用率达到系统危险警戒线（默认90%）后，Broker将拒绝消息写入</li></ul><blockquote><p>需要注意以下几点：</p><p><em>1</em>）对于<em>RocketMQ</em>系统来说，删除一个<em>1G</em>大小的文件，是一个压力巨大的<em>IO</em>操作。在删除过程中，系统性能会骤然下降。所以，其默认清理时间点为凌晨<em>4</em>点，访问量最小的时间。也正因如果，我们要保障磁盘空间的空闲率，不要使系统出现在其它时间点删除<em>commitlog</em>文件的情况。</p><p><em>2</em>）官方建议<em>RocketMQ</em>服务的<em>Linux</em>文件系统采用<em>ext4</em>。因为对于文件删除操作，<em>ext4</em>要比<em>ext3</em>性能更好</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spirng-cloud </tag>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6046 L1 学习笔记</title>
      <link href="/2023/09/23/2023-9-23-MIT-6046-L1-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/09/23/2023-9-23-MIT-6046-L1-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="MIT6-046算法设计-L1-学习笔记"><a href="#MIT6-046算法设计-L1-学习笔记" class="headerlink" title="MIT6.046算法设计 L1 学习笔记"></a>MIT6.046算法设计 L1 学习笔记</h1><h2 id="区间调度算法-Interval-Scheduling-贪心算法"><a href="#区间调度算法-Interval-Scheduling-贪心算法" class="headerlink" title="区间调度算法 Interval Scheduling / 贪心算法"></a>区间调度算法 Interval Scheduling / 贪心算法</h2><p>区间调度算法属于贪心算法;贪心算法是动态规划DP算法的一个特例,其需要满足更多的条件(整体的最优解可以通过一系列的局部最优解得到),相对的,贪心的效率比DP高</p><h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><p>经典的贪心算法问题 Interval Scheduling（区间调度问题）。 给很多形如 [start, end] 的闭区间，算出这些区间中最多有几个互不相交的区间。</p><p>本质是求这些时间区间的最大不相交子集。</p><h3 id="二、贪心解法"><a href="#二、贪心解法" class="headerlink" title="二、贪心解法"></a>二、贪心解法</h3><p>1.从区间集合R中选择一个区间x,其是在R内结束时间最早的区间</p><p>2.从R中删除所有与x相交的区间</p><p>3.ans_count++,将x从R中剔除,重复1,2;直到R为空</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">intervalSchedule</span><span class="params">(<span class="type">int</span>[][] intvs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intvs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 按 end 升序排序</span></span><br><span class="line">    Arrays.<span class="built_in">sort</span>(intvs, <span class="keyword">new</span> <span class="built_in">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="built_in">compare</span>(<span class="type">int</span>[] a, <span class="type">int</span>[] b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 至少有一个区间不相交</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 排序后，第一个区间就是 x</span></span><br><span class="line">    <span class="type">int</span> x_end = intvs[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] interval : intvs) &#123;</span><br><span class="line">        <span class="type">int</span> start = interval[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= x_end) &#123;</span><br><span class="line">            <span class="comment">// 找到下一个选择的区间了</span></span><br><span class="line">            count++;</span><br><span class="line">            x_end = interval[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么根据事件的结束时间从小到大排就可以获取最大不相交子区间数"><a href="#为什么根据事件的结束时间从小到大排就可以获取最大不相交子区间数" class="headerlink" title="为什么根据事件的结束时间从小到大排就可以获取最大不相交子区间数?"></a>为什么根据事件的结束时间从小到大排就可以获取最大不相交子区间数?</h3><p>因为这个问题符合<strong>贪心选择性质</strong></p><p>我们按时间顺序观察时间轴, 将每个区间画出,按结束时间从小到大对时间切面进行观察</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309231741259.png" alt="image-20230923174111230"></p><p>对于1号,显然其前面不存在与其冲突的区间,其符合要求,同时其终点截断了两个区间,所以这两个区间产生了冲突,将他们排除</p><p>对于2号,3号同理</p><blockquote><p>详细的推理看不太懂….</p><p>假设存在一个最优解，其中包含的区间数量为 n。我们可以证明，按照结束时间从早到晚选择区间的贪心算法可以得到至少 n 个互不相交的区间。</p><p>假设最优解中的第一个区间为 x，结束时间最早，那么贪心算法选择的第一个区间也必然是 x。我们可以将最优解中的第一个区间 x 替换为贪心算法选择的第一个区间，这个新的解仍然是一个合法解，并且包含的区间数量不少于最优解。</p><p>接下来，我们需要证明贪心算法选择的第二个区间也是最优解中的一个区间。假设最优解中的第二个区间为 y，结束时间最早。如果 y 与 x 相交，那么由于贪心算法选择的区间 x 的结束时间最早，所以 y 的结束时间一定晚于 x，即 y 的结束时间晚于 x 的结束时间。由于贪心算法选择区间的性质，我们可以将最优解中的第二个区间 y 替换为贪心算法选择的第二个区间。这样做不会减少互不相交的区间数量。</p><p>以此类推，我们可以将最优解中的每个区间都替换为贪心算法选择的区间，这样得到的新解仍然是一个合法解，并且包含的区间数量不少于最优解。因此，按照结束时间从早到晚选择区间的贪心算法可以得到至少与最优解一样多的互不相交区间。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>recketmq配置dashboard连接问题的解决</title>
      <link href="/2023/09/21/2023-9-22-recketmq%E9%85%8D%E7%BD%AEdashboard%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
      <url>/2023/09/21/2023-9-22-recketmq%E9%85%8D%E7%BD%AEdashboard%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>在配置虚拟机内的rocketmq连接到win10下的dashboard时报错:</p><p><code>java.lang.RuntimeException: org.apache.rocketmq.remoting.exception.RemotingConnectException: connect to &lt;null&gt; failed</code></p><p>尝试一天修改各种配置无果,翌日重新尝试,仔细阅读日志,发现<code>rocketmq RemotingConnectException: connect to [ip:9876] failed</code></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>关闭虚拟机centos的防火墙</p><p>1.查询防火墙状态</p><p><code>systemctl status firewalld</code></p><p>2.关闭防火墙</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld#关闭防火墙</span><br><span class="line">systemctl disable firewalld    #关闭防火墙开机自启</span><br></pre></td></tr></table></figure><p><img src="https://cdn-icons-png.flaticon.com/512/2818/2818757.png" alt="Bug - Free security icons"></p>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ 一二、集群搭建理论与RAID常识</title>
      <link href="/2023/09/21/2023-9-21-rocketMQ%E7%AC%AC%E4%BA%8C%E7%AB%A0-RocketMQ%E5%AE%89%E8%A3%85%E4%B8%8E%E5%90%AF%E5%8A%A8/"/>
      <url>/2023/09/21/2023-9-21-rocketMQ%E7%AC%AC%E4%BA%8C%E7%AB%A0-RocketMQ%E5%AE%89%E8%A3%85%E4%B8%8E%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="第2章-RocketMQ的安装与启动"><a href="#第2章-RocketMQ的安装与启动" class="headerlink" title="第2章 RocketMQ的安装与启动"></a>第2章 RocketMQ的安装与启动</h1><h2 id="三、系统安装与启动与console图形化控制台的安装与启动"><a href="#三、系统安装与启动与console图形化控制台的安装与启动" class="headerlink" title="三、系统安装与启动与console图形化控制台的安装与启动"></a>三、系统安装与启动与console图形化控制台的安装与启动</h2><p>省略实操步骤</p><p><strong>在linux下配置好了broker和NameServer,就是连不上console,试了十来个小时就是连不上,暂时先跳过</strong></p><h2 id="四、集群搭建理论"><a href="#四、集群搭建理论" class="headerlink" title="四、集群搭建理论"></a>四、集群搭建理论</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309211734870.png" alt="image-20230921173407729"></p><h3 id="数据复制与刷盘策略"><a href="#数据复制与刷盘策略" class="headerlink" title="数据复制与刷盘策略"></a>数据复制与刷盘策略</h3><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309211740953.png" alt="image-20230921174026909"></p><h4 id="复制策略"><a href="#复制策略" class="headerlink" title="复制策略"></a>复制策略</h4><p>复制策略是Broker的Master与Slave间的数据同步方式,分为同步复制和异步复制</p><ul><li>同步复制: 消息写入master后，master会等待slave同步数据成功后才向producer返回成功ACK</li><li>异步复制: 消息写入master后，master立即向producer返回成功ACK，无需等待slave同步数据成功</li></ul><h4 id="刷盘策略"><a href="#刷盘策略" class="headerlink" title="刷盘策略"></a>刷盘策略</h4><p>刷盘策略指的是broker中消息的<strong>落盘</strong>方式，即消息发送到broker内存后消息持久化到磁盘的方式。分为同步刷盘与异步刷盘：</p><ul><li><p>同步刷盘：当消息持久化到broker的<strong>磁盘</strong>后才算是消息写入成功。</p></li><li><p>异步刷盘：当消息写入到broker的<strong>内存</strong>后即表示消息写入成功，无需等待消息持久化到磁盘。</p></li></ul><blockquote><p>1)异步刷盘策略会降低系统的写入延迟,RT减小,提高了系统的吞吐量</p><p>2)消息写入到Broker的内存,一般是写入到了PageCache中</p><p>3)对于异步刷盘策略,消息会在写入到PageCache后立即返回成功ack;单并不会立刻落盘,而是等PageCache达到一定量后再落盘</p></blockquote><h3 id="Broker集群模式"><a href="#Broker集群模式" class="headerlink" title="Broker集群模式"></a>Broker集群模式</h3><p>根据Broker集群中各节点间关系不同,其可分为以下类</p><h4 id="1-单Master"><a href="#1-单Master" class="headerlink" title="1.单Master"></a>1.单Master</h4><p>只有一个broker（其本质上就不能称为集群）。这种方式也只能是在测试时使用，生产环境下不能使用，因为存在单点问题。</p><h4 id="2-多Master"><a href="#2-多Master" class="headerlink" title="2.多Master"></a>2.多Master</h4><p>broker集群仅由多个master构成，不存在Slave。同一Topic的各个Queue会平均分布在各个master节点上。</p><ul><li><p>优点：配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10(非常可靠)时，即使机器宕机不可恢复情况下，消息也不几乎会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；</p></li><li><p>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅（不可消费），消息实时性会受到影响。</p></li></ul><blockquote><p> 以上优点的前提是，这些<em>Master</em>都配置了<em>RAID</em>磁盘阵列。如果没有配置，一旦出现某<em>Master</em>宕机，则会发生大量消息丢失的情况。</p></blockquote><h4 id="3-多Master多Slave模式-异步复制"><a href="#3-多Master多Slave模式-异步复制" class="headerlink" title="3.多Master多Slave模式 - 异步复制"></a>3.多Master多Slave模式 - 异步复制</h4><p>broker集群由多个master构成，每个master又配置了多个slave（在配置了RAID磁盘阵列的情况下，一个master一般配置一个slave即可）。master与slave的关系是主备关系，即master负责处理消息的读写请求，而slave仅负责消息的<u>备份</u>与master宕机后的<u>角色切换</u>。</p><p>异步复制即前面所讲的复制策略中的异步复制策略，即消息写入master成功后，master立即向producer返回成功ACK，无需等待向slave同步数据的成功。</p><p>该模式的最大特点之一是，当master宕机后slave能够<strong>自动切换</strong>为master。不过由于slave从master的同步具有短暂的延迟（毫秒级），所以当master宕机后，这种异步复制方式可能会存在少量消息的丢失问题。</p><blockquote><p>Slave从Master同步的延迟越短,其可能丢失的消息越少(因为在同步的过程中如果master发生宕机,同步延迟越短,在宕机中被截断的数据越少)</p></blockquote><h4 id="4-多Master多Slave模式同步双写"><a href="#4-多Master多Slave模式同步双写" class="headerlink" title="4.多Master多Slave模式同步双写"></a>4.多Master多Slave模式同步双写</h4><p>该模式是多Master多Slave模式的同步复制实现。所谓同步双写，指的是消息写入master成功后，master会等待slave同步数据成功后才向producer返回成功ACK，即master与slave<strong>都</strong>要写入成功后才会返回成功ACK，也即双写。</p><p>该模式与异步复制模式相比，优点是消息的安<strong>全性更高</strong>，不存在消息丢失的情况。但单个消息的RT略高，从而导致<strong>性能略低</strong>（大约低10%）。</p><blockquote><p>该模式存在一个大的问题：对于目前的版本，Master宕机后，Slave<strong>不会自动切换</strong>到Master(截止21/7),这种设计决策是为了确保数据的一致性和可靠性。自动切换Slave节点为新的Master节点可能导致数据冲突和不一致性。</p></blockquote><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>一般会为Master配置RAID10磁盘阵列，然后再为其配置一个Slave。即利用了RAID10磁盘阵列的高效、安全性，又解决了可能会影响订阅的问题。</p><blockquote><p><em>1</em>）<em>RAID</em>磁盘阵列的效率要高于<em>Master-Slave</em>集群。因为<em>RAID</em>是硬件支持的,但其搭建成本较高。</p><p><em>2</em>）多<em>Master+RAID</em>阵列，与多<em>Master</em>多<em>Slave</em>集群的区别是什么？</p><ul><li><p>多<em>Master+RAID</em>阵列，其仅仅可以保证数据不丢失，即不影响消息写入，但其<u>可能会影响到消息的订阅</u>。但其执行效率要<strong>远高于</strong>多Master多Slave集群</p></li><li><p>多<em>Master</em>多<em>Slave</em>集群，其不仅可以保证数据不丢失，也不会影响消息订阅。但其运行效率要低于多Master+RAID阵列</p></li></ul></blockquote><h3 id="五、磁盘阵列RAID-补充扩展"><a href="#五、磁盘阵列RAID-补充扩展" class="headerlink" title="五、磁盘阵列RAID(补充扩展)"></a>五、磁盘阵列RAID(补充扩展)</h3><h3 id="1-RAID历史"><a href="#1-RAID历史" class="headerlink" title="1.RAID历史"></a>1.RAID历史</h3><p>RAID 概念于1988年被提出 ，即廉价冗余磁盘阵列。由于当时大容量磁盘比较昂贵， RAID 的基本思想是将多个容量较小、相对廉价的磁盘进行有机组合，从而以较低的成本获得与昂贵大容量磁盘相当的容量、性能、可靠性。随着磁盘成本和价格的不断降低， “廉价” 已经毫无意义。</p><p>因此， RAID 咨询委员会决定用“ 独立 ” 替代 “ 廉价 ” ，于是 RAID 变成了独立磁盘冗余阵列（ Redundant Array of Independent Disks ）。但这仅仅是名称的变化，实质内容没有改变。</p><h3 id="2-RAID等级"><a href="#2-RAID等级" class="headerlink" title="2.RAID等级"></a>2.RAID等级</h3><p>RAID 这种设计思想很快被业界接纳， RAID 技术作为高性能、高可靠的存储技术，得到了非常广泛的应用。 RAID 主要利用镜像、数据条带和数据校验三种技术来获取高性能、可靠性、容错能力和扩展性，根据对这三种技术的使用策略和组合架构，可以把 RAID 分为不同的等级，以满足不同数据应用的需求。</p>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spirng-cloud </tag>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ 一、概述与基本概念</title>
      <link href="/2023/09/17/2023-9-18-rocketMQ%E7%AC%AC%E4%B8%80-%E4%BA%8C%E7%AB%A0-RocketMQ%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/09/17/2023-9-18-rocketMQ%E7%AC%AC%E4%B8%80-%E4%BA%8C%E7%AB%A0-RocketMQ%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-RocketMQ概述"><a href="#第一章-RocketMQ概述" class="headerlink" title="第一章 RocketMQ概述"></a>第一章 RocketMQ概述</h1><h2 id="一-、MQ概述"><a href="#一-、MQ概述" class="headerlink" title="一 、MQ概述"></a>一 、MQ概述</h2><h3 id="MQ简介"><a href="#MQ简介" class="headerlink" title="MQ简介"></a>MQ简介</h3><p>Message Queue消息队列,是一种提供消息队列服务的中间件,也称为消息中间件,是一套提供了信息生产,储存,消费全过程的API软甲系统</p><h3 id="MQ用途"><a href="#MQ用途" class="headerlink" title="MQ用途"></a>MQ用途</h3><h4 id="1-流量削峰"><a href="#1-流量削峰" class="headerlink" title="1.流量削峰"></a><strong>1.流量削峰</strong></h4><p>MQ可以将系统的<strong>超量</strong>请求暂存其中,以便后期系统可以慢慢处理,从而避免了请求的丢失或者系统宕机</p><h4 id="2-异步解耦"><a href="#2-异步解耦" class="headerlink" title="2.异步解耦"></a><strong>2.异步解耦</strong></h4><p>上游系统对下游系统的调用若为同步调用,则会大大降低系统的吞吐量与并发度,且系统耦合度太高;异步调用可以通过在上下游间添加一个<strong>MQ层</strong>来解决这些问题</p><h4 id="3-数据收集"><a href="#3-数据收集" class="headerlink" title="3.数据收集"></a>3.<strong>数据收集</strong></h4><p>分布式系统会产生海量数据流,如:业务日志,监控数据,用户行为等;针对这些数据流进行实时或批量采集汇总,然后对这些数据流进行大数据分析,是当前互联网平台的必备技术,通过MQ完成此类数据收集是最好的选择</p><h1 id="第二章-RocketMQ的安装与启动"><a href="#第二章-RocketMQ的安装与启动" class="headerlink" title="第二章 RocketMQ的安装与启动"></a>第二章 RocketMQ的安装与启动</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1-消息-Message"><a href="#1-消息-Message" class="headerlink" title="1.消息 Message"></a>1.消息 Message</h3><p>消息是消息系统所传输信息的物理载体,生产和消费数据的最小单位,每条消息必须属于一个主题</p><h3 id="2-主题-Topic"><a href="#2-主题-Topic" class="headerlink" title="2.主题 Topic"></a>2.主题 Topic</h3><p>Topic表示一类消息的<strong>集合</strong>，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行<strong>消息订阅的基本单位</strong>。</p><p>一个生产者可以同时发送多种Topic的消息;而一个消费者只对某种特定的Topic感兴趣，即<u>一个消费者只可以订阅和消费一种Topic的消息</u>。</p><h3 id="3-标签-Tag"><a href="#3-标签-Tag" class="headerlink" title="3.标签  Tag"></a>3.标签  Tag</h3><p>Tag是为消息设置的标签,用于区别同一Topic下的不同类型的消息;</p><p><u>即Topic是消息的一级分类,Tag是消息的二级分类</u></p><h3 id="4-队列-Queue"><a href="#4-队列-Queue" class="headerlink" title="4.队列 Queue"></a>4.队列 Queue</h3><p>存储消息的物理实体,一个Topic中可以包含多个Queue(一个Queue中的消息只能被一个消费者组中的一个消费者消费;一个Queue中的消息不允许同一个消费者组的多个消费者同时消费),每个Queue中存放的就是该Topic的消息</p><p>一个Topic的Queue也被称为一个Topic中消息的分区</p><blockquote><p>分片:在RocketMQ中,分片指的是存放响应Topic的Broker数量;每个分片会创建相应数量的分区,即Queue,每个Queue的大小应该是相同的</p></blockquote><h3 id="5-消息标示-MessageId-Key"><a href="#5-消息标示-MessageId-Key" class="headerlink" title="5.消息标示 MessageId/Key"></a>5.消息标示 MessageId/Key</h3><p>RocketMQ中每个消息拥有唯一的Messageld，且可以携带具有业务标识的Key，以方使对消息的查询。不过需要注意的是，MessageId有两个:在生产者send()消息时会自动生成一个Messageld (msgld),当消息到达Broker后,其也会自动生成一个MessageId(offsetId)</p><ul><li>msgld: 田producer端生成，具生成规则为:</li></ul><p>​        <strong>producerIp +进程pid + MessageclientIDSetter类的c1assLoader的hashcode +当前时间+ AutomicInteger自增计数器</strong></p><ul><li>offsetMsgld:由broker端生成，其生成规则为: brokerIp +物理分区的offset(Queue中的偏移量)</li><li>key:由用户指定的业务相关的唯一标识</li></ul><h2 id="二、系统架构"><a href="#二、系统架构" class="headerlink" title="二、系统架构"></a>二、系统架构</h2><h3 id="1-Producer-生产者"><a href="#1-Producer-生产者" class="headerlink" title="1.Producer  生产者"></a>1.Producer  生产者</h3><p>消息生产者,负责生产消息,其通过MQ的负载均衡模块选择响应的Broker集群队列进行消息投递,投递过程支持快速失败且低延迟</p><p>RocketMQ中消息生产者都是以<strong>生产者组</strong>的形式出现的,生产者组是同一类生产者的集合,这类Producer<strong>都能(不是仅能)</strong>发送相同Topic类型的消息</p><h3 id="2-Consumer-消费者"><a href="#2-Consumer-消费者" class="headerlink" title="2.Consumer 消费者"></a>2.Consumer 消费者</h3><p>消息消费者,负责消费消息,一个消费者会从Broker服务器中获取消息,并对消息进行相关业务处理</p><p>RocketMQ中的消息消费者都是以<strong>消费者组</strong>的形式出现的,其是同一类消费者的集合,这类Consumer消费的是同一个Topic类型的消息,消费者组的存在使得<strong>负载均衡</strong>(指的是将一个Topic中不同的Queue平均分配给同一个Consumer Group的不同的Consumer,并不是Message的消息负载均衡)和<strong>容错</strong>(一个Consumer挂了,该消费者组中的其他Consumer可以接着消费原Consumer消费的Queue)的实现变得容易</p><blockquote><p>同一个生产者可以生产多种不同消息,而同一个消费者只能生产同一种消息</p><p>不过一个Topic类型的消息可以同时呗多个消费者组同时消费</p></blockquote><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309181321830.png" alt="image-20230918132127582"></p><blockquote><p>注意:</p><p>1)一个消费者组中的消费者必须订阅完全相同的Topic</p><p>2)消费者组只能消费一个Topic的消息,不能同时消费多个Topic消息</p></blockquote><h3 id="3-Name-Server"><a href="#3-Name-Server" class="headerlink" title="3.Name Server"></a>3.Name Server</h3><h4 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h4><p>NameServer是一个Broker与Topic路由的注册中心,支持Broker的动态注册与发现</p><p>主要包括两个功能</p><ul><li><strong>Broker管理</strong>:接受Broker集群的注册信息并保存下来作为路由信息的基本数据;提供心跳检测</li><li><strong>路由信息管理</strong>:每个NameServer中都保存着Broker集群的整个路由信息和用于客户端查询的队列信息;Producer和Consumer通过NameServer可以获取整个Broker集群的路由信息,从而进行消息的投递和消费</li></ul><h4 id="路由注册"><a href="#路由注册" class="headerlink" title="路由注册"></a>路由注册</h4><p>NameServer通常是集群部署,不过NameServer是无状态的(集群中各个节点无差异),集群中各节点间不进行相互的信息通讯</p><p>节点中的数据是如何同步的呢?</p><p>在Broker结点启动时,轮询NameServer结点建立长连接,发起注册请求,在NameServer内部维护者一个Broker列表用来动态存储Broker信息</p><blockquote><p>注意 这是与其他如zk,Eureka,Nacos等注册中心不同的</p><p>NameServer的无状态方式的优缺点</p><ul><li><p>优点:搭建简单,扩容简单-</p></li><li><p>缺点:对于Broker,必须要明确指示所有NameServer地址,否则为指出的NameServer将不会被注册;因此,NameServer并不能随意扩容,因为若Broker不重新配置,新增的NameServer对于Broker不可见</p></li></ul></blockquote><p>Broker节点为了维持自己的存活,为了维护与NameServer的长连接,会将最新消息以<strong>心跳包</strong>的方式上报给NameServer,30s一次;NameServer在收到心跳包后会更新心跳时间戳,记录这个Broker的最新存活时间</p><h4 id="路由剔除"><a href="#路由剔除" class="headerlink" title="路由剔除"></a>路由剔除</h4><p>若NameServer未及时收到Broker的心跳,NameServer可能会将其从Broker列表中剔除</p><p>NameServer每10秒扫描一次Broker表,若发现Broker的心跳时间戳距今超过120s则判定其失效,将其从Broker列表中剔除</p><blockquote><p>扩展:对于Rocket的日常运维,需要暂停Broker的工作,管理员需要怎么做?</p><p>OP需要将Broker的读写权限暂时禁用,若client向broker发送请求,则会收到broker的NO_PERMISSION响应,然后client会向其他Broker发送重试请求</p><p>当OP发现这个Broker没有流量后,再将其关闭,实现Broker从NameServer中的移除</p></blockquote><h4 id="路由发现"><a href="#路由发现" class="headerlink" title="路由发现"></a>路由发现</h4><p>RocketMQ的路由发现采用pull模型;NameServer不会主动推送Topic变动,而是client定时拉去topic最新路由;客户端默认每30s拉取一次最新路由</p><blockquote><p>拓展:</p><p>1)Push模型: 主动推送模型/发布-订阅模型</p><p>其需要维护一个长连接,<strong>实时性好</strong>,但<strong>资源消耗大</strong></p><p>​    适用场景:</p><ul><li>实时性要求高</li><li>Client数量不多,Server数据变化频繁</li></ul><p>2)Pull模型: 拉取模型</p><p>缺点:实时性较差,资源消耗较小</p><p>3)Long Polling模型: 长轮询模型</p><p>是对Push与Pull模型的融合,取长补短,对二者进行了折中</p></blockquote><h4 id="客户端NameServer选择策略"><a href="#客户端NameServer选择策略" class="headerlink" title="客户端NameServer选择策略"></a>客户端NameServer选择策略</h4><p>客户端在配置时必须要写上NameServer集群的地址，那么客户端到底连接的是哪个NameServer节点呢?</p><p>客户端首先会生产一个随机数，然后再与NameServer节点数量取模，此时得到的就是所要连接的节点索引，然后就会进行连接。如果连接失败，则会采用round-robin策略，逐个尝试着去连接其它节点。</p><p><u>首先采用<strong>随机策略</strong>进行选择,失败后采取<strong>轮询策略</strong></u></p><h3 id="4-Broker"><a href="#4-Broker" class="headerlink" title="4.Broker"></a>4.Broker</h3><h4 id="功能介绍-1"><a href="#功能介绍-1" class="headerlink" title="功能介绍"></a>功能介绍</h4><p>Broker充当消息中转角色,负责存储,转发消息;Broker在RocketMQ系统中负责接收并存储从生产者发来的消息,同时为消费者的拉取做准备(中介呗);Broker同时存储着消息相关的元数据,包括消费者组消费进度offset,主题,队列等</p><h4 id="模块构成"><a href="#模块构成" class="headerlink" title="模块构成"></a>模块构成</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309181430000.png" alt="image-20230918143047892"></p><p><strong>Remoting Module</strong>：整个Broker的实体，负责处理来自clients端的请求。而这个Broker实体则由以下模块构成。</p><p><strong>Client Manager</strong>：客户端管理器。负责接收、解析客户端(Producer/Consumer)请求，管理客户端。例如，维护Consumer的Topic订阅信息</p><p><strong>Store Service</strong>：存储服务。提供方便简单的API接口，处理消息存储到物理硬盘和消息查询功能。</p><p><strong>HA Service</strong>：高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能。</p><p><strong>Index Service</strong>：索引服务。根据特定的Message key，对投递到Broker的消息进行索引服务，同时也提供根据Message Key对消息进行快速查询的功能。</p><h4 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309181440907.png" alt="image-20230918144029773"></p><p>为了增强Broker性能与吞吐量，Broker一般都是以集群形式出现的。各集群节点中可能存放着相同Topic的不同Queue。不过，这里有个问题，如果某Broker节点宕机，如何保证数据不丢失呢？其解决方案是，将每个Broker集群节点进行横向扩展，即将Broker节点再建为一个HA集群，解决单点问题。</p><p>Broker节点集群是一个主从集群，即集群中具有Master与Slave两种角色。Master负责处理读写操作请求，Slave负责对Master中的数据进行备份。当Master挂掉了，Slave则会自动切换为Master去工作。所以这个Broker集群是主备集群。一个Master可以包含多个Slave，但一个Slave只能隶属于一个Master。</p><p>Master与Slave 的对应关系是通过指定相同的BrokerName、不同的BrokerId 来确定的。BrokerId为0表示Master，非0表示Slave。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。</p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>1）启动NameServer，NameServer启动后开始监听端口，等待Broker、Producer、Consumer连接。</p><p>2）启动Broker时，Broker会与所有的NameServer建立并保持长连接，然后每30秒向NameServer定时发送心跳包。</p><p>3）发送消息前，可以先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，当然，在创建Topic时也会将Topic与Broker的关系写入到NameServer中。不过，这步是可选的，也可以在发送消息时自动创建Topic。</p><blockquote><p>Topic的<strong>手动</strong>创建有两种方式:</p><ul><li>集群模式:该模式下创建的Topic在该集群中,所有Broker中Queue的数量是<strong>相同</strong>的</li><li>Broker模式:该模式下创建的Topic在该集群中,所有Broker中Queue的数量可以<strong>不同</strong></li></ul><p><strong>自动</strong>创建Topic时,默认采用Broker模式,会为每个Broker默认创建4个Queue</p></blockquote><p>4）Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取路由信息，即当前发送的Topic消息的Queue与Broker的地址（IP+Port）的映射关系。然后根据算法策略从队选择一个Queue，与队列所在的Broker建立长连接从而向Broker发消息。当然，在获取到路由信息后，Producer会首先将路由信息缓存到本地，再每30秒从NameServer更新一次路由信息。</p><p>5）Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取其所订阅Topic的路由信息，然后根据算法策略从路由信息中获取到其所要消费的Queue，然后直接跟Broker建立长连接，开始消费其中的消息。Consumer在获取到路由信息后，同样也会每30秒从NameServer更新一次路由信息。不过不同于Producer的是，Consumer还会向Broker发送心跳，以确保Broker的存活状态。</p><p><strong>读/写队列</strong></p><p>从物理上来讲，读/写队列是同一个队列。所以，不存在读/写队列数据同步问题。读/写队列是逻辑上进行区分的概念。一般情况下，读/写队列数量是相同的。</p><p>例如，创建Topic时设置的写队列数量为8，读队列数量为4，此时系统会创建8个Queue，分别是0 1 2 3 4 5 6 7。Producer会将消息写入到这8个队列，但Consumer只会消费0 1 2 3这4个队列中的消息，4 5 6 7中的消息是不会被消费到的。</p><p>这样设计的目的是为了，方便Topic的Queue的缩容。</p><p>例如，原来创建的Topic中包含16个Queue，如何能够使其Queue缩容为8个，还不会丢失消息？可以动态修改写队列数量为8，读队列数量不变。此时新的消息只能写入到前8个队列，而消费都消费的却是16个队列中的数据。当发现后8个Queue中的消息消费完毕后，就可以再将读队列数量动态设置为8。整个缩容过程，没有丢失任何消息。</p><p>perm用于设置对当前创建Topic的操作权限：2表示只写，4表示只读，6表示读写</p>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spirng-cloud </tag>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis高级入门篇</title>
      <link href="/2023/09/16/2023-9-17-Redis%E9%AB%98%E7%BA%A7%E7%AF%87%E5%85%A5%E9%97%A8/"/>
      <url>/2023/09/16/2023-9-17-Redis%E9%AB%98%E7%BA%A7%E7%AF%87%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis入门高级入门篇"><a href="#Redis入门高级入门篇" class="headerlink" title="Redis入门高级入门篇"></a>Redis入门高级入门篇</h1><h2 id="单点Redis的问题"><a href="#单点Redis的问题" class="headerlink" title="单点Redis的问题"></a>单点Redis的问题</h2><ul><li>数据丢失问题 —-Redis数据持久化</li><li>并发能力问题 —-主从集群,读写分离</li><li>故障恢复问题 —-Redis哨兵,健康监测/自动恢复</li><li>存储能力问题 —-搭建分片集群,利用插槽机制动态扩容</li></ul><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="1-RDB-Redis快照"><a href="#1-RDB-Redis快照" class="headerlink" title="1.RDB(Redis快照)"></a>1.RDB(Redis快照)</h2><p>RDB把内存中的所有数据都记录到磁盘中</p><h4 id="执行时机"><a href="#执行时机" class="headerlink" title="执行时机"></a><strong>执行时机</strong></h4><p>RDB持久化在四种情况下会执行：</p><ul><li>执行save命令</li><li>执行bgsave命令</li><li>Redis停机时</li><li>触发RDB条件时</li></ul><p><strong>1)save命令</strong></p><p>save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</p><p><strong>2)bgsave命令</strong></p><p>这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</p><p>其开始时会fork主进程得到子进程,子进程共享主进程内的内存数据,完成fork后读取内存数据并写入RDB文件</p><p> fork采用的是copy-on-write技术</p><ul><li><p>当主进程执行读操作时,访问共享内存</p></li><li><p>当主进程执行写操作时,则会拷贝一份数据再执行写操作</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309162036886.png" alt="image-20230916203610778"></p></li></ul><p><strong>3）停机时</strong></p><p>Redis停机时会自动执行一次save命令，实现RDB持久化。</p><p><strong>4）触发RDB条件</strong></p><p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save &quot;&quot; 则表示禁用RDB</span></span><br><span class="line"><span class="attr">save</span> <span class="string">900 1  </span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 10  </span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000 </span></span><br></pre></td></tr></table></figure><p>RDB的其它配置也可以在redis.conf文件中设置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span></span><br><span class="line"><span class="attr">rdbcompression</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># RDB文件名称</span></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">dump.rdb  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 文件保存的路径目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">./ </span></span><br></pre></td></tr></table></figure><h3 id="RDB缺点"><a href="#RDB缺点" class="headerlink" title="RDB缺点"></a>RDB缺点</h3><ul><li>执行间隔长,两次RDB之间数据写入有丢失风险</li><li>fork子进程,压缩,写出RDB文件都需要消耗资源</li></ul><h2 id="2-AOF-追加文件"><a href="#2-AOF-追加文件" class="headerlink" title="2.AOF(追加文件)"></a>2.AOF(追加文件)</h2><p>Redis处理的每一个写命令都会记录在AOF文件,所以看做是某种命令日志文件</p><h3 id="AOF配置"><a href="#AOF配置" class="headerlink" title="AOF配置"></a>AOF配置</h3><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否开启AOF功能，默认是no</span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># AOF文件的名称</span></span><br><span class="line"><span class="attr">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span></span><br></pre></td></tr></table></figure><p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示每执行一次写命令，立即记录到AOF文件</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">always </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">everysec </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">no</span></span><br></pre></td></tr></table></figure><p>三种策略的对比:</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309162043730.png" alt="image-20230916204345695"></p><h3 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h3><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309162049263.png" alt="image-20230916204916235"></p><p>如图，AOF原本有三个命令，但是<code>set num 123 和 set num 666</code>都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。</p><p>所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p><p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AOF文件比上次文件 增长超过多少百分比则触发重写</span></span><br><span class="line"><span class="attr">auto-aof-rewrite-percentage</span> <span class="string">100</span></span><br><span class="line"><span class="comment"># AOF文件体积最小多大以上才触发重写 </span></span><br><span class="line"><span class="attr">auto-aof-rewrite-min-size</span> <span class="string">64mb </span></span><br></pre></td></tr></table></figure><h2 id="RDB与AOF对比"><a href="#RDB与AOF对比" class="headerlink" title="RDB与AOF对比"></a>RDB与AOF对比</h2><p>在实际应用中要结合优缺点<strong>混合</strong>使用</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309162050972.png" alt="image-20230916205029924"></p><h2 id="Redis主从"><a href="#Redis主从" class="headerlink" title="Redis主从"></a>Redis主从</h2><p>单节点redis的并发能力是有上限的,需要通过搭建主从集群实现读写分离</p><h3 id="主从间数据同步原理"><a href="#主从间数据同步原理" class="headerlink" title="主从间数据同步原理"></a>主从间数据同步原理</h3><ul><li>主从第一次同步是<strong>全量同步</strong></li></ul><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309162127955.png" alt="image-20230916212735891"></p><p>master是如何判断是否是第一次同步呢?</p><p>​    <strong>Replication Id</strong>:其是数据集的id,每个master都有唯一的repliid,slave则会集成master结点的replid</p><p>​    <strong>offset</strong>:偏移量,随着repl_backlog中数据增多而增大</p><p>所以slave的数据同步必须要向master生命自己的reliid和offset以供master判断需要同步哪些数据</p><ul><li>slave重启后同步,执行<strong>增量同步</strong></li></ul><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309162145817.png" alt="image-20230916214538754"></p><p><strong>注意:repl_baklog大小有上限,写满后会覆盖最早的数据,如果slave断开时间过久,导致尚未被备份的数据被覆盖,则无法基于log做增量同步,只能再次进行全量同步</strong></p><h4 id="Redis主从集群的优化"><a href="#Redis主从集群的优化" class="headerlink" title="Redis主从集群的优化"></a>Redis主从集群的优化</h4><ul><li>在master中配置repl-diskless-sync yse启动无磁盘复制,避免全量同步时的磁盘io</li><li>Redis单节点上的内存占用不要太大,减少RDB导致的过多磁盘IO</li><li>适当提高repl_baklog的大小,发现从节点宕机时尽快实现故障恢复,尽量避免进行全量恢复</li><li>限制一个master上的slave数量,如果slave确实多,可以采用主-从-从链式(从节点A是相对于其从节点B的master结点)结构,减轻master压力</li></ul><h2 id="Redis哨兵"><a href="#Redis哨兵" class="headerlink" title="Redis哨兵"></a>Redis哨兵</h2><h3 id="哨兵-sentinel-的作用"><a href="#哨兵-sentinel-的作用" class="headerlink" title="哨兵(sentinel)的作用"></a>哨兵(sentinel)的作用</h3><ul><li><strong>监控</strong>:Sentinel会不断检查master和slave是否按照预期工作</li><li><strong>自动故障恢复</strong>:如果master故障,Sentinel会将一个slave提升为master,当故障实例恢复后也是以新的master为主</li><li><strong>通知</strong>:Sentinel充当Redis客户端的服务发现来源,当集群发生故障转移时,会将最新的消息推送给Redis的客户端</li></ul><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309171228366.png" alt="image-20230917122803281"></p><h3 id="服务状态监控"><a href="#服务状态监控" class="headerlink" title="服务状态监控"></a>服务状态监控</h3><p>Sentinel基于心跳机制检测服务状态,每隔1s向集群的每个实例发送ping指令</p><ul><li>主观下线:如果某sentinel节点发现某实例未在规定时间响应,则认定该实例主观下线</li><li>客观下线:若超过指定数量quorum的sentinel都认为该实例主观下线,则该实例客观下线(quorum值最好超过sentinel实例数量的一半)</li></ul><h3 id="如何选举新的master"><a href="#如何选举新的master" class="headerlink" title="如何选举新的master"></a>如何选举新的master</h3><p><strong>选举依据</strong></p><ul><li>首先判断slave与master结点断开时间的长短,如果超过指定值,就会排除该slave结点</li><li>然后判断slave结点的slave-priority值,越小优先局越高,若为0则用不参加选举</li><li>若slave-priority值一样,则判断slave结点的offset值,越大说明数据越新,优先级越高</li></ul><h3 id="如何实现故障转移"><a href="#如何实现故障转移" class="headerlink" title="如何实现故障转移"></a>如何实现故障转移</h3><ul><li>选定一个slave作为新的master,执行slaveof no one</li><li>让所有节点执行slaveof 新master</li><li>修改故障节点配置,添加slaveof 新master</li></ul><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309171234367.png" alt="image-20230917123410283"></p><h2 id="Redis分片集群"><a href="#Redis分片集群" class="headerlink" title="Redis分片集群"></a>Redis分片集群</h2><h3 id="分片集群结构"><a href="#分片集群结构" class="headerlink" title="分片集群结构"></a>分片集群结构</h3><p>主从和哨兵可以解决高可用,高并发读的问题,但是依然没有解决海量数据存储和高并发写的问题</p><p>使用分片集群可以解决上述问题,其特征如下</p><ul><li>集群中有多个master,每个master保存不同数据</li><li>每个master都可以拥有多个slave结点</li><li>master之间通过ping检测彼此健康状态</li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spirng-cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>seata入门笔记</title>
      <link href="/2023/09/14/2023-9-14-seata%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/09/14/2023-9-14-seata%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="分布式事务理论基础"><a href="#分布式事务理论基础" class="headerlink" title="分布式事务理论基础:"></a>分布式事务理论基础:</h2><h4 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理:"></a>CAP定理:</h4><p>分布式系统结点通过网络连接,一定会出现分区问题P,这时系统的一致性C和可用性A就无法同时满足</p><h4 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论:"></a>BASE理论:</h4><p>是对CAP的一种解决思路,包括基本可用BA(允许损失部分可用来保证核心可用),软状态SS(中间状态),和最终一致性(在经过软状态后最终数据一致)</p><h4 id="解决分布式事务问题的思想"><a href="#解决分布式事务问题的思想" class="headerlink" title="解决分布式事务问题的思想:"></a>解决分布式事务问题的思想:</h4><p>AP模式:各个子事务分别提交,允许结果不一致,通过弥补措施实现最后结果一致</p><p>CP模式:各个子事务执行后相互等待,同时提交同时回滚,实现强一致,但在等待的过程中事务会变为弱可用状态</p><h4 id="解决分布式事务问题的模型"><a href="#解决分布式事务问题的模型" class="headerlink" title="解决分布式事务问题的模型:"></a>解决分布式事务问题的模型:</h4><p>全局事务:指整个分布式事务</p><p>分支事务:分布式事务中包含的每个子系统的事务</p><h3 id="初识Seata"><a href="#初识Seata" class="headerlink" title="初识Seata"></a>初识<a href="https://seata.io/">Seata</a></h3><h4 id="Seata中重要的三个角色-Seata架构"><a href="#Seata中重要的三个角色-Seata架构" class="headerlink" title="Seata中重要的三个角色/Seata架构"></a>Seata中重要的三个角色/Seata架构</h4><ul><li><p>事务协调者TC:维护全局和分支事务的状态</p></li><li><p>事务管理器TM:定义全局事务的范围,开始全局事务,提交或回滚全局事务</p></li><li><p>资源管理器RM:管理分支事务处理的资源,于TC交谈来注册分支事务和报告分支事务的状态,并驱动分支事务或回滚</p></li></ul><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202309141708797.png" alt="image-20230914170846702"></p><h3 id="部署TC服务"><a href="#部署TC服务" class="headerlink" title="部署TC服务"></a>部署TC服务</h3><h4 id="1-修改配置"><a href="#1-修改配置" class="headerlink" title="1.修改配置"></a>1.修改配置</h4><p>修改conf目录下的registry.conf文件：</p><p>内容如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">registry</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">  # tc服务的注册中心类，这里选择nacos，也可以是eureka、zookeeper等</span></span><br><span class="line">  <span class="attr">type</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">nacos</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">    # seata tc 服务注册到 nacos的服务名称，可以自定义</span></span><br><span class="line">    <span class="attr">application</span> = <span class="string">&quot;seata-tc-server&quot;</span></span><br><span class="line">    <span class="attr">serverAddr</span> = <span class="string">&quot;127.0.0.1:8848&quot;</span></span><br><span class="line">    <span class="attr">group</span> = <span class="string">&quot;DEFAULT_GROUP&quot;</span></span><br><span class="line">    <span class="attr">namespace</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">cluster</span> = <span class="string">&quot;SH&quot;</span></span><br><span class="line">    <span class="attr">username</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    <span class="attr">password</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">config</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">  # 读取tc服务端的配置文件的方式，这里是从nacos配置中心读取，这样如果tc是集群，可以共享配置</span></span><br><span class="line">  <span class="attr">type</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line"><span class="comment">  # 配置nacos地址等信息</span></span><br><span class="line">  <span class="attr">nacos</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">serverAddr</span> = <span class="string">&quot;127.0.0.1:8848&quot;</span></span><br><span class="line">    <span class="attr">namespace</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">group</span> = <span class="string">&quot;SEATA_GROUP&quot;</span></span><br><span class="line">    <span class="attr">username</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    <span class="attr">password</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    <span class="attr">dataId</span> = <span class="string">&quot;seataServer.properties&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="2-在nacos添加配置"><a href="#2-在nacos添加配置" class="headerlink" title="2.在nacos添加配置"></a>2.在nacos添加配置</h4><p>特别注意，为了让tc服务的集群可以共享配置，我们选择了nacos作为统一配置中心。因此服务端配置文件seataServer.properties文件需要在nacos中配好。</p><p>配置内容如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据存储方式，db代表数据库</span></span><br><span class="line"><span class="attr">store.mode</span>=<span class="string">db</span></span><br><span class="line"><span class="attr">store.db.datasource</span>=<span class="string">druid</span></span><br><span class="line"><span class="attr">store.db.dbType</span>=<span class="string">mysql</span></span><br><span class="line"><span class="attr">store.db.driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">store.db.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/seata?useUnicode=true&amp;rewriteBatchedStatements=true</span></span><br><span class="line"><span class="attr">store.db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">store.db.password</span>=<span class="string">1234</span></span><br><span class="line"><span class="attr">store.db.minConn</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">store.db.maxConn</span>=<span class="string">30</span></span><br><span class="line"><span class="attr">store.db.globalTable</span>=<span class="string">global_table</span></span><br><span class="line"><span class="attr">store.db.branchTable</span>=<span class="string">branch_table</span></span><br><span class="line"><span class="attr">store.db.queryLimit</span>=<span class="string">100</span></span><br><span class="line"><span class="attr">store.db.lockTable</span>=<span class="string">lock_table</span></span><br><span class="line"><span class="attr">store.db.maxWait</span>=<span class="string">5000</span></span><br><span class="line"><span class="comment"># 事务、日志等配置</span></span><br><span class="line"><span class="attr">server.recovery.committingRetryPeriod</span>=<span class="string">1000</span></span><br><span class="line"><span class="attr">server.recovery.asynCommittingRetryPeriod</span>=<span class="string">1000</span></span><br><span class="line"><span class="attr">server.recovery.rollbackingRetryPeriod</span>=<span class="string">1000</span></span><br><span class="line"><span class="attr">server.recovery.timeoutRetryPeriod</span>=<span class="string">1000</span></span><br><span class="line"><span class="attr">server.maxCommitRetryTimeout</span>=<span class="string">-1</span></span><br><span class="line"><span class="attr">server.maxRollbackRetryTimeout</span>=<span class="string">-1</span></span><br><span class="line"><span class="attr">server.rollbackRetryTimeoutUnlockEnable</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">server.undo.logSaveDays</span>=<span class="string">7</span></span><br><span class="line"><span class="attr">server.undo.logDeletePeriod</span>=<span class="string">86400000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 客户端与服务端传输方式</span></span><br><span class="line"><span class="attr">transport.serialization</span>=<span class="string">seata</span></span><br><span class="line"><span class="attr">transport.compressor</span>=<span class="string">none</span></span><br><span class="line"><span class="comment"># 关闭metrics功能，提高性能</span></span><br><span class="line"><span class="attr">metrics.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">metrics.registryType</span>=<span class="string">compact</span></span><br><span class="line"><span class="attr">metrics.exporterList</span>=<span class="string">prometheus</span></span><br><span class="line"><span class="attr">metrics.exporterPrometheusPort</span>=<span class="string">9898</span></span><br></pre></td></tr></table></figure><p>==其中的数据库地址、用户名、密码都需要修改成自己的数据库信息==</p><h4 id="3-创建数据库表"><a href="#3-创建数据库表" class="headerlink" title="3.创建数据库表"></a>3.创建数据库表</h4><p>特别注意：tc服务在管理分布式事务时，需要记录事务相关数据到数据库中，你需要提前创建好这些表。</p><p>新建一个名为seata的数据库，运行资料提供的sql文件：</p><p>这些表主要记录全局事务、分支事务、全局锁信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">SET NAMES utf8mb4;</span><br><span class="line">SET FOREIGN_KEY_CHECKS = 0;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- 分支事务表</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `branch_table`;</span><br><span class="line">CREATE TABLE `branch_table`  (</span><br><span class="line">  `branch_id` bigint(20) NOT NULL,</span><br><span class="line">  `xid` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</span><br><span class="line">  `transaction_id` bigint(20) NULL DEFAULT NULL,</span><br><span class="line">  `resource_group_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `resource_id` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `branch_type` varchar(8) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `status` tinyint(4) NULL DEFAULT NULL,</span><br><span class="line">  `client_id` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `application_data` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `gmt_create` datetime(6) NULL DEFAULT NULL,</span><br><span class="line">  `gmt_modified` datetime(6) NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`branch_id`) USING BTREE,</span><br><span class="line">  INDEX `idx_xid`(`xid`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- 全局事务表</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `global_table`;</span><br><span class="line">CREATE TABLE `global_table`  (</span><br><span class="line">  `xid` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</span><br><span class="line">  `transaction_id` bigint(20) NULL DEFAULT NULL,</span><br><span class="line">  `status` tinyint(4) NOT NULL,</span><br><span class="line">  `application_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `transaction_service_group` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `transaction_name` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `timeout` int(11) NULL DEFAULT NULL,</span><br><span class="line">  `begin_time` bigint(20) NULL DEFAULT NULL,</span><br><span class="line">  `application_data` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `gmt_create` datetime NULL DEFAULT NULL,</span><br><span class="line">  `gmt_modified` datetime NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`xid`) USING BTREE,</span><br><span class="line">  INDEX `idx_gmt_modified_status`(`gmt_modified`, `status`) USING BTREE,</span><br><span class="line">  INDEX `idx_transaction_id`(`transaction_id`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;</span><br><span class="line"></span><br><span class="line">SET FOREIGN_KEY_CHECKS = 1;</span><br></pre></td></tr></table></figure><h4 id="4-启动TC服务"><a href="#4-启动TC服务" class="headerlink" title="4.启动TC服务"></a>4.启动TC服务</h4><p>进入bin目录，运行其中的seata-server.bat即可,启动成功后，seata-server应该已经注册到nacos注册中心了。</p><p>打开浏览器，访问nacos地址：<a href="http://localhost:8848，然后进入服务列表页面，可以看到seata-tc-server的信息">http://localhost:8848，然后进入服务列表页面，可以看到seata-tc-server的信息</a></p><h3 id="微服务集成Seata"><a href="#微服务集成Seata" class="headerlink" title="微服务集成Seata"></a>微服务集成Seata</h3><h4 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--版本较低，1.3.0，因此排除--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--seata starter 采用1.4.2版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;seata.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-修改配置文件-让微服务通过注册中心找到seata-tc-server"><a href="#2-修改配置文件-让微服务通过注册中心找到seata-tc-server" class="headerlink" title="2.修改配置文件,让微服务通过注册中心找到seata-tc-server"></a>2.修改配置文件,让微服务通过注册中心找到seata-tc-server</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">registry:</span> <span class="comment"># TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址</span></span><br><span class="line">    <span class="comment"># 参考tc服务自己的registry.conf中的配置</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span> <span class="comment"># tc</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-tc-server</span> <span class="comment"># tc服务在nacos中的服务名称</span></span><br><span class="line">      <span class="attr">cluster:</span> <span class="string">SH</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">seata-demo</span> <span class="comment"># 事务组，根据这个获取tc服务的cluster名称</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span> <span class="comment"># 事务组与TC服务cluster的映射关系</span></span><br><span class="line">      <span class="attr">seata-demo:</span> <span class="string">SH</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spirng-cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23/7/20 算法每日一题</title>
      <link href="/2023/07/20/2023-7-20-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/07/20/2023-7-20-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目1-小红的环形字符串"><a href="#题目1-小红的环形字符串" class="headerlink" title="题目1:小红的环形字符串"></a>题目1:<a href="https://ac.nowcoder.com/acm/contest/60456/A">小红的环形字符串</a></h2><p>小红拿到了一个环形字符串s。所谓环形字符串，指首尾相接的字符串。<br>小红想顺时针截取其中一段连续子串正好等于t，一共有多少种截法？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">2</span>*N],s1[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;s1;</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//直接倍增构造一个伪环形串</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len;i&lt;<span class="number">2</span>*len;i++) s[i]=s[i-len];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="built_in">strlen</span>(s1);j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i+j]!=s1[j])</span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2-相邻不同数字的标记"><a href="#题目2-相邻不同数字的标记" class="headerlink" title="题目2:相邻不同数字的标记"></a>题目2:<a href="https://ac.nowcoder.com/acm/contest/60456/B">相邻不同数字的标记</a></h2><p>小红拿到了一个数组，每个数字被染成了红色或蓝色。</p><p>小红有很多次操作，每次操作可以选择两个相邻的不同颜色的数字标记，并获得它们数字之和的得分。已经被标记的数字无法再次标记。<br>小红想知道，自己最多能获得多少分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dp[i]表示就计算到i时的最大得分</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="type">char</span> c=s[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;t&lt;n;t++)</span><br><span class="line">        <span class="keyword">if</span>(c!=s[t])</span><br><span class="line">        &#123;</span><br><span class="line">            dp[t]=a[t]+a[t<span class="number">-1</span>];</span><br><span class="line">            c=s[t];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    t++;</span><br><span class="line">    <span class="keyword">for</span>(;t&lt;n;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c==s[t]) dp[t]=dp[t<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            c=s[t];</span><br><span class="line">            dp[t]=<span class="built_in">max</span>(dp[t<span class="number">-1</span>],dp[t<span class="number">-2</span>]+a[t]+a[t<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/7/18 算法每日一题</title>
      <link href="/2023/07/18/2023-7-18-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/07/18/2023-7-18-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目1-moon"><a href="#题目1-moon" class="headerlink" title="题目1:moon"></a>题目1:<a href="https://ac.nowcoder.com/acm/contest/58833/B">moon</a></h2><h5 id="你搁这出脑筋急转弯呢T-T"><a href="#你搁这出脑筋急转弯呢T-T" class="headerlink" title="你搁这出脑筋急转弯呢T_T"></a>你搁这出脑筋急转弯呢T_T</h5><p>给出一棵以 1 为根的有根树，一开始每个节点都是白色的。David 和 Adam 在树上博弈，David 先手，每次每个人需要选择树上一个白色的点，并把这个点以及其到根路径上的所有点染成黑色。无法操作的人输。</p><p>假定两人均绝顶聪明，你需要求出谁会获胜。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">// using namespace std;</span></span><br><span class="line"><span class="comment">// const int N=1e5+10;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int a[N]=&#123;0&#125;;</span></span><br><span class="line"><span class="comment">// bool st[N]=&#123;false&#125;;</span></span><br><span class="line"><span class="comment">// int n;</span></span><br><span class="line"><span class="comment">// int ans=0;//操作次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void fun(int v)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     if(a[v]!=-1&amp;&amp;!st[v])</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         n--;</span></span><br><span class="line"><span class="comment">//         st[v]==true;</span></span><br><span class="line"><span class="comment">//         n++;</span></span><br><span class="line"><span class="comment">//         fun(a[v]);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int main()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     a[1]=-1;</span></span><br><span class="line"><span class="comment">//     scanf(&quot;%d&quot;,&amp;n);</span></span><br><span class="line"><span class="comment">//     for(int i=2;i&lt;=n-1;i++) scanf(&quot;%d&quot;,&amp;a[i]);</span></span><br><span class="line"><span class="comment">//     fun()</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//David先手必胜</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;David&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2-小红的基环树"><a href="#题目2-小红的基环树" class="headerlink" title="题目2:小红的基环树"></a>题目2:<a href="https://ac.nowcoder.com/acm/contest/60282/A">小红的基环树</a></h2><h4 id="脑筋急转弯二号"><a href="#脑筋急转弯二号" class="headerlink" title="脑筋急转弯二号"></a>脑筋急转弯二号</h4><p>定义基环树为n个节点、n条边的、没有自环和重边的无向连通图。<br>定义一个图的直径是任意两点最短路的最大值。<br>小红想知道，n个节点构成的所有基环树中，最小的直径是多少？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">if</span>(n!=<span class="number">3</span>)cout&lt;&lt;<span class="number">2</span>&lt;&lt;endl;   </span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目3-小红的回文串"><a href="#题目3-小红的回文串" class="headerlink" title="题目3:小红的回文串"></a>题目3:<a href="https://ac.nowcoder.com/acm/contest/60282/B">小红的回文串</a></h2><p>小红拿到了一个字符串，字符串仅由小写字母和’?’字符组成。<br>小红会将每个’?’替换成任意小写字母。她希望最终字符串变成回文串。<br>小红想知道，有多少种不同的方案？答案请对1e9+7取模。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>, MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = s.<span class="built_in">length</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[l] == <span class="string">&#x27;?&#x27;</span> || s[r] == <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[l]==s[r]) ans *= <span class="number">26</span>,ans%=MOD;<span class="comment">//两个?</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[l] != s[r])</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        l++, r--;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/7/14 算法每日一题</title>
      <link href="/2023/07/14/2023-7-14-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/07/14/2023-7-14-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-游游的数组染色"><a href="#题目-游游的数组染色" class="headerlink" title="题目:游游的数组染色"></a>题目:<a href="https://ac.nowcoder.com/acm/contest/60245/B">游游的数组染色</a></h2><p>游游拿到了一个数组，其中一些数被染成红色，一些数被染成蓝色。<br>游游想知道，取两个不同颜色的数，且它们的数值相等，有多少种不同的取法？<br>我们定义，两种取法如果取的某个数在原数组的位置不同，则定义为不同的取法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[N];</span><br><span class="line"><span class="type">char</span> c[N];</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m[<span class="number">2</span>];<span class="comment">//R对应0,B对应1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += m[c[i] == <span class="string">&#x27;B&#x27;</span>][a[i]];</span><br><span class="line">        m[c[i] == <span class="string">&#x27;R&#x27;</span>][a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/7/8 算法每日一题</title>
      <link href="/2023/07/08/2023-7-8-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/07/08/2023-7-8-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-方豆子"><a href="#题目-方豆子" class="headerlink" title="题目:方豆子"></a>题目:<a href="https://ac.nowcoder.com/acm/contest/60063/C">方豆子</a></h2><p>阿宁最近对吃豆子感兴趣，阿宁想要用程序输出一下，但是图形化对于阿宁来说太难。因此他决定用字符，并且是方形的模样。</p><p>给一个正整数n，输出n级好豆子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">一级好豆子：</span><br><span class="line">******</span><br><span class="line">******</span><br><span class="line">******</span><br><span class="line">***...</span><br><span class="line">***...</span><br><span class="line">***...</span><br><span class="line"> </span><br><span class="line">一级坏豆子：</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">...***</span><br><span class="line">...***</span><br><span class="line">...***</span><br><span class="line"> </span><br><span class="line">二级好豆子：</span><br><span class="line">一级坏豆子 一级坏豆子</span><br><span class="line">一级坏豆子 一级好豆子</span><br><span class="line"> </span><br><span class="line">二级坏豆子：</span><br><span class="line">一级好豆子 一级好豆子</span><br><span class="line">一级好豆子 一级坏豆子</span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">x级好豆子：</span><br><span class="line">x-1级坏豆子 x-1级坏豆子</span><br><span class="line">x-1级坏豆子 x-1级好豆子</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">x级坏豆子：</span><br><span class="line">x-1级好豆子 x-1级好豆子</span><br><span class="line">x-1级好豆子 x-1级坏豆子</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ans[<span class="number">1</span>&lt;&lt;<span class="number">12</span>][<span class="number">1</span>&lt;&lt;<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> n,<span class="type">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当n等于0时，表示到达最小级别的豆子，需要进行填充操作。根据flag的值，对应填充好豆子或者坏豆子的图案。</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="comment">//好豆子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;x+<span class="number">3</span>;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=y;j&lt;y+<span class="number">3</span>;j++)</span><br><span class="line">                    ans[i][j]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt; x + <span class="number">3</span>; i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = y; j &lt; y + <span class="number">3</span>; j++)</span><br><span class="line">                    ans[i][j] = <span class="string">&#x27;*&#x27;</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) t=t&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    t=t*<span class="number">3</span>;</span><br><span class="line">    <span class="comment">//当前级别的豆子划分为四个部分，并以不同的方式填充每个部分。其中，flag的值会在每次递归调用时进行取反。</span></span><br><span class="line">    <span class="built_in">cal</span>(x,y,n<span class="number">-1</span>,flag^<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cal</span>(x,y+t,n<span class="number">-1</span>,flag^<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cal</span>(x+t,y,n<span class="number">-1</span>,flag^<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cal</span>(x+t,y+t,n<span class="number">-1</span>,flag);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cal</span>(<span class="number">0</span>,<span class="number">0</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) t&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    t*=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t;i++)</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/7/7 算法每日一题</title>
      <link href="/2023/07/07/2023-7-7-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/07/07/2023-7-7-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-AcWing-3326-最大硬币数"><a href="#题目-AcWing-3326-最大硬币数" class="headerlink" title="题目:AcWing 3326.最大硬币数"></a>题目:<a href="https://www.acwing.com/problem/content/3329/">AcWing 3326.最大硬币数</a></h2><p>Mike 有一个 N 行 N 列的方格矩阵。</p><p>位于第 i 行第 j 列的方格的位置坐标表示为 (i,j)。矩阵左上角方格的坐标即为 (1,1)。每个方格中都包含一定数量的硬币，Mike 只有到达一个方格内时，方可收集方格中的硬币。Ci,j 表示第 i 行第 j 列的方格中的硬币数量。</p><p>当 Mike 处于方格 (i,j) 时，他可以选择移动至方格 (i−1,j−1) 或方格 (i+1,j+1) 中，前提是所选择的方格位于矩阵边界内，且之前没有到达过。</p><p>Mike 可以选择从任意方格开始移动，也可以选择在移动至任意方格时结束移动。Mike 希望尽可能多的收集硬币。</p><p>请帮助他确定他可以收集的最大硬币数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> c[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">getans</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a&lt;=n&amp;&amp;b&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        max+=c[a][b];</span><br><span class="line">        a++,b++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=T;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;c[i][j]);</span><br><span class="line">                </span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,<span class="built_in">getans</span>(i,<span class="number">1</span>));</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,<span class="built_in">getans</span>(<span class="number">1</span>,i));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %lld\n&quot;</span>, t, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/7/6 算法每日一题</title>
      <link href="/2023/07/06/2023-7-6-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/07/06/2023-7-6-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目1-AcWing-3325-Kick-Start"><a href="#题目1-AcWing-3325-Kick-Start" class="headerlink" title="题目1:AcWing 3325.Kick_Start"></a>题目1:<a href="https://www.acwing.com/problem/content/3328/">AcWing 3325.Kick_Start</a></h2><p>Ksenia 非常喜欢读书，因此每天她都会从自己最喜欢的书中选取一段内容进行阅读，然后再开始她早晨的其他活动。</p><p>一段内容可以看作是整个文本中的一个子字符串。</p><p>Ksenia 有点迷信，她坚信如果阅读的这段内容是以字符串 KICK 开头，然后中间包含 0 个或更多个字符，最后以字符串 START 结尾，即使这段内容没什么意义，她的一天也会非常的幸运。</p><p>给定这本书的全部文本内容，请你数一数在这本书变得破旧不堪，Ksenia 不得不再买新书之前，共有多少个幸运片段可供她阅读。</p><p>只要两个片段的起始位置或结束位置不同，就认为这两个片段是不同的，即使它们包含的内容完全相同。</p><p>还需注意，不同片段之间可能会有重叠部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findLucky</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> kick = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>()<span class="number">-4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//i的变化符合kmp思想</span></span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">substr</span>(i, <span class="number">4</span>) == <span class="string">&quot;KICK&quot;</span>) kick ++, i += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.<span class="built_in">substr</span>(i, <span class="number">5</span>) == <span class="string">&quot;START&quot;</span>) ans += kick, i += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=T;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">findLucky</span>(s);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>,t,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2-AcWing-4114-垃圾桶"><a href="#题目2-AcWing-4114-垃圾桶" class="headerlink" title="题目2:AcWing 4114.垃圾桶"></a>题目2:<a href="https://www.acwing.com/problem/content/4117/">AcWing 4114.垃圾桶</a></h2><p>一条很长的街道上有 N 个房子。</p><p>第一个房子在位置 1，第二个房子在位置 2，以此类推。</p><p>任意一对房子 i 和 j 之间的距离为 |i−j|。</p><p>一些房子的位置处有垃圾桶。每个房子的主人都要倒垃圾。如果自己房子前面有垃圾桶，则无需移动，直接倒垃圾即可。</p><p>如果自己房子前面没有垃圾桶，则前往距离自己最近的垃圾桶处倒垃圾，如果这样的垃圾桶不唯一，则任意前往一个即可。</p><p>请计算，所有房子的主人倒垃圾需要行走的总距离之和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> l[N], r[N];<span class="comment">//分别表示该住户左侧和右侧最近的垃圾桶,若自带垃圾桶则为0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>; t &lt;= T; t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, s + <span class="number">1</span>);</span><br><span class="line">        l[<span class="number">0</span>] = <span class="number">-1e6</span>, r[n + <span class="number">1</span>] = <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            l[i] = s[i] == <span class="string">&#x27;1&#x27;</span> ? i : l[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">            r[i] = s[i] == <span class="string">&#x27;1&#x27;</span> ? i : r[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            ans += <span class="built_in">min</span>(i - l[i], r[i] - i);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %lld\n&quot;</span>, t, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/7/5 算法每日一题</title>
      <link href="/2023/07/05/2023-7-5-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/07/05/2023-7-5-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-AcWing-3748-递增子串"><a href="#题目-AcWing-3748-递增子串" class="headerlink" title="题目:AcWing 3748.递增子串"></a>题目:<a href="https://www.acwing.com/problem/content/3751/">AcWing 3748.递增子串</a></h2><p>的朋友约翰刚刚度假归来，他迫不及待地想要跟你分享他了解到的关于字符串的一个新性质。</p><p>他了解到，如果一个长度为 L 的大写字母构成的字符串 C，满足对于每对索引 i,j（1≤i&lt;j≤L，索引编号 1∼L），位置 i 处的字符均小于位置 j 处的字符，则该字符串是严格递增的。</p><p>例如，字符串 ABC 和 ADF 是严格递增的，而字符串 ACC 和 FDA 则不是。</p><p>在教给你这个关于字符串的新性质后，他打算考一考你：</p><p>给定一个长度为 N 的字符串 S，请你计算对于每个位置 i（1≤i≤N），以该位置结束的最长严格递增子串的长度是多少？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=T;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;n,s);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, t);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,f=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>||s[i<span class="number">-1</span>]&lt;s[i]) f++;</span><br><span class="line">            <span class="keyword">else</span> f=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,f);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/7/4 算法每日一题</title>
      <link href="/2023/07/04/2023-7-4-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/07/04/2023-7-4-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-AcWing-4118-狗和猫"><a href="#题目-AcWing-4118-狗和猫" class="headerlink" title="题目:AcWing 4118.狗和猫"></a>题目:<a href="https://www.acwing.com/problem/content/4121/">AcWing 4118.狗和猫</a></h2><p>你在动物收容所工作，负责喂养动物。</p><p>你一共准备了 D 份狗粮和 C 份猫粮。一共有 N 只动物排队等候用餐，有的是狗，有的是猫。当然，也有可能全都是狗或者全都是猫。</p><p>我们可以用一个长度为 N 的由大写字母 C 和 D 组成的字符串 S 来表示队列中猫狗的顺序。</p><p>如果队列中第 i 只动物是猫，则第 i 个字符为 C。如果队列中第 i 只动物是狗，则第 i 个字符为 D。</p><p>动物们严格按照排队顺序依次进食。每只狗吃一份狗粮，每只猫吃一份猫粮。</p><p>此外，你还有额外的猫粮。每当一条狗吃完一份狗粮，你就会为猫多提供 M 份猫粮。</p><p>每只动物都只会在排在其前面的所有动物都进食完毕后，才肯进食。这也就意味着，当轮到某只动物进食，但是却没有相应的食物时，它和排在它后面的所有动物都会因此无法进食。</p><p>请问，在这种情况下，队列中的所有狗能否都得到喂食。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=T;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> N,D,C,M;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;N,&amp;D,&amp;C,&amp;M);</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;<span class="comment">//狗前的猫数量</span></span><br><span class="line">        <span class="type">int</span> cat=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;D&#x27;</span>) q.<span class="built_in">push</span>(cat),cat=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> cat++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//q.push(cat); 只需要管的狗都喂了没,所以不需要管尾部的猫</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((C-q.<span class="built_in">front</span>())&gt;=<span class="number">0</span>&amp;&amp;D&gt;=<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                D--;</span><br><span class="line">                C+=M;</span><br><span class="line">                C-=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: YES\n&quot;</span>,t);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: NO\n&quot;</span>,t);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/7/3 算法每日一题</title>
      <link href="/2023/07/03/2023-7-3-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/07/03/2023-7-3-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目1-AcWing-4443-无限区域"><a href="#题目1-AcWing-4443-无限区域" class="headerlink" title="题目1:AcWing 4443.无限区域"></a>题目1:<a href="https://www.acwing.com/problem/content/4446/">AcWing 4443.无限区域</a></h2><p>给定一个无限大的二维平面，设点 S 为该平面的中心点。</p><p>设经过点 S 的垂直方向的直线为 P，如果直线 P 是一个圆的切线，且切点恰好为点 S，那么：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果该圆位于直线 P 的右侧，则称之为右圆。</span><br><span class="line">如果该圆位于直线 P 的左侧，则称之为左圆。</span><br></pre></td></tr></table></figure></p><p>现在，给定三个整数 R,A,B，你需要按照右圆、左圆、右圆、左圆…的顺序不断画圆，具体要求如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一个右圆的半径等于 R。</span><br><span class="line">每个左圆的半径等于你画的上一个圆的半径乘以 A。</span><br><span class="line">每个右圆（第一个除外）的半径等于你画的上一个圆的半径除以 B（向下取整）。</span><br><span class="line">当你要画的圆的半径等于 0 时，绘画停止。</span><br></pre></td></tr></table></figure></p><p>请你计算，所有画出的圆的面积之和。题目保证绘画会在有限数量的步骤后停止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.1415927</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//画画顺序 右 左 右 左</span></span><br><span class="line"><span class="comment">//当出现画圆半径为0的情况,则退出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>; t &lt;= T; t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> r, a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>, &amp;r, &amp;a, &amp;b);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = r*r;</span><br><span class="line">        <span class="comment">//一次执行左右两个操作,因为就算在中途半径清零了,对结果也没有影响</span></span><br><span class="line">        <span class="keyword">while</span>(r &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r *= a;</span><br><span class="line">            ans += r*r;</span><br><span class="line">            r /= b;</span><br><span class="line">            ans += r*r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %lf\n&quot;</span>,t,PI*ans);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2-AcWing-3752-更小的字符串"><a href="#题目2-AcWing-3752-更小的字符串" class="headerlink" title="题目2:AcWing 3752.更小的字符串"></a>题目2:<a href="https://www.acwing.com/problem/content/3755/">AcWing 3752.更小的字符串</a></h2><p>给定一个整数 K 和一个长度为 N 的字符串 S。</p><p>已知，字符串 S 是由前 K 个小写字母组成。</p><p>现在，请你找出满足下列条件的回文字符串的数量：</p><p>长度为 N。<br>字典序上小于 S。<br>由前 K 个小写字母组成。<br>由于满足条件的字符串数量可能很大，所以输出对 1e9+7 取模后的答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N];<span class="comment">//f表示有n个位置可以随便取时的分支数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=T;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">        <span class="type">char</span> s[N];</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        </span><br><span class="line">        f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            f[i]=(LL)f[i<span class="number">-1</span>]*k%MOD;</span><br><span class="line">            </span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid=(n+<span class="number">1</span>)/<span class="number">2</span>;<span class="comment">//自由度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;mid;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=(LL)(s[i]-<span class="string">&#x27;a&#x27;</span>)*f[mid-i<span class="number">-1</span>]%MOD;</span><br><span class="line">            res%=MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断回文串是否小于原串=&gt;前半段全与原s相等的情况</span></span><br><span class="line">        <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=mid<span class="number">-1</span>,j=n<span class="number">-1</span>-i;i&gt;=<span class="number">0</span>;i--,j++)</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=s[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]&lt;s[j]) y=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        res=(res+y)%MOD;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>, t, res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/7/2 算法每日一题</title>
      <link href="/2023/07/02/2023-7-2-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/07/02/2023-7-2-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目1-AcWing-3321-ATM队列"><a href="#题目1-AcWing-3321-ATM队列" class="headerlink" title="题目1:AcWing 3321.ATM队列"></a>题目1:<a href="https://www.acwing.com/problem/content/3324/">AcWing 3321.ATM队列</a></h2><p>N 个人（编号 1∼N），排成一队在 ATM 机前准备取钱。</p><p>初始时，队列按编号升序的顺序排列。</p><p>第 i 个人需要取 Ai 元钱。<br>一个人一次最多可以取 X 元钱。</p><p>当轮到某个人取钱时，如果其需要的钱的数量大于 X，则只能先取 X 元钱，然后去队尾重新排队，等待下次轮到他取钱时，继续去取。</p><p>当一个人取够钱时，他就会拿着钱离开队列。</p><p>现在，请你确定所有人离开队列的顺序。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>,i);</span><br><span class="line">        <span class="type">int</span> n,x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;y);</span><br><span class="line">            a[j]=&#123;(y<span class="number">-1</span>)/x,j&#125;;<span class="comment">//直接计算轮次,需要注意当待取钱数等于一次最多能去的钱数的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[j].second);</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2-AcWing-4122-字符串转换"><a href="#题目2-AcWing-4122-字符串转换" class="headerlink" title="题目2:AcWing 4122.字符串转换"></a>题目2:<a href="https://www.acwing.com/problem/content/4125/">AcWing 4122.字符串转换</a></h2><p>给定一个由小写字母构成的字符串 S。</p><p>再给定一个由若干个各不相同的小写字母按字典序排序构成的字符串 F。</p><p>现在，你可以对字符串 S 进行字符转换操作。</p><p>每次选中其中一个字符（即某个小写字母），将其转换为一个按照字母顺序与其相邻（上一个或下一个）的小写字母。</p><p>例如，c 可以转换为 b 或 d。</p><p>额外的，我们将按照循环顺序考虑字母，即我们认为 a 的上一个字母为 z，z 的下一个字母为 a。</p><p>请问，至少需要进行多少次操作，可以使得字符串 S 中的每个字母都出现在字符串 F 中。</p><p>代码如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string s, f;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; f;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; s.<span class="built_in">size</span>(); a++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> m = <span class="number">26</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; f.<span class="built_in">size</span>(); b++)</span><br><span class="line">            &#123;</span><br><span class="line">                m = <span class="built_in">min</span>(m, <span class="built_in">abs</span>(s[a] - f[b]));</span><br><span class="line">                m = <span class="built_in">min</span>(m, <span class="built_in">abs</span>(s[a] + <span class="number">26</span> - f[b]));</span><br><span class="line">                m = <span class="built_in">min</span>(m, <span class="built_in">abs</span>(s[a] - <span class="number">26</span> - f[b]));</span><br><span class="line">            &#125;</span><br><span class="line">            ans += m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>, i, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/7/1 算法每日一题</title>
      <link href="/2023/07/01/2023-7-1-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/07/01/2023-7-1-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>因为期末周和放假回家休息了几天,今天开始继续</p><h2 id="题目1-AcWing-4737-冰壶"><a href="#题目1-AcWing-4737-冰壶" class="headerlink" title="题目1:AcWing 4737.冰壶"></a>题目1:<a href="https://www.acwing.com/problem/content/4740/">AcWing 4737.冰壶</a></h2><p>红队和黄队进行了一场冰壶比赛，比赛结束后，裁判正在计算两队的得分。</p><p>场地可以看作一个二维平面，得分区域可以看作一个以 (0,0) 为圆心 Rh 为半径的圆。</p><p>场地上散落着 N 个红队的冰壶以及 M 个黄队的冰壶。</p><p>冰壶可以看作一个半径为 Rs 的圆。</p><p>每个冰壶的圆心坐标已知。<br>如果一个冰壶的任何部分位于得分区域的圆上或圆内（两者相切也算），则视为该冰壶位于得分区域内。<br>如果一个冰壶能够同时满足：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.它位于得分区域内。</span><br><span class="line"></span><br><span class="line">2.不存在任何对方冰壶比它距离得分中心 (0,0) 更近（欧几里得距离）。</span><br></pre></td></tr></table></figure><br>那么，这个冰壶就是一个得分冰壶。</p><p>一个队伍的最终得分等于该队伍的得分冰壶数量。请你计算并输出两支队伍的最终得分。</p><p>一个冰壶与得分中心之间的距离等于其圆心点到点 (0,0)的距离。</p><p>数据保证不同冰壶与得分中心之间的距离不同，且冰壶两两之间不重叠（但可能相切）。</p><p>代码如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; a, b;<span class="comment">//直接存得分圈内的圆壶的距离</span></span><br><span class="line">        <span class="type">int</span> rs,rh,n,m;<span class="comment">//rs场地半径,rh圆壶半径,n,m圆壶数</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;rs,&amp;rh);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="type">double</span> d = <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">            <span class="keyword">if</span> (d &lt;= rs + rh) a.<span class="built_in">push_back</span>(d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="type">double</span> d = <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">            <span class="keyword">if</span> (d &lt;= rs + rh) b.<span class="built_in">push_back</span>(d);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> m1 = <span class="number">0</span>, m2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">empty</span>() || b.<span class="built_in">empty</span>()) m1 = a.<span class="built_in">size</span>(), m2 = b.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">            <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> d : a)</span><br><span class="line">                <span class="keyword">if</span> (d &lt; b[<span class="number">0</span>]) m1++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> d : b)</span><br><span class="line">                <span class="keyword">if</span> (d &lt; a[<span class="number">0</span>]) m2++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d %d\n&quot;</span>,i,m1,m2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="题目2-AcWing-4633-学生和导师"><a href="#题目2-AcWing-4633-学生和导师" class="headerlink" title="题目2:AcWing 4633.学生和导师"></a>题目2:<a href="https://www.acwing.com/problem/content/4636/">AcWing 4633.学生和导师</a></h2><p>有 N 个学生（编号 1∼N）正在一起准备编程竞赛。</p><p>为了帮助彼此做好准备，每个学生都要选择一个其他学生作为他的导师，帮助其进步。<br>每个学生只能拥有一位导师，但是一个学生可以成为多个学生的导师。</p><p>第 i 个学生的实力评分为 Ri。</p><p>我们认为，导师不能比其受指导者强太多，所以只有当 Rj≤2×Ri 时，学生 j 才能成为学生 i 的导师。</p><p>请注意，导师的评分可以小于或等于其受指导者的评分。</p><p>毫不奇怪，每个学生都希望自己的导师尽可能强，所以对于每个学生，请你找出他们可以选择的导师的最高评分。</p><p>代码如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="built_in">memcpy</span>(b,a,<span class="keyword">sizeof</span> a);</span><br><span class="line">        <span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>,i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用二分找大于2a[i]的第一个位置,然后对其--,就找到了</span></span><br><span class="line">        <span class="comment">//如果正好为自身,同样--,找到比自己拉的导师</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">1</span>,r=n;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(b[mid]&gt;<span class="number">2</span>*a[i]) r=mid;</span><br><span class="line">                <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(b[r]&gt;<span class="number">2</span>*a[i]) r--;<span class="comment">//超出范围</span></span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[r]) r--;<span class="comment">//等于自身</span></span><br><span class="line">            <span class="keyword">if</span>(r!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[r]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/6/25 算法每日一题</title>
      <link href="/2023/06/25/2023-6-25-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/06/25/2023-6-25-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-AcWing-4738-快乐子数组"><a href="#题目-AcWing-4738-快乐子数组" class="headerlink" title="题目:AcWing 4738.快乐子数组"></a>题目:<a href="https://www.acwing.com/problem/content/4741/">AcWing 4738.快乐子数组</a></h2><p>我们将 F(B,L,R) 定义为整数数组 B 的索引从 L 到 R（包括两者）的子数组的各个元素之和。</p><p>更具体的说，F(B,L,R)=BL+BL+1+…+BR。</p><p>如果一个长度为 K 的整数数组 C 满足其所有前缀和均为非负整数，则称数组 C 为快乐数组。</p><p>更具体的说，如果 F(C,1,1),F(C,1,2),…,F(C,1,K) 均为非负整数，则数组 C 为快乐数组。</p><p>给定一个包含 N 个整数的数组 A，请你计算数组 A 中的所有快乐连续子数组的元素和相加的结果。</p><h3 id="大佬代码"><a href="#大佬代码" class="headerlink" title="大佬代码"></a><a href="https://www.acwing.com/solution/content/148121/">大佬代码</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//菜,自己润不出来</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> p[N], pp[N], r[N];</span><br><span class="line"><span class="comment">//设p数组的前缀和数组为pp, pp[i]=p[1]+p[2]+…+p[i]</span></span><br><span class="line"><span class="comment">//定义r[l]为， 以al开始的最长快乐子数组的右端点。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T; cin &gt;&gt; T;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>; t &lt;= T; t ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            p[i] = p[i - <span class="number">1</span>] + x;</span><br><span class="line">            pp[i] = pp[i - <span class="number">1</span>] + p[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        stk.<span class="built_in">push</span>(n + <span class="number">1</span>), p[n + <span class="number">1</span>] = <span class="number">-1e9</span>;<span class="comment">//初始化栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">0</span>; i --) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (p[i] &lt;= p[stk.<span class="built_in">top</span>()])<span class="comment">//当栈顶元素大时</span></span><br><span class="line">                stk.<span class="built_in">pop</span>();<span class="comment">//直接删除栈顶元素</span></span><br><span class="line">                </span><br><span class="line">            r[i + <span class="number">1</span>] = stk.<span class="built_in">top</span>();<span class="comment">//找到了右端点</span></span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> j = r[i] - <span class="number">1</span>;</span><br><span class="line">            res += pp[j] - pp[i - <span class="number">1</span>] - (j - i + <span class="number">1</span>) * p[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="再贴一个单调栈的文章吧"><a href="#再贴一个单调栈的文章吧" class="headerlink" title="再贴一个单调栈的文章吧"></a>再贴一个单调栈的文章吧</h3><p><a href="https://www.acwing.com/solution/content/27437/">单调栈</a></p><p>算法原理:<br>用单调递增栈，当该元素可以入栈的时候，栈顶元素就是它左侧第一个比它小的元素。<br>以：3 4 2 7 5 为例，过程如下：<br><img src="https://cdn.acwing.com/media/article/image/2023/03/11/55289_7a61998ec0-20201211221031165.gif" alt="image"></p><p>这里是伪代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="comment">//此处一般需要给数组最后添加结束标志符，具体下面例题会有详细讲解</span></span><br><span class="line"><span class="keyword">for</span> (遍历这个数组)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (栈空 || 栈顶元素大于等于当前比较元素)</span><br><span class="line">&#123;</span><br><span class="line">入栈;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (栈不为空 &amp;&amp; 栈顶元素小于当前元素)</span><br><span class="line">&#123;</span><br><span class="line">栈顶元素出栈;</span><br><span class="line">更新结果;</span><br><span class="line">&#125;</span><br><span class="line">当前数据入栈;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「lucky52529」的原创文章，遵循CC <span class="number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/lucky52529/article/details/89155694</span></span><br></pre></td></tr></table></figure></p><p>代码如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> stk[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">while</span> (tt &amp;&amp; stk[tt] &gt;= x) tt -- ;<span class="comment">//如果栈顶元素大于当前待入栈元素，则出栈</span></span><br><span class="line">        <span class="keyword">if</span> (!tt) <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);<span class="comment">//如果栈空，则没有比该元素小的值。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, stk[tt]);<span class="comment">//栈顶元素就是左侧第一个比它小的元素。</span></span><br><span class="line">        stk[ ++ tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/6/24 算法每日一题</title>
      <link href="/2023/06/24/2023-6-24-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/06/24/2023-6-24-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-AcWing-4741-魔法百合井"><a href="#题目-AcWing-4741-魔法百合井" class="headerlink" title="题目:AcWing 4741.魔法百合井"></a>题目:<a href="https://www.acwing.com/problem/content/4744/">AcWing 4741.魔法百合井</a></h2><p>森林里有一口很深的魔法井，井中有 L 朵百合花。</p><p>你带着一个大空篮子和足够多的硬币来到了井边。<br>这个井有魔力，向里面投入硬币可以发生神奇的事情：</p><p>如果你向井里一次性投入 1 个硬币，井就会发动魔法，将一朵百合花扔进你的篮子里。<br>如果你向井里一次性投入 4 个硬币，井就会发动魔法，统计并记录到目前为止，已经扔进你的篮子里的百合花的数量。<br>如果你向井里一次性投入 2 个硬币，井就会发动魔法，将等同于上次记录数量的百合花扔进你的篮子里。<br>有一点需要特别注意，如果你向井里一次性投入 1 个或 2 个硬币后，井中已经没有足够的百合花扔给你了，那么井就不会发动任何魔法，也不会扔给你任何百合花（钱白花了）。</p><p>请你计算，为了将所有百合花都收入篮中，所需要花费的最少硬币数量。</p><h3 id="自己尝试的错误做法"><a href="#自己尝试的错误做法" class="headerlink" title="自己尝试的错误做法"></a>自己尝试的错误做法</h3><p>可以发现这样选不出最优的开始倍增的位置,原理我也不清楚,反正模拟下案例发现这样暴力模拟确实做不出来<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加一朵鲜花需要1</span></span><br><span class="line"><span class="comment">//对当前持有鲜花倍增需要4+2=6</span></span><br><span class="line"><span class="comment">//对上一次持有的鲜花数进行倍增需要2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当篮子内鲜花数&gt;=6时开始考虑倍增</span></span><br><span class="line"><span class="comment">// 若倍增后超过 井内鲜花数,则不倍增,否则倍增</span></span><br><span class="line"><span class="comment">// 若不倍增,看看对上次持有鲜花数倍增能否更接近答案,之后加一,重复这个过程;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t, l;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;l);</span><br><span class="line">        <span class="type">int</span> nf = <span class="number">0</span>;<span class="comment">//当前篮子里鲜花数量</span></span><br><span class="line">        <span class="type">int</span> f = l;<span class="comment">//当前井中鲜花数</span></span><br><span class="line">        <span class="type">int</span> lastf = <span class="number">0</span>;<span class="comment">//上次记录井中鲜花数</span></span><br><span class="line">        <span class="type">int</span> coin = <span class="number">0</span>;<span class="comment">//硬币数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (nf != l)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (nf &lt; <span class="number">6</span> &amp;&amp; f != <span class="number">0</span>) coin++, f--, nf++;</span><br><span class="line">            <span class="keyword">while</span> (f &gt;= lastf&amp;&amp;nf!=l)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nf * <span class="number">2</span> &lt;= l &amp;&amp; f &gt;= nf) coin += <span class="number">6</span>, lastf = nf, nf += nf, f -= lastf;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (f &gt;= lastf &amp;&amp; nf + lastf &lt; l)coin += <span class="number">2</span>, nf += lastf, f -= lastf;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (nf != l) coin++, f--, nf++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; coin &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="这是简化后的dp"><a href="#这是简化后的dp" class="headerlink" title="这是简化后的dp"></a>这是简化后的dp</h3><p><a href="https://www.acwing.com/solution/content/191789/">转自:鸣一YU</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//f[i]表示i朵花的最少花费</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于题目范围内的i,遍历其约数</span></span><br><span class="line">        <span class="comment">//其中，j 表示翻倍的倍数(2的个数)，即从 i/j 开始翻倍；i/j 表示翻倍后的数量，即每次翻倍的数量为 i/j；</span></span><br><span class="line">        <span class="comment">//i%(i/j) 表示最后一次翻倍时需要花费的额外费用(结尾补1)。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//具体地，首先将 f[i] 更新为当前最小花费，然后枚举从 i/j 开始翻倍的倍数 j，计算翻倍后的数量</span></span><br><span class="line">        <span class="comment">//和最后一次翻倍的额外费用，然后加上 4+(j-1)*2，即投入 4 个硬币并记录新的数量的花费。最后，将</span></span><br><span class="line">        <span class="comment">//这个值与当前的 f[i] 取最小值，表示使用这种翻倍方式所需的最小花费。</span></span><br><span class="line"></span><br><span class="line">        f[i]=i;<span class="comment">//初始化i朵花最坏情况：每朵花都是一块钱买的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>; j&lt;=i/j; j++)<span class="comment">//j表示扩大的倍数</span></span><br><span class="line">            f[i]=<span class="built_in">min</span>(f[i], f[i/j]+<span class="number">4</span>+(j<span class="number">-1</span>)*<span class="number">2</span>+i%(i/j));</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">              f[i/j]表示从i/j这个开始翻倍时的最小费用,</span></span><br><span class="line"><span class="comment">              f[i/j]+4+(j-1)*2+i%(i/j)这就是翻倍后的通用的推导公式；</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a ; cin &gt;&gt; a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>, i, f[a]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/6/21 算法每日一题</title>
      <link href="/2023/06/23/2023-6-23-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/06/23/2023-6-23-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目1-AcWing-4742-电"><a href="#题目1-AcWing-4742-电" class="headerlink" title="题目1:AcWing 4742.电"></a>题目1:<a href="https://www.acwing.com/problem/content/4745/">AcWing 4742.电</a></h2><p>某城市有 N 个电力节点，编号 1∼N。</p><p>这些电力节点形成的电力网络，可以看作一个 N 个节点 N−1 条边的连通图。</p><p>每个电力节点都有一个固定的电容，其中第 i 个节点的电容为 Ai。</p><p>现在，可以选择其中一个节点进行供电，其它节点也可以根据实际连接以及具体电容情况接收电力。</p><p>具体来说，如果第 i 个节点通电，那么它也可以将电力传输给其它所有与它直接连接且电容严格小于 Ai 的节点。</p><p>我们希望通过合理选择初始供电节点，从而使得尽可能多的节点能够通电。</p><p>请你计算并输出可以通电的最大节点数量。</p><h3 id="手搓邻接表-原文链接"><a href="#手搓邻接表-原文链接" class="headerlink" title="手搓邻接表 原文链接"></a>手搓邻接表 <a href="https://blog.csdn.net/qq_63356727/article/details/129209473">原文链接</a></h3><p>h数组：表示每个顶点对应的链表的头节点的下标。</p><p>e数组：表示每个边的终点。</p><p>ne数组：表示与当前边起点相同的下一条边的下标。</p><p>需要注意的是,这些数组内存储的都是下标</p><p>具体来说，对于一条边(a, b)，我们将它插入到顶点a的链表中。我们需要先将新边的终点存入e数组中，将当前顶点a的链表的头节点下标存入ne数组中，然后将当前边的下标存入h数组中。同时，为了保证新插入的边在链表的头部，我们需要将当前边的下标作为新的头节点，将它存入h数组中，并更新ne数组中原来的头节点的值，使其指向当前边的下标。这样，就能够实现将新边插入到链表的头部，并更新该顶点的链表头节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//DFS</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2</span>*<span class="number">1e5</span>+<span class="number">10</span>,M=N*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],idx=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    res[n]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[n];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=e[i];</span><br><span class="line">        <span class="keyword">if</span>(w[n]&gt;w[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (res[j] == <span class="number">0</span>) <span class="built_in">dfs</span>(j);</span><br><span class="line">            res[n] += res[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t,n;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[j]), h[j] = <span class="number">-1</span>, res[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a,b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">            <span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res[j]==<span class="number">0</span>) <span class="built_in">dfs</span>(j);</span><br><span class="line">            <span class="keyword">if</span>(res[j]&gt;ans) ans=res[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>,i,ans);</span><br><span class="line">        </span><br><span class="line">        idx=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2-AcWing-4740-跑圈"><a href="#题目2-AcWing-4740-跑圈" class="headerlink" title="题目2:AcWing 4740.跑圈"></a>题目2:<a href="https://www.acwing.com/problem/content/4743/">AcWing 4740.跑圈</a></h2><p>阿达正在一个长度为 L 的环形跑道上练习跑步。</p><p>为了更专注于跑步，阿达专门准备了一台机器来统计她跑的圈数。</p><p>机器放置在跑道的起跑线上，从 0 开始计数。</p><p>每当阿达离开起跑线时（直接越过起跑线或在起跑线位置处改变方向并离开起跑线），她的面朝方向就会被机器记录。</p><p>机器只会实时记录她最近一次离开起跑线时的面朝方向。<br>每当阿达到达起跑线位置时，只要其面朝方向与机器记录的上次离开起跑线时的面朝方向相同，机器计数就会加 1。</p><p>阿达从起跑线处开始跑步。她的耐力有限，无法将计划的训练量一口气完成。因此，每跑一段距离，她都会原地休息一段时间，用来恢复体力。</p><p>不幸的是，阿达的记忆力并不是很好，每当她休息完再次开始跑步时，她都会忘了之前面朝的方向。这时，她只能随意选择一个方向（顺时针或逆时针），并面朝该方向从她停下的位置开始继续跑步。</p><p>具体的说，她一共进行了 N 段跑步，其中第 i 段跑步的距离为 Di，跑步时的面朝方向为 Ci<br>。</p><p>请你计算，在阿达完成跑步后，机器最终记录的圈数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">1</span>; m &lt;= t; m++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, n;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; n;</span><br><span class="line">        <span class="comment">//bool first = true;//记录第一次起跑</span></span><br><span class="line">        <span class="type">char</span> f, lf;<span class="comment">//当前方向,上次方向</span></span><br><span class="line">        <span class="type">int</span> d;<span class="comment">//本段跑步长度</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;<span class="comment">//圈数量  注意数据范围ll</span></span><br><span class="line">        <span class="type">int</span> rd = <span class="number">0</span>;<span class="comment">//当前位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %c&quot;</span>, &amp;d, &amp;f);</span><br><span class="line">            <span class="comment">//if(first) lf=f,first=false;</span></span><br><span class="line">            <span class="keyword">if</span> (rd == <span class="number">0</span>) lf = f;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (lf == f)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((rd + d) / l)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans += (rd + d) / l;</span><br><span class="line">                    rd = (rd + d) % l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> rd += d;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rd - d &gt; <span class="number">0</span>) rd -= d;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    rd = (d - rd), lf = f;</span><br><span class="line">                    <span class="keyword">if</span> (rd / l)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans += rd / l;</span><br><span class="line">                        rd = rd % l;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %lld\n&quot;</span>,m,ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/6/22 算法每日一题</title>
      <link href="/2023/06/22/2023-6-22-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/06/22/2023-6-22-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>题目:<a href="https://www.acwing.com/problem/content/4443/">AcWing 4440.照相</a></p><p>迫切希望在郡县集市上赢得最佳奶牛摄影师的农夫约翰正在尝试为他的N头奶牛拍摄一张完美的照片。</p><p>农夫约翰拥有两种品种的奶牛：更赛牛（Guernsey）和荷斯坦牛（Holstein）。</p><p>为了使他的照片尽可能地艺术，他想把他的奶牛排成一排，使得尽可能多的更赛牛处于队列中的偶数位置（队列中的第一个位置是奇数位置，下一个是偶数位置，以此类推）。</p><p>由于他与他的奶牛缺乏有效的沟通，他可以达到目的的唯一方法是让他的奶牛的偶数长的「前缀」进行反转（一个前缀指的是对于某个位置 j，从第一头奶牛到第 j 头奶牛范围内的所有奶牛）。</p><p>请计算农夫约翰达到目的所需要的最小反转次数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ACW4440 take cow photo</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2</span>*<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于牛的总数为偶数,且每次翻转的牛的数量总取前偶数个</span></span><br><span class="line"><span class="comment">// 对于每次输入,对其进行两两一组的分组</span></span><br><span class="line"><span class="comment">// 对于组别GH,需要对其进行翻转,让其变为HG,因为翻转后会破坏前面已经符合题意的前缀</span></span><br><span class="line"><span class="comment">// 所以需要对其前缀进行翻转维护前缀的正确性</span></span><br><span class="line"><span class="comment">// 对于组别GG,HH,直接忽略即可</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string s; </span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;<span class="comment">//翻转次数</span></span><br><span class="line">    <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i+=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;G&#x27;</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">&#x27;H&#x27;</span>) ans+=flag==<span class="number">2</span>,flag=<span class="number">1</span>;<span class="comment">//GH情况,如果前面是GH,则先放着不管,攒着一起翻转前缀</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;H&#x27;</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">&#x27;G&#x27;</span>) ans+=flag==<span class="number">1</span>,flag=<span class="number">2</span>;<span class="comment">//HG情况,如果前面也是GH的情况,则需要处理前面的前缀了</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="number">1</span>) ans++;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/6/21 算法每日一题</title>
      <link href="/2023/06/21/2023-6-21-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/06/21/2023-6-21-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>题目:<a href="https://www.acwing.com/activity/content/problem/content/8434/">AcWing 4908.饥饿的牛</a></p><p>贝茜是一头饥饿的牛。每天晚上，如果牛棚中还有干草的话，贝茜都会吃掉其中的一捆。</p><p>初始时，牛棚中没有干草。</p><p>为了让贝茜不被饿死，农夫约翰制定了N个给贝茜送干草的计划。</p><p>其中第 i个计划是在第 di天的白天给贝茜送去 bi捆干草。</p><p>这些计划互不冲突，保证 1≤d1&lt;d2&lt;…&lt;dN≤T。</p><p>请你计算，贝茜在第 1∼T天中有多少天有干草吃。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ACW4908 hunger cow</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n,t;<span class="comment">//送n次草,共t天</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> di,bi,cao=<span class="number">0</span>,last=<span class="number">0</span>;<span class="comment">//当前送草日,当前送草量,上次更新的库存草料数,上次送草日</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> fullDay=<span class="number">0</span>;<span class="comment">//吃饱天数</span></span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;di,&amp;bi);</span><br><span class="line">        <span class="keyword">if</span>(di-last&gt;cao)<span class="comment">//中间挨饿了</span></span><br><span class="line">        &#123;</span><br><span class="line">            fullDay+=cao;</span><br><span class="line">            cao=bi;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cao-=(di-last);</span><br><span class="line">            cao+=bi;</span><br><span class="line">            fullDay+=di-last;</span><br><span class="line">        &#125;</span><br><span class="line">        last=di;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理最后一次送草的余料</span></span><br><span class="line">    <span class="keyword">if</span>(cao&gt;=(t-last+<span class="number">1</span>)) fullDay+=(t-last+<span class="number">1</span>);<span class="comment">//够吃到结束</span></span><br><span class="line">    <span class="keyword">else</span> fullDay+=cao;<span class="comment">//不够吃到结束</span></span><br><span class="line">    cout&lt;&lt;fullDay&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23年大二下硬件课设</title>
      <link href="/2023/06/20/2023-6-20-23%E7%A1%AC%E4%BB%B6%E8%AF%BE%E8%AE%BE/"/>
      <url>/2023/06/20/2023-6-20-23%E7%A1%AC%E4%BB%B6%E8%AF%BE%E8%AE%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="verilog代码实现模拟交通灯"><a href="#verilog代码实现模拟交通灯" class="headerlink" title="verilog代码实现模拟交通灯"></a>verilog代码实现模拟交通灯</h1><h2 id="题目要求如下"><a href="#题目要求如下" class="headerlink" title="题目要求如下"></a>题目要求如下</h2><p>模拟交通灯<br>输入信号：时钟信号clk<br>输出信号：东西向红黄绿灯信号r1、y1、g1以及南北向红黄绿灯信号r2、y2、g2<br>设计要求：<br>1、输出高电平表示相应灯点亮，低电平表示相应灯熄灭。<br>2、初始时东西向绿灯，g1输出高电平，南北向红灯，r2输出高电平。<br>3、12个时钟脉冲（可统一使用时钟脉冲的上升沿或者下降沿，下同）后，原绿灯方向变为黄灯，再3个时钟脉冲后，黄灯方向变红灯，同时原红灯方向变绿灯；随后又是12个时钟脉冲后，当前绿灯方向又变为黄灯，再过3个时钟脉冲后，黄灯方向变红灯，同时当前红灯方向又变为绿灯，如此循环往复。<br>4、绿灯变为黄灯前，绿灯必须先闪烁数次以作为提示，即第8个时钟脉冲到来后绿灯暂时熄灭，第9个时钟脉冲到来后绿灯重新点亮，第10个时钟脉冲到来后绿灯又熄灭，第11个时钟脉冲到来后绿灯又点亮，直到第12个时钟脉冲到来后绿灯才变为黄灯，此功能必须实现。<br>5、设法消除输出信号中的干扰脉冲（“毛刺”），此功能必须实现。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在这个模拟交通灯系统中，我们需要根据输入信号：时钟信号clk输出东西向红黄绿灯信号r1、y1、g1以及南北向红黄绿灯信号r2、y2、g2。整个系统要求输出高电平表示相应灯点亮，低电平表示相应灯熄灭，并且初始状态下东西向道路为绿色，南北向道路为红色。此外，在每一个方向上车辆可以行驶的时间是有限制的，并且在不同时期会出现所谓“闪烁”等特殊情况。</p><h3 id="TLCounter模块设计"><a href="#TLCounter模块设计" class="headerlink" title="TLCounter模块设计"></a>TLCounter模块设计</h3><p>对于计数器模块,我们需要实现以下的功能需求：①能够循环计数0~27，并根据计数值更新交通信号灯状态。②在每个时间单位内，交通信号灯的状态都需要被同步更新。③交通信号灯的控制信号需要被输出到特定的IO口。<br>TLCounter模块由一个5位二进制寄存器组成，用于循环计数0~27。其中第一位最低位作为使能端口（enable），其余四位可表示16种状态，在此我们仅使用其中12种状态作为交通灯各个阶段。每当计数器的值变化时，就会触发TLDecoder模块更新输出状态。在该设计中，我们使用了简单的异或逻辑实现二进制寄存器的自加1操作。<br>具体实现代码如下：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> TLCounter(clk,cnt);<span class="comment">//0~27 循环计数</span></span><br><span class="line"><span class="keyword">input</span> clk;</span><br><span class="line"><span class="keyword">output</span>[<span class="number">4</span>:<span class="number">0</span>] cnt;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">4</span>:<span class="number">0</span>] cnt=<span class="number">5&#x27;b00001</span>;</span><br><span class="line"><span class="keyword">assign</span> clr=~(cnt[<span class="number">0</span>]&amp;cnt[<span class="number">1</span>]&amp;(cnt[<span class="number">2</span>])&amp;cnt[<span class="number">3</span>]&amp;cnt[<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">cnt[<span class="number">0</span>] &lt;= (~cnt[<span class="number">0</span>]);</span><br><span class="line">cnt[<span class="number">1</span>] &lt;= (cnt[<span class="number">1</span>] ^ cnt[<span class="number">0</span>]);</span><br><span class="line">cnt[<span class="number">2</span>] &lt;= (cnt[<span class="number">2</span>] ^ (cnt[<span class="number">0</span>] &amp; cnt[<span class="number">1</span>]));</span><br><span class="line">cnt[<span class="number">3</span>] &lt;= (cnt[<span class="number">3</span>] ^ (cnt[<span class="number">0</span>] &amp; cnt[<span class="number">1</span>] &amp; cnt[<span class="number">2</span>]));</span><br><span class="line">cnt[<span class="number">4</span>] &lt;= (cnt[<span class="number">4</span>] ^ (cnt[<span class="number">0</span>] &amp; cnt[<span class="number">1</span>] &amp; cnt[<span class="number">2</span>] &amp; cnt[<span class="number">3</span>]));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><br>在上面的代码中，我们首先定义了一个输入时钟信号（clk）、使能信号（enable）和一个用于输出计数器数值的信号（cnt）。然后，我们使用reg关键字声明了一个名为cnt的寄存器，并将其初始化为5’b00001。<br>接下来是关键的部分：在顺时针上升沿时，如果使能信号enable为高电平，则寄存器cnt的值会自动加1。具体实现方法是使用异或逻辑运算符（^）对各个二进制位进行比较和修改。通过这样的方式，我们就成功地实现了一个简单的计数器模块。</p><h3 id="TLDecoder模块设计"><a href="#TLDecoder模块设计" class="headerlink" title="TLDecoder模块设计"></a>TLDecoder模块设计</h3><p>TLDecoder模块是由一个组合电路构成，它将计数器产生的信号解码成相应的交通灯控制信号。具体实现采用了基于嵌套语句和位运算符构建的多层分支结构来判断当前处于哪种状态，并生成相应控制信号。<br>具体实现代码如下：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> TLDecoder(cnt,light,clk);</span><br><span class="line"><span class="keyword">input</span> clk;</span><br><span class="line"><span class="keyword">input</span>[<span class="number">4</span>:<span class="number">0</span>] cnt;</span><br><span class="line"><span class="keyword">output</span>[<span class="number">5</span>:<span class="number">0</span>] light;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">5</span>:<span class="number">0</span>] light=<span class="number">6&#x27;b001100</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)<span class="comment">//所有的输出信号都将在时钟的上升沿同步更新，从而消除可能的毛刺</span></span><br><span class="line"><span class="keyword">begin</span> light[<span class="number">5</span>]&lt;=((cnt[<span class="number">4</span>]&amp;(~cnt[<span class="number">3</span>]))|(cnt[<span class="number">4</span>]&amp;(~cnt[<span class="number">2</span>]))|((~cnt[<span class="number">4</span>])&amp;cnt[<span class="number">3</span>]&amp;cnt[<span class="number">2</span>]&amp;cnt[<span class="number">1</span>]));</span><br><span class="line">light[<span class="number">4</span>]&lt;=(((~cnt[<span class="number">4</span>])&amp;cnt[<span class="number">3</span>]&amp;(~cnt[<span class="number">2</span>])&amp;cnt[<span class="number">1</span>]&amp;cnt[<span class="number">0</span>])|((~cnt[<span class="number">4</span>])&amp;cnt[<span class="number">3</span>]&amp;cnt[<span class="number">2</span>]&amp;(~cnt[<span class="number">1</span>])));</span><br><span class="line">light[<span class="number">2</span>]&lt;=(((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">3</span>]))|((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">2</span>]))|((~cnt[<span class="number">4</span>])&amp;cnt[<span class="number">2</span>]&amp;(~cnt[<span class="number">1</span>])));</span><br><span class="line">light[<span class="number">1</span>]&lt;=((cnt[<span class="number">4</span>]&amp;cnt[<span class="number">3</span>]&amp;(~cnt[<span class="number">2</span>])&amp;cnt[<span class="number">0</span>])|(cnt[<span class="number">4</span>]&amp;cnt[<span class="number">3</span>]&amp;(~cnt[<span class="number">2</span>])&amp;cnt[<span class="number">1</span>]));</span><br><span class="line">light[<span class="number">3</span>]&lt;=(((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">3</span>])&amp;(~cnt[<span class="number">1</span>]))|((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">3</span>])&amp;(~cnt[<span class="number">2</span>]))|((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">2</span>])&amp;(~cnt[<span class="number">1</span>])&amp;(~cnt[<span class="number">0</span>]))|((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">2</span>])&amp;cnt[<span class="number">1</span>]&amp;(~cnt[<span class="number">0</span>]))|((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">3</span>])&amp;cnt[<span class="number">1</span>]&amp;(~cnt[<span class="number">0</span>])));</span><br><span class="line">light[<span class="number">0</span>]&lt;=((cnt[<span class="number">4</span>]&amp;(~cnt[<span class="number">3</span>])&amp;(~cnt[<span class="number">2</span>]))|(cnt[<span class="number">4</span>]&amp;(~cnt[<span class="number">2</span>])&amp;(~cnt[<span class="number">1</span>])&amp;(~cnt[<span class="number">0</span>]))|(cnt[<span class="number">4</span>]&amp;(~cnt[<span class="number">3</span>])&amp;(~cnt[<span class="number">1</span>])&amp;(~cnt[<span class="number">0</span>]))|(cnt[<span class="number">4</span>]&amp;(~cnt[<span class="number">3</span>])&amp;cnt[<span class="number">1</span>]&amp;(~cnt[<span class="number">0</span>]))|((~cnt[<span class="number">4</span>])&amp;cnt[<span class="number">3</span>]&amp;cnt[<span class="number">2</span>]&amp;cnt[<span class="number">1</span>]));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><br>该模块实现了一个基于计数器值的交通信号灯控制器。在给定时钟信号的上升沿触发下，通过组合逻辑电路计算出当前计数器值所对应的红、黄、绿三种灯的状态，并将其输出到light寄存器中。具体地说，该模块包含一个5位的输入计数器值cnt和一个6位的输出灯状态light，其中light[5:0]分别对应红、黄、绿三种灯的状态。通过在不同的计数器值下控制各个灯的状态变化，从而实现了基于计数器的交通信号灯控制功能。</p><h2 id="毛刺的消除"><a href="#毛刺的消除" class="headerlink" title="毛刺的消除"></a>毛刺的消除</h2><p>在实现了基本的红绿灯代码后，发现执行的结果中存在“毛刺”现象。<br>首先，我们需要确定毛刺的来源。查阅资料，发现毛刺可能源于TLDecoder模块的always @(cnt)敏感性列表。因为当cnt发生变化时，所有的输出信号都会重新计算。这可能会导致不同信号之间的计算不同步，从而引入毛刺。为了解决这个问题，我们可以尝试使用同步的时钟信号来消除毛刺。<br>具体来说，我们可以将TLDecoder模块的输入信号添加一个时钟信号clk，然后将敏感性列表更改为posedge clk。这样，所有的输出信号都将在时钟的上升沿同步更新，从而消除可能的毛刺。不过，请注意，这将使输出信号的更新速度受到时钟频率的限制。请根据具体应用场景调整时钟频率以满足实际需求。</p><h4 id="verilog代码如下"><a href="#verilog代码如下" class="headerlink" title="verilog代码如下"></a>verilog代码如下</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> HardwareCourse(clk,r1,g1,y1,r2,y2,g2);</span><br><span class="line"><span class="keyword">input</span> clk;</span><br><span class="line"><span class="keyword">output</span> r1,y1,g1,r2,y2,g2;</span><br><span class="line"><span class="keyword">wire</span>[<span class="number">4</span>:<span class="number">0</span>] cnt;</span><br><span class="line"></span><br><span class="line">TLCounter u1(clk,cnt);</span><br><span class="line">TLDecoder u2(cnt,&#123;r1,y1,g1,r2,y2,g2&#125;,clk);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> TLCounter(clk,cnt);<span class="comment">//0~27 循环计数</span></span><br><span class="line"><span class="keyword">input</span> clk;</span><br><span class="line"><span class="keyword">output</span>[<span class="number">4</span>:<span class="number">0</span>] cnt;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">4</span>:<span class="number">0</span>] cnt=<span class="number">5&#x27;b00001</span>;</span><br><span class="line"><span class="keyword">assign</span> clr=~(cnt[<span class="number">0</span>]&amp;cnt[<span class="number">1</span>]&amp;(cnt[<span class="number">2</span>])&amp;cnt[<span class="number">3</span>]&amp;cnt[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">cnt[<span class="number">0</span>] &lt;= (~cnt[<span class="number">0</span>]);</span><br><span class="line">cnt[<span class="number">1</span>] &lt;= (cnt[<span class="number">1</span>] ^ cnt[<span class="number">0</span>]);</span><br><span class="line">cnt[<span class="number">2</span>] &lt;= (cnt[<span class="number">2</span>] ^ (cnt[<span class="number">0</span>] &amp; cnt[<span class="number">1</span>]));</span><br><span class="line">cnt[<span class="number">3</span>] &lt;= (cnt[<span class="number">3</span>] ^ (cnt[<span class="number">0</span>] &amp; cnt[<span class="number">1</span>] &amp; cnt[<span class="number">2</span>]));</span><br><span class="line">cnt[<span class="number">4</span>] &lt;= (cnt[<span class="number">4</span>] ^ (cnt[<span class="number">0</span>] &amp; cnt[<span class="number">1</span>] &amp; cnt[<span class="number">2</span>] &amp; cnt[<span class="number">3</span>]));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> TLDecoder(cnt,light,clk);</span><br><span class="line"><span class="keyword">input</span> clk;</span><br><span class="line"><span class="keyword">input</span>[<span class="number">4</span>:<span class="number">0</span>] cnt;</span><br><span class="line"><span class="keyword">output</span>[<span class="number">5</span>:<span class="number">0</span>] light;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">5</span>:<span class="number">0</span>] light=<span class="number">6&#x27;b001100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">light[<span class="number">5</span>]&lt;=((cnt[<span class="number">4</span>]&amp;(~cnt[<span class="number">3</span>]))|(cnt[<span class="number">4</span>]&amp;(~cnt[<span class="number">2</span>]))|((~cnt[<span class="number">4</span>])&amp;cnt[<span class="number">3</span>]&amp;cnt[<span class="number">2</span>]&amp;cnt[<span class="number">1</span>]));</span><br><span class="line">light[<span class="number">4</span>]&lt;=(((~cnt[<span class="number">4</span>])&amp;cnt[<span class="number">3</span>]&amp;(~cnt[<span class="number">2</span>])&amp;cnt[<span class="number">1</span>]&amp;cnt[<span class="number">0</span>])|((~cnt[<span class="number">4</span>])&amp;cnt[<span class="number">3</span>]&amp;cnt[<span class="number">2</span>]&amp;(~cnt[<span class="number">1</span>])));</span><br><span class="line"><span class="comment">//light[3]&lt;=(((~cnt[4])&amp;(~cnt[3]))|((~cnt[4])&amp;(~cnt[2])&amp;(~cnt[1]))|((~cnt[4])&amp;(~cnt[2])&amp;cnt[1]&amp;(~cnt[0])));</span></span><br><span class="line">light[<span class="number">2</span>]&lt;=(((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">3</span>]))|((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">2</span>]))|((~cnt[<span class="number">4</span>])&amp;cnt[<span class="number">2</span>]&amp;(~cnt[<span class="number">1</span>])));</span><br><span class="line">light[<span class="number">1</span>]&lt;=((cnt[<span class="number">4</span>]&amp;cnt[<span class="number">3</span>]&amp;(~cnt[<span class="number">2</span>])&amp;cnt[<span class="number">0</span>])|(cnt[<span class="number">4</span>]&amp;cnt[<span class="number">3</span>]&amp;(~cnt[<span class="number">2</span>])&amp;cnt[<span class="number">1</span>]));</span><br><span class="line"><span class="comment">//light[0]&lt;=((cnt[4]&amp;(~cnt[3]))|(cnt[4]&amp;(~cnt[2])&amp;(~cnt[1])&amp;(~cnt[0]))|((~cnt[4])&amp;cnt[3]&amp;cnt[2])&amp;cnt[1]);</span></span><br><span class="line"></span><br><span class="line">light[<span class="number">3</span>]&lt;=(((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">3</span>])&amp;(~cnt[<span class="number">1</span>]))|((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">3</span>])&amp;(~cnt[<span class="number">2</span>]))|((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">2</span>])&amp;(~cnt[<span class="number">1</span>])&amp;(~cnt[<span class="number">0</span>]))|((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">2</span>])&amp;cnt[<span class="number">1</span>]&amp;(~cnt[<span class="number">0</span>]))|((~cnt[<span class="number">4</span>])&amp;(~cnt[<span class="number">3</span>])&amp;cnt[<span class="number">1</span>]&amp;(~cnt[<span class="number">0</span>])));</span><br><span class="line">light[<span class="number">0</span>]&lt;=((cnt[<span class="number">4</span>]&amp;(~cnt[<span class="number">3</span>])&amp;(~cnt[<span class="number">2</span>]))|(cnt[<span class="number">4</span>]&amp;(~cnt[<span class="number">2</span>])&amp;(~cnt[<span class="number">1</span>])&amp;(~cnt[<span class="number">0</span>]))|(cnt[<span class="number">4</span>]&amp;(~cnt[<span class="number">3</span>])&amp;(~cnt[<span class="number">1</span>])&amp;(~cnt[<span class="number">0</span>]))|(cnt[<span class="number">4</span>]&amp;(~cnt[<span class="number">3</span>])&amp;cnt[<span class="number">1</span>]&amp;(~cnt[<span class="number">0</span>]))|((~cnt[<span class="number">4</span>])&amp;cnt[<span class="number">3</span>]&amp;cnt[<span class="number">2</span>]&amp;cnt[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23年大二下软件课设</title>
      <link href="/2023/06/20/2023-6-20-23%E8%BD%AF%E4%BB%B6%E8%AF%BE%E8%AE%BE/"/>
      <url>/2023/06/20/2023-6-20-23%E8%BD%AF%E4%BB%B6%E8%AF%BE%E8%AE%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="WHSubway-武汉市地铁导引系统"><a href="#WHSubway-武汉市地铁导引系统" class="headerlink" title="WHSubway 武汉市地铁导引系统"></a>WHSubway 武汉市地铁导引系统</h1><p>本系统前端基于<a href="https://blog.csdn.net/qq_42365534/article/details/129887911?spm=1001.2014.3001.5502">electron-vue3+vite</a>脚手架搭建,实现了<del>简陋</del>基础的GUI功能<br>后端用了SpringBoot,mybatis等技术<br>武汉市地铁线路截取日期为2023.5.23日</p><p><strong><em>由于electron的文件太大了,传不到github上,就用夸克网盘吧</em></strong></p><p>夸克网盘地址:<a href="https://pan.quark.cn/s/c24eb516f6c2">WHSubway 武汉市地铁引导系统</a></p><h3 id="以下是实验报告中截取的废话"><a href="#以下是实验报告中截取的废话" class="headerlink" title="以下是实验报告中截取的废话"></a><del>以下是实验报告中截取的废话</del></h3><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>随着城市的快速发展，武汉市地铁系统不断扩建，已成为市民出行的重要交通方式之一。然而由于线路复杂、站点众多，乘客常常面临选择路线困难的问题。因此，如何高效地引导乘客选择最合适的路线已是一个具有挑战性的问题。<br>为了解决这个问题，武汉市地铁导引系统应运而生。该系统可以让乘客输入起始站点和目的站点，自动计算最短路线，并在路线信息中提供换乘方案，以便乘客提前规划出行路线。这不仅可以缓解乘客选择路线的困难，还能减少拥挤，优化地铁运营效率。<br>武汉市地铁导引系统使用了最新的技术，基于Electron-Vite-Vue框架实现了图形化界面，使用户操作更加友好和方便。同时，前后端分离的设计，采用MyBatis和MySQL数据库进行数据管理，采用SpringBoot的后端框架，使得系统更加易于更新和维护，也增强了系统的可靠性和稳定性。<br>武汉市地铁导引系统基于2023.5.27的武汉地铁线路，但随着地铁线路不断扩建和更新，该系统也可以通过修改后端的数据库不断完善和更新，以满足不同时间段、不同线路的乘客需求。武汉市地铁导引系统将为城市居民提供了更加便捷、快速、准确的出行选择。</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><h4 id="图形化界面"><a href="#图形化界面" class="headerlink" title="图形化界面"></a>图形化界面</h4><p>为了便于乘客使用，需要设计一个简单的图形化界面，让用户能直观的了解系统的使用方法和用途。GUI中要对用户的操作进行引导，例如选择站点的下拉菜单选项比较多，所以设计用户能直接在选项栏中进行输入以进行模糊搜索，同时需要对用户的操作进行初步的判断与纠错，以减轻后端的负担，例如，用户未输入站点就点击提交时，提示用户输入站点，而不是直接把数据提交给后端处理查询。</p><h4 id="获取最短路径"><a href="#获取最短路径" class="headerlink" title="获取最短路径"></a>获取最短路径</h4><p>获取最短路径是本系统的核心算法，为了实现最短路径的查询，使用广度优先搜索BFS算法，这样可以较快的找到经过站点最少的地铁线路。</p><h4 id="换乘判断"><a href="#换乘判断" class="headerlink" title="换乘判断"></a>换乘判断</h4><p>为了方便用户进行路线的规划，本系统需要展示换乘站点，为了实现换乘站点的查询，需要进行换乘判断，并输出将要换乘的线路。</p><h4 id="缩略地图放大"><a href="#缩略地图放大" class="headerlink" title="缩略地图放大"></a>缩略地图放大</h4><p>为了让用户在查询查询前能找到想去的站点，差查询后能对查找到的线路进行概览，需要将界面上缩略地图进行局部的放大，以便于用户方便的查看大地图。</p><p><img src="https://img-blog.csdnimg.cn/ef1f6e21aa5c43baa3ed2a09c400de29.png" alt="欢迎界面"><br><img src="https://img-blog.csdnimg.cn/ecab171b5417476db0ee3cff54b72582.jpeg" alt="线路查找示意"></p>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23/6/20 算法每日一题</title>
      <link href="/2023/06/20/2023-6-20-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2023/06/20/2023-6-20-%E7%AE%97%E6%B3%95%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>题目:<a href="https://ac.nowcoder.com/acm/contest/59284/E">幼稚园的树2</a></p><p>牛牛在幼稚园做义工，幼稚园中共有 n 棵树，第 1 天中午时它们的高度分别为：ℎ1,ℎ2,…,ℎn（单位：毫米）。</p><p>每一天的晚上第 i 棵树的高度会增加 ai毫米，而牛牛的任务则是在第二天的清晨检查每一棵树的高度，若某棵树的高度超过了 k 毫米牛牛就会将它的高度修剪为 b 毫米。</p><p>牛牛想请你帮它计算一下第 m 天中午每一棵树的高度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cut</span><span class="params">(<span class="type">int</span> h,<span class="type">int</span> ch,<span class="type">int</span> ach,<span class="type">int</span> gr,<span class="type">int</span> day)</span><span class="comment">//初始高度,要修剪的高度,修剪后高度,每天生长高度,天数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cd1 = (ch-h)/gr+<span class="number">1</span>;<span class="comment">//第一轮到初始值需要的时间</span></span><br><span class="line">    <span class="keyword">if</span>(day&lt;cd1) <span class="keyword">return</span> h+gr*day;</span><br><span class="line">    <span class="keyword">else</span> day-=cd1,h=ach;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cut_r = (ch-ach)/gr+<span class="number">1</span>;<span class="comment">//修剪后要生长的高度/每天生长高度 向上取整 =&gt; 每次修剪间隔的时间</span></span><br><span class="line">    <span class="keyword">return</span> ach+gr*(day%cut_r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> n,m,k,b;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tree[N];</span><br><span class="line"><span class="type">int</span> grow[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;cut(4,10,3,2,4);//初始高度为4,长到10后修建为3,每天长2,长4天</span></span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;b;<span class="comment">//树数,第m天,长到k剪为b</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tree[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;grow[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cout&lt;&lt;<span class="built_in">cut</span>(tree[i],k,b,grow[i],m<span class="number">-1</span>)&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>王道数据结构书-线性表作业2</title>
      <link href="/2023/03/23/2023-3-23-%E7%8E%8B%E9%81%93%E7%AE%97%E6%B3%95%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/03/23/2023-3-23-%E7%8E%8B%E9%81%93%E7%AE%97%E6%B3%95%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="太菜了-简单题也要看答案的思路-T-T"><a href="#太菜了-简单题也要看答案的思路-T-T" class="headerlink" title="太菜了,简单题也要看答案的思路 T T"></a>太菜了,简单题也要看答案的思路 T T</h3><div class="row">    <embed src="https://pic-bed-1wt.pages.dev/files/2022王道算法2.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王道数据结构书-线性表作业1</title>
      <link href="/2023/03/19/2023-3-19-%E7%8E%8B%E9%81%93%E7%AE%97%E6%B3%95%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2023/03/19/2023-3-19-%E7%8E%8B%E9%81%93%E7%AE%97%E6%B3%95%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="https://pic-bed-1wt.pages.dev/files/2022王道算法1.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《惠子，凝视》：比赛落幕，生活如旧</title>
      <link href="/2023/02/23/2023-2-23-%E3%80%8A%E6%83%A0%E5%AD%90%EF%BC%8C%E5%87%9D%E8%A7%86%E3%80%8B/"/>
      <url>/2023/02/23/2023-2-23-%E3%80%8A%E6%83%A0%E5%AD%90%EF%BC%8C%E5%87%9D%E8%A7%86%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="《惠子，凝视》：比赛落幕，生活如旧"><a href="#《惠子，凝视》：比赛落幕，生活如旧" class="headerlink" title="《惠子，凝视》：比赛落幕，生活如旧"></a>《惠子，凝视》：比赛落幕，生活如旧</h1><p>心情乱糟糟的，挑了一个之前收藏的日影来缓解一下。<br>电影的对话很少，但影调有惊艳到我，非常浓的日影味。刚开始不知道女主的情况，还纳闷为什么女主一直不说话。<br>明明只是个大学生，就这么喜欢日影，感觉有点太老成了。惠子先天失聪，会长大病，全馆也关了，最后收到大家瞩目的比赛也输了<br>惠子最强烈的情感表达，也只是因为听不到裁判的声音而错失机会的怒号。<br>无论怎样，生活仍在继续，次日黄昏，惠子依然出现在河畔跑步，在工作时指导后辈折好床单角。<br>惠子回到了酒店工作，惠子的对手回到了建筑工地，无关赛场上的胜负，一切喧嚣最终都会归于寂静。<br><img src="https://pic-bed-1wt.pages.dev/img/《惠子，凝视》.jpg" style= 'width="80%" align="left"'>  </p>]]></content>
      
      
      <categories>
          
          <category> 观影墙 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影 </tag>
            
            <tag> 日影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鼠鼠の寒假Vlog</title>
      <link href="/2023/02/19/2023-2-20-%E9%BC%A0%E9%BC%A0Vlog/"/>
      <url>/2023/02/19/2023-2-20-%E9%BC%A0%E9%BC%A0Vlog/</url>
      
        <content type="html"><![CDATA[<h3 id="鼠鼠我呀，要暑假才能再见到鼠鼠了捏"><a href="#鼠鼠我呀，要暑假才能再见到鼠鼠了捏" class="headerlink" title="鼠鼠我呀，要暑假才能再见到鼠鼠了捏"></a>鼠鼠我呀，要暑假才能再见到鼠鼠了捏</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=567231124&bvid=BV15v4y1s7VB&cid=1016043469&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><h3 id="整个活"><a href="#整个活" class="headerlink" title="整个活"></a>整个活</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=267212852&bvid=BV1HY411Y7PJ&cid=1016135232&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div>]]></content>
      
      
      <categories>
          
          <category> 茶余饭后 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vlog </tag>
            
            <tag> 动物朋友 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拿证！</title>
      <link href="/2023/02/17/2023-2-17-%E6%8B%BF%E8%AF%81%EF%BC%81/"/>
      <url>/2023/02/17/2023-2-17-%E6%8B%BF%E8%AF%81%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h3 id="拿证啦！花了一个月时间终于拿到了"><a href="#拿证啦！花了一个月时间终于拿到了" class="headerlink" title="拿证啦！花了一个月时间终于拿到了"></a>拿证啦！花了一个月时间终于拿到了</h3><p>　　练车第一天遇见的大叔，一开始就是练踩油门和挂挡，大叔看我无聊，过来教我倒车入库，他随便教了下，我还真学会了，后面也总是看见他。刚开始还以为大叔是个很闲的人，后来知道他在驾校附近的工厂工作，跟我一样想早点拿证，所以就也天天来练车。最后结果也不错，我们科目一到科目三都是一起考试的，都是一遍过。本来昨天科四还在到处找他没看见，应该以后也见不到他了吧…应该加个微信的，还有一个小姐姐，也是一起考的科二，也祝她暑假科三一把过。<br>　　没想到考驾照能直接全部一把过，如果挂了还要多花不少钱呢。<br>　　总之痛苦的学车生活结束了，暑假也不用再晒大太阳去练车了，寒假一个月拿证的flag也实现了，其实开车真的不难，而且开习惯了开那种好开的路感觉还很爽。<br>　　感谢教练，感谢一起练车的大叔！<br><img src="https://pic-bed-1wt.pages.dev/img/拿证1.png" width="50%"><br><img src="https://pic-bed-1wt.pages.dev/img/拿证2.png" width="50%"></p>]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大二学生寒假自律的一天</title>
      <link href="/2023/02/10/2023-2-11-%E8%9C%88%E8%9A%A3%E5%A4%A7%E5%AD%A6%E7%94%9F%E8%87%AA%E5%BE%8B%E7%9A%84%E4%B8%80%E5%A4%A9Vlog/"/>
      <url>/2023/02/10/2023-2-11-%E8%9C%88%E8%9A%A3%E5%A4%A7%E5%AD%A6%E7%94%9F%E8%87%AA%E5%BE%8B%E7%9A%84%E4%B8%80%E5%A4%A9Vlog/</url>
      
        <content type="html"><![CDATA[<h3 id="家访班会展示用，制作时长两时半-gt"><a href="#家访班会展示用，制作时长两时半-gt" class="headerlink" title="家访班会展示用，制作时长两时半:&gt;"></a>家访班会展示用，制作时长两时半:&gt;</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=779212716&bvid=BV1J14y1c7sJ&cid=1002396299&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div>]]></content>
      
      
      <categories>
          
          <category> 茶余饭后 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vlog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科三一把过</title>
      <link href="/2023/02/10/2023-2-10-%E7%A7%91%E4%B8%89%E4%B8%80%E6%8A%8A%E8%BF%87/"/>
      <url>/2023/02/10/2023-2-10-%E7%A7%91%E4%B8%89%E4%B8%80%E6%8A%8A%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="本人于公元2023年2月2日进行的科目三-道路驾驶技能考试一次通过，特此公告！"><a href="#本人于公元2023年2月2日进行的科目三-道路驾驶技能考试一次通过，特此公告！" class="headerlink" title="本人于公元2023年2月2日进行的科目三 道路驾驶技能考试一次通过，特此公告！"></a>本人于公元2023年2月2日进行的科目三 道路驾驶技能考试一次通过，特此公告！</h3><!-- ![成绩](https://pic-bed-1wt.pages.dev/img/%E7%A7%91%E7%9B%AE%E4%B8%89.png) --><p><img src="https://pic-bed-1wt.pages.dev/img/拿证1.png" width="50%"></p>]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科二一把过</title>
      <link href="/2023/02/02/2023-2-2-%E7%A7%91%E4%BA%8C%E4%B8%80%E6%8A%8A%E8%BF%87/"/>
      <url>/2023/02/02/2023-2-2-%E7%A7%91%E4%BA%8C%E4%B8%80%E6%8A%8A%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="本人于公元2023年2月2日进行的场地驾驶技能考试（科目二）一次通过，特此公告（狗头）！"><a href="#本人于公元2023年2月2日进行的场地驾驶技能考试（科目二）一次通过，特此公告（狗头）！" class="headerlink" title="本人于公元2023年2月2日进行的场地驾驶技能考试（科目二）一次通过，特此公告（狗头）！"></a>本人于公元2023年2月2日进行的场地驾驶技能考试（科目二）一次通过，特此公告（狗头）！</h3>]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初学MarkDown语法</title>
      <link href="/2023/01/29/2023-1-29-%E5%88%9D%E5%AD%A6md%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/01/29/2023-1-29-%E5%88%9D%E5%AD%A6md%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="初学MarkDown语法"><a href="#初学MarkDown语法" class="headerlink" title="初学MarkDown语法"></a>初学MarkDown语法</h1><p>年差不多过完了，想写写博客发现没学过md语法…</p><h2 id="学习资料："><a href="#学习资料：" class="headerlink" title="学习资料："></a>学习资料：</h2><p><a href="https://blog.csdn.net/TeFuirnever/article/details/104255022?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167500645516800213086410%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167500645516800213086410&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-104255022-null-null.142^v71^one_line,201^v4^add_ask&amp;utm_term=markdown&amp;spm=1018.2226.3001.4187">Markdown入门指南</a></p><p><a href="https://www.bilibili.com/video/BV1JA411h7Gw/?spm_id_from=333.1007.top_right_bar_window_history.content.click">参考视频：8分钟让你快速掌握Markdown</a></p><p><a href="https://www.fomal.cc/posts/2013454d.html">Markdown语法与外挂标签写法汇总</a></p><p><strong>以下是这次学习的练手</strong></p><hr><h1 id="块元素"><a href="#块元素" class="headerlink" title="==块元素=="></a>==块元素==</h1><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="…"><a href="#…" class="headerlink" title="…"></a>…</h3><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><p>==我是高亮==</p><p><em>倾斜</em><br><strong>加粗</strong><br><strong><em>倾斜且加粗</em></strong><br><del>划掉</del><br>我是^上标^<br>我是~下标~</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ul><li>一二三四五<ul><li>上山打老虎<ul><li>老虎没打到<ul><li>打到小松鼠</li></ul></li></ul></li></ul></li></ul><ol><li>一二三四五</li><li>上山打老虎</li><li>老虎没打到</li><li>打到小松鼠</li></ol><p>明天要做的事:</p><ul><li>[ ] 吃饭</li><li>[ ] 睡觉</li><li>[x] 打豆豆</li></ul><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><div class="table-container"><table><thead><tr><th style="text-align:center">Mon</th><th style="text-align:center">Tue</th><th style="text-align:center">Wed</th><th style="text-align:center">Thu</th><th style="text-align:center">Fri</th><th style="text-align:center">Sat</th><th style="text-align:center">Sun</th></tr></thead><tbody><tr><td style="text-align:center">上山</td><td style="text-align:center">上山</td><td style="text-align:center">上山</td><td style="text-align:center">上山</td><td style="text-align:center">上山</td><td style="text-align:center">上山</td><td style="text-align:center">上山</td></tr></tbody></table></div><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><code>我是单行代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>这是一段引用</p></blockquote><h2 id="行文"><a href="#行文" class="headerlink" title="行文"></a>行文</h2><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>我是<sup><a href="#fn_脚注" id="reffn_脚注">脚注</a></sup></p><p>横线</p><hr><h1 id="行元素"><a href="#行元素" class="headerlink" title="==行元素=="></a>==行元素==</h1><p><a href="www.bilibili.com" title="一个视频网站">b站</a></p><p><a href="www.bilibili.com" title="一个视频网站">b站</a></p><p>请参考<a href="# 块元素">块元素</a></p><p>ULR:<br><a href="http://www.bilibili.com">http://www.bilibili.com</a></p><iframe src="//player.bilibili.com/player.html?aid=327623069&bvid=BV1JA411h7Gw&cid=171385214&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20岁生日随笔</title>
      <link href="/2023/01/19/2023-1-19-20%E5%B2%81%E7%94%9F%E6%97%A5%E9%9A%8F%E7%AC%94/"/>
      <url>/2023/01/19/2023-1-19-20%E5%B2%81%E7%94%9F%E6%97%A5%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<h3 id="20岁生日随笔-作为网站第一篇文章补档发布"><a href="#20岁生日随笔-作为网站第一篇文章补档发布" class="headerlink" title="20岁生日随笔 作为网站第一篇文章补档发布~"></a>20岁生日随笔 作为网站第一篇文章补档发布~</h3><p>感觉还没反应过来就已经二十了<br>我从未像今年一样，决绝的彻底的想要告别我的19岁，迎接20岁。20岁真的会好吗？说实话我也不知道。只能说，答案在空中飘荡。<br>进入大学后，总是陷入周期性的焦虑，渐渐失掉了高中时高远的追求，又被无力感所裹挟，不知道未来会怎样。我开始厌倦用宏大叙事，用公共的视角看待社会，厌倦应付学校中那些不必要的形式，面对不断涌入的负面信息，我选择了逃避；我发现在时代的洪流面前，逃避和退缩也许并不可耻。与其试图改变无法改变的事，不如趁着秋日午后，爬上宿舍天台，蹲守一朵檐上的云；不如约上三两好友，去巷角的咖啡店，打扰猫咪的甜梦；安心于当下，享受每一个“非必要的瞬间”。<br>于是，我开始学着变得简单，变得不再贪婪，只愿这一生有所值得。新的一岁，我要明确地爱，直接的厌恶，真诚的喜欢，拥有站在太阳下的坦荡，大声无愧地称赞自己。祝我的朋友们，值得一切。快乐，平安，炽热或静好，努力收获回报！<br>“你且听这荒唐 春秋走来一步步，你且迷这风浪 永远二十赶朝暮，将昨日事，归欢喜处，我们都需要自渡。”</p>]]></content>
      
      
      <categories>
          
          <category> 茶余饭后 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>优质转载测试</title>
      <link href="/2023/01/19/2023-1-19-%E4%BC%98%E8%B4%A8%E8%BD%AC%E8%BD%BD/"/>
      <url>/2023/01/19/2023-1-19-%E4%BC%98%E8%B4%A8%E8%BD%AC%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="这是第一篇优质转载"><a href="#这是第一篇优质转载" class="headerlink" title="这是第一篇优质转载"></a>这是第一篇优质转载</h2>]]></content>
      
      
      <categories>
          
          <category> 优质转载 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>知识笔记测试</title>
      <link href="/2023/01/19/2023-1-19-%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/19/2023-1-19-%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是第一篇知识笔记"><a href="#这是第一篇知识笔记" class="headerlink" title="这是第一篇知识笔记"></a>这是第一篇知识笔记</h2><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol>]]></content>
      
      
      <categories>
          
          <category> 知识笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法学习测试</title>
      <link href="/2023/01/19/2023-1-19-%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/01/19/2023-1-19-%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是第一篇算法学习测试"><a href="#这是第一篇算法学习测试" class="headerlink" title="这是第一篇算法学习测试"></a>这是第一篇算法学习测试</h2>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>生活日常测试</title>
      <link href="/2023/01/19/2023-1-19-%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8/"/>
      <url>/2023/01/19/2023-1-19-%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="这是一篇测试"><a href="#这是一篇测试" class="headerlink" title="这是一篇测试"></a>这是一篇测试</h2>]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
