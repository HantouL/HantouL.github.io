<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>半岛Hantou的博客</title>
  
  
  <link href="https://hantoul.github.io/atom.xml" rel="self"/>
  
  <link href="https://hantoul.github.io/"/>
  <updated>2025-03-13T08:53:47.000Z</updated>
  <id>https://hantoul.github.io/</id>
  
  <author>
    <name>半岛Hantou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分类实战——以AlexNet为例的代码详解</title>
    <link href="https://hantoul.github.io/2025/03/13/2025-3-13-%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%BB%A5AlexNet%E4%B8%BA%E4%BE%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <id>https://hantoul.github.io/2025/03/13/2025-3-13-%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%BB%A5AlexNet%E4%B8%BA%E4%BE%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-03-13T08:53:44.000Z</published>
    <updated>2025-03-13T08:53:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分类实战——以AlexNet为例的代码详解"><a href="#分类实战——以AlexNet为例的代码详解" class="headerlink" title="分类实战——以AlexNet为例的代码详解"></a>分类实战——以AlexNet为例的代码详解</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个自定义的神经网络模型类，继承自 nn.Module</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myModel</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_cls</span>):</span><br><span class="line">        <span class="built_in">super</span>(myModel, self).__init__()  <span class="comment"># 调用父类的构造函数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义第一个卷积层</span></span><br><span class="line">        <span class="comment"># 输入通道数为3（RGB图像），输出通道数为64，卷积核大小为11x11，步长为4，padding为2</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">64</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 定义第一个最大池化层，池化核大小为3x3，步长为2</span></span><br><span class="line">        self.pool1 = nn.MaxPool2d(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义第二个卷积层</span></span><br><span class="line">        <span class="comment"># 输入通道数为64，输出通道数为192，卷积核大小为5x5，步长为1，padding为2</span></span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">64</span>, <span class="number">192</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 定义第二个最大池化层，池化核大小为3x3，步长为2</span></span><br><span class="line">        self.pool2 = nn.MaxPool2d(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义第三个卷积层</span></span><br><span class="line">        <span class="comment"># 输入通道数为192，输出通道数为384，卷积核大小为5x5，步长为1，padding为2</span></span><br><span class="line">        self.conv3 = nn.Conv2d(<span class="number">192</span>, <span class="number">384</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 定义第四个卷积层</span></span><br><span class="line">        <span class="comment"># 输入通道数为384，输出通道数为256，卷积核大小为5x5，步长为1，padding为2</span></span><br><span class="line">        self.conv4 = nn.Conv2d(<span class="number">384</span>, <span class="number">256</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 定义第五个卷积层</span></span><br><span class="line">        <span class="comment"># 输入通道数为256，输出通道数为256，卷积核大小为5x5，步长为1，padding为2</span></span><br><span class="line">        self.conv5 = nn.Conv2d(<span class="number">256</span>, <span class="number">256</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义第三个最大池化层，池化核大小为3x3，步长为2</span></span><br><span class="line">        self.pool3 = nn.MaxPool2d(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 定义自适应平均池化层，输出大小为6x6</span></span><br><span class="line">        self.pool4 = nn.AdaptiveAvgPool2d(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义第一个全连接层，输入特征数为9216，输出特征数为4096</span></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">9216</span>, <span class="number">4096</span>)</span><br><span class="line">        <span class="comment"># 定义第二个全连接层，输入特征数为4096，输出特征数为4096</span></span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">4096</span>, <span class="number">4096</span>)</span><br><span class="line">        <span class="comment"># 定义第三个全连接层，输入特征数为4096，输出特征数为num_cls（分类类别数）</span></span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">4096</span>, num_cls)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义前向传播函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># 第一层卷积和池化</span></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = self.pool1(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二层卷积和池化</span></span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = self.pool2(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第三、四、五层卷积</span></span><br><span class="line">        x = self.conv3(x)</span><br><span class="line">        x = self.conv4(x)</span><br><span class="line">        x = self.conv5(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第三层池化和自适应平均池化</span></span><br><span class="line">        x = self.pool3(x)</span><br><span class="line">        x = self.pool4(x)  <span class="comment"># 输出形状为 batch*256*6*6</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将多维张量展平为一维，以便输入全连接层</span></span><br><span class="line">        x = x.view(x.size()[<span class="number">0</span>], -<span class="number">1</span>)  <span class="comment"># 形状变为 batch*9216</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 全连接层</span></span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        x = self.fc3(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x  <span class="comment"># 返回最终的输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个模型实例，num_cls为1000（假设有1000个分类类别）</span></span><br><span class="line">model = myModel(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个形状为 (4, 3, 224, 224) 的输入张量，表示4张3通道的224x224图像</span></span><br><span class="line">data = torch.ones((<span class="number">4</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将输入数据传入模型，得到预测结果</span></span><br><span class="line">pred = model(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，用于计算模型的参数数量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_parameter_number</span>(<span class="params">model</span>):</span><br><span class="line">    <span class="comment"># 计算模型的总参数数量</span></span><br><span class="line">    total_num = <span class="built_in">sum</span>(p.numel() <span class="keyword">for</span> p <span class="keyword">in</span> model.parameters())</span><br><span class="line">    <span class="comment"># 计算模型中可训练的参数数量</span></span><br><span class="line">    trainable_num = <span class="built_in">sum</span>(p.numel() <span class="keyword">for</span> p <span class="keyword">in</span> model.parameters() <span class="keyword">if</span> p.requires_grad)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;Total&#x27;</span>: total_num, <span class="string">&#x27;Trainable&#x27;</span>: trainable_num&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印模型的参数数量</span></span><br><span class="line"><span class="built_in">print</span>(get_parameter_number(model))</span><br></pre></td></tr></table></figure><p>nn.Conv2d()的参数分别为</p><blockquote><p>输入特征图数量<br>输出特征图数量<br>卷积核大小<br>步长<br>padding</p></blockquote><h2 id="各层次的代码"><a href="#各层次的代码" class="headerlink" title="各层次的代码"></a>各层次的代码</h2><h3 id="卷积第一层"><a href="#卷积第一层" class="headerlink" title="卷积第一层"></a>卷积第一层</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义第一个卷积层</span></span><br><span class="line"><span class="comment"># 输入通道数为3（RGB图像），输出通道数为64，卷积核大小为11x11，步长为4，padding为2</span></span><br><span class="line">self.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">64</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 定义第一个最大池化层，池化核大小为3x3，步长为2</span></span><br><span class="line">self.pool1 = nn.MaxPool2d(<span class="number">3</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>我们输入的原始图片尺寸为3通道，我们用Conv2d转化为64通道输出，在Conc2d中使用长度为11的卷积核，步长为4，边框长度2</p><blockquote><p>这时获取的特征图尺寸为 64 <em> [(224 - 11 + 2</em>2)/4 + 1]^2, 即64 <em> 55 </em> 55</p></blockquote><p>再通过池化，<code>nn.MaxPool2d(3, 2)</code>表示窗口大小为3*3，滑动步长为2</p><p>输出特征图尺寸为：[64 <em> (55 - 3 +0)/2 + 1]^2 即 64</em> 27*27</p><h3 id="卷积第二层"><a href="#卷积第二层" class="headerlink" title="卷积第二层"></a>卷积第二层</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义第二个卷积层</span></span><br><span class="line"><span class="comment"># 输入通道数为64，输出通道数为192，卷积核大小为5x5，步长为1，padding为2</span></span><br><span class="line">self.conv2 = nn.Conv2d(<span class="number">64</span>, <span class="number">192</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 定义第二个最大池化层，池化核大小为3x3，步长为2</span></span><br><span class="line">self.pool2 = nn.MaxPool2d(<span class="number">3</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>将特征图尺寸化为192<em> [(27-5+2</em>2)/1 +1] <em>2，即192 </em> 27 *27</p><p>同理，再进行池化，化为192<em>13 </em>13</p><h3 id="卷积第三四五层"><a href="#卷积第三四五层" class="headerlink" title="卷积第三四五层"></a>卷积第三四五层</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义第三个卷积层</span></span><br><span class="line"><span class="comment"># 输入通道数为192，输出通道数为384，卷积核大小为5x5，步长为1，padding为2</span></span><br><span class="line">self.conv3 = nn.Conv2d(<span class="number">192</span>, <span class="number">384</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 定义第四个卷积层</span></span><br><span class="line"><span class="comment"># 输入通道数为384，输出通道数为256，卷积核大小为5x5，步长为1，padding为2</span></span><br><span class="line">self.conv4 = nn.Conv2d(<span class="number">384</span>, <span class="number">256</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 定义第五个卷积层</span></span><br><span class="line"><span class="comment"># 输入通道数为256，输出通道数为256，卷积核大小为5x5，步长为1，padding为2</span></span><br><span class="line">self.conv5 = nn.Conv2d(<span class="number">256</span>, <span class="number">256</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>通过三次连续的卷积变换将特征图尺寸变为256<em> 13</em> 13</p><h3 id="再池化两次"><a href="#再池化两次" class="headerlink" title="再池化两次"></a>再池化两次</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义第三个最大池化层，池化核大小为3x3，步长为2</span></span><br><span class="line">self.pool3 = nn.MaxPool2d(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 定义自适应平均池化层，输出大小为6x6</span></span><br><span class="line">self.pool4 = nn.AdaptiveAvgPool2d(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>再通过两次池化，进一步缩小特征图，将尺寸缩小为256 <em> 6 </em> 6</p><h3 id="将特征图降维成一维的"><a href="#将特征图降维成一维的" class="headerlink" title="将特征图降维成一维的"></a>将特征图降维成一维的</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将多维张量展平为一维，以便输入全连接层</span></span><br><span class="line">x = x.view(x.size()[<span class="number">0</span>], -<span class="number">1</span>)  <span class="comment"># 形状变为 batch*9216</span></span><br></pre></td></tr></table></figure><h3 id="再通过全连接层建立模型"><a href="#再通过全连接层建立模型" class="headerlink" title="再通过全连接层建立模型"></a>再通过全连接层建立模型</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义第一个全连接层，输入特征数为9216，输出特征数为4096</span></span><br><span class="line">self.fc1 = nn.Linear(<span class="number">9216</span>, <span class="number">4096</span>)</span><br><span class="line"><span class="comment"># 定义第二个全连接层，输入特征数为4096，输出特征数为4096</span></span><br><span class="line">self.fc2 = nn.Linear(<span class="number">4096</span>, <span class="number">4096</span>)</span><br><span class="line"><span class="comment"># 定义第三个全连接层，输入特征数为4096，输出特征数为num_cls（分类类别数）</span></span><br><span class="line">self.fc3 = nn.Linear(<span class="number">4096</span>, num_cls)</span><br></pre></td></tr></table></figure><p>这里和回归是一致的，不做过多叙述</p><hr><h2 id="各个层的作用"><a href="#各个层的作用" class="headerlink" title="各个层的作用"></a>各个层的作用</h2><h3 id="卷积层-self-conv1-self-conv2-self-conv3-self-conv4-self-conv5"><a href="#卷积层-self-conv1-self-conv2-self-conv3-self-conv4-self-conv5" class="headerlink" title="卷积层 (self.conv1, self.conv2, self.conv3, self.conv4, self.conv5)"></a>卷积层 (<code>self.conv1</code>, <code>self.conv2</code>, <code>self.conv3</code>, <code>self.conv4</code>, <code>self.conv5</code>)</h3><p>卷积操作可以<strong>捕捉图像的局部信息</strong>，通过共享权重<strong>减少参数量</strong>，还可以<strong>提取更高级、复杂、抽象的特征</strong></p><h3 id="池化层-self-pool1-self-pool2-self-pool3"><a href="#池化层-self-pool1-self-pool2-self-pool3" class="headerlink" title="池化层 (self.pool1, self.pool2, self.pool3)"></a>池化层 (<code>self.pool1</code>, <code>self.pool2</code>, <code>self.pool3</code>)</h3><p>池化层可以通过对特征图进行下采样，<strong>降低计算量</strong>，<strong>防止过拟合</strong></p><h3 id="自适应平均池化层-self-pool4"><a href="#自适应平均池化层-self-pool4" class="headerlink" title="自适应平均池化层 (self.pool4)"></a>自适应平均池化层 (<code>self.pool4</code>)</h3><p>它将特征图尺寸调整为固定的输出尺寸，方便后面的全连接层进行处理</p><p>这里使用平均池化，可以让特征图更平滑</p><h3 id="展平操作-x-view-x-size-0-1"><a href="#展平操作-x-view-x-size-0-1" class="headerlink" title="展平操作 (x.view(x.size()[0], -1))"></a>展平操作 (<code>x.view(x.size()[0], -1)</code>)</h3><p>将多维特征图降维成一维向量，便于后续分类</p><h3 id="全连接层-self-fc1-self-fc2-self-fc3"><a href="#全连接层-self-fc1-self-fc2-self-fc3" class="headerlink" title="全连接层 (self.fc1, self.fc2, self.fc3)"></a>全连接层 (<code>self.fc1</code>, <code>self.fc2</code>, <code>self.fc3</code>)</h3><p>将提取的特征通过全连接层映射到分类任务中</p><hr><h3 id="整体过程"><a href="#整体过程" class="headerlink" title="整体过程"></a>整体过程</h3><blockquote><ul><li><strong>特征提取</strong>:<ul><li>卷积层和池化层逐步提取输入图像的低级到高级特征。</li></ul></li><li><strong>降维</strong>:<ul><li>池化层和自适应池化层减少特征图的空间尺寸，降低计算复杂度。</li></ul></li><li><strong>特征组合</strong>:<ul><li>全连接层将提取的特征组合起来，生成最终的分类结果。</li></ul></li><li><strong>分类</strong>:<ul><li>最后一层全连接层输出每个类别的得分，用于分类任务。</li></ul></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分类实战——以AlexNet为例的代码详解&quot;&gt;&lt;a href=&quot;#分类实战——以AlexNet为例的代码详解&quot; class=&quot;headerlink&quot; title=&quot;分类实战——以AlexNet为例的代码详解&quot;&gt;&lt;/a&gt;分类实战——以AlexNet为例的代码详解&lt;/</summary>
      
    
    
    
    <category term="知识笔记" scheme="https://hantoul.github.io/categories/%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="深度学习" scheme="https://hantoul.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="AI" scheme="https://hantoul.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>初识神经网络的分类问题</title>
    <link href="https://hantoul.github.io/2025/03/03/2025-3-3-%E5%88%9D%E8%AF%86%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    <id>https://hantoul.github.io/2025/03/03/2025-3-3-%E5%88%9D%E8%AF%86%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/</id>
    <published>2025-03-03T15:32:49.000Z</published>
    <updated>2025-03-03T15:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识神经网络的分类问题"><a href="#初识神经网络的分类问题" class="headerlink" title="初识神经网络的分类问题"></a>初识神经网络的分类问题</h1><p>在接触分类问题之前，我们先学过了回归问题</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503032211354.png" alt="image-20250303221101224"></p><ul><li><strong>回归</strong>问题是找一个神秘的函数关系，来匹配并预测每个数据点的位置</li><li>而<strong>分类</strong>问题是要寻找到一个方法，将数据集划分为若干类，每个类中都有神秘的共性，我们要找的模型就是区分他们的方法</li></ul><p>以图片分类为例，我们给电脑投喂一组照片，里面有<code>[猫，狗，树]</code>，但我们知道，机器学习的输出是数学形式，所以我们要使用<code>One-hot独热编码</code>来表示模型输出的结果</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503032215221.png" alt="image-20250303221538164"></p><p>类似于计组中的指令编码方法，每一类表达不同的种类的概率，在上述例子中，每位分别表示图片为狗、猫、树的概率</p><h2 id="简述训练流程的各种问题"><a href="#简述训练流程的各种问题" class="headerlink" title="简述训练流程的各种问题"></a>简述训练流程的各种问题</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503032227756.png" alt="image-20250303222722667"></p><p>输入一幅图片（图片天生就是矩阵），模型对矩阵进行预测，然后输出各个分类的概率，在对概率进行处理，最后得到分类的结果</p><h3 id="如何理解图片作为输入源"><a href="#如何理解图片作为输入源" class="headerlink" title="如何理解图片作为输入源"></a>如何理解图片作为输入源</h3><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503032257820.png" alt="image-20250303225735722"></p><p>所有颜色都可以通过RGB三维色彩坐标来表示，所以所有图片可以拆解为红绿蓝三层</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503032230573.png" alt="image-20250303223026495"></p><p>对于不同中的像素点，对于该层的颜色来说，又有不同的灰度，这时的灰度值就作为这个该层中此像素点的值</p><p>但是在上次学的回归中，输入的都是一维张量，对于矩阵来说，我们同样可以将他们转换为一维的，只需要将每层的矩阵拉平，再将不同层拼接即可</p><blockquote><p>训练模型的时候，常常将图片尺寸处理为224*224再喂给模型处理</p></blockquote><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503032234139.png" alt="image-20250303223458069"></p><h3 id="一维？何不全连接？"><a href="#一维？何不全连接？" class="headerlink" title="一维？何不全连接？"></a>一维？何不全连接？</h3><p>都把图片降维成一维的了，为什么不直接用全连接找规律呢</p><p>哥们，想想模型的参数数量，224<em> 224 </em> 3初始点位，就算是个层数不高的全连接，产生的参数数量也是非常惊人的，这代价未免也太大了</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503032238810.png" alt="image-20250303223848736"></p><p>显然对于矩阵来说，全连接有点太过粗暴了</p><h3 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h3><blockquote><p>之前学图像处理的时候有接触过一些皮毛，不过当时在准备java的方向就也没认真听，只知道卷积核大概是怎么卷的</p></blockquote><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503032241616.png" alt="image-20250303224137556"></p><p>在上图中，我们将那个比较大的图作为特征图，下面那个小图作为卷积核，用红色表示1，黑色表示-1</p><p>这样就将抽象的图像用数字化的形式表述出来了，我们此时只需要将卷积核在合适的地方与特征图上的数对应相乘，最后将结果记录在新的特征图上即可</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503032249700.gif" alt="img"></p><h3 id="图片的所有组成部分都有意义吗"><a href="#图片的所有组成部分都有意义吗" class="headerlink" title="图片的所有组成部分都有意义吗"></a>图片的所有组成部分都有意义吗</h3><p>我们人脑辨认物体的时候，当然能窥见全貌是最好的，但如果只看见了物体的一部分，也能认出个大概，这部分内容，我们称之为<strong>特征</strong></p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503032257578.png" alt="image-20250303225710512"></p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503032253747.png" alt="image-20250303225300631"></p><p>以这张鸟的图片为例，我们可以将鸟眼、鸟嘴、鸟胯子等等部位作为鸟的特征，并在神经网络的训练中给予这些特征不同的权重</p><blockquote><p>毕竟单看这个鸟嘴的话，好像长在小鸡头上也不是不行</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503032256533.png" alt="image-20250303225635412"></p></blockquote><h3 id="More-About-卷积核"><a href="#More-About-卷积核" class="headerlink" title="More About 卷积核"></a>More About 卷积核</h3><p>之前提到的卷积核，在上面的例子中，就相当于鸟胯子、鸟嘴、鸟眼</p><p>那么我们<strong>怎么选择合适的卷积核？</strong></p><ul><li>更大的卷积核可以拥有<strong>更大的感受野</strong><br><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503032303154.png" alt="image-20250303230130914"></li></ul><p>我们将一张图片通过多个卷积核卷积过后，每个卷积核都各自生成了一张新的特征图，如果我们还想加深，接着卷，就把新生成的这些特征图叠加，继续循环往复，最后形成了下图右下角的克系特征图，已经超出人类能认识的维度了</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503032303277.png" alt="image-20250303230310190"></p><h3 id="如何缩小特征图？"><a href="#如何缩小特征图？" class="headerlink" title="如何缩小特征图？"></a>如何缩小特征图？</h3><p><strong>方法1</strong>：扩大步长；相当与增加取样间隔，但是这样比较慢，而且没考虑到每步之间的数据</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503032312587.png" alt="image-20250303231256523"></p><p><strong>方法2</strong>：依靠Pooling池化</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503032313455.png" alt="image-20250303231317367"></p><h3 id="卷积后的尺寸计算"><a href="#卷积后的尺寸计算" class="headerlink" title="卷积后的尺寸计算"></a>卷积后的尺寸计算</h3><ul><li><p><strong>O = ( I - K + 2P ) / S + 1</strong></p><blockquote><p>O：卷积后新特征图边长</p><p>I：原特征图边长Input</p><p>K：卷积核边长</p><p>P：边距Padding</p><p>S：步长Stride</p></blockquote></li></ul><h3 id="卷积如何计算出最后的类别？"><a href="#卷积如何计算出最后的类别？" class="headerlink" title="卷积如何计算出最后的类别？"></a>卷积如何计算出最后的类别？</h3><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503032317925.png" alt="image-20250303231734855"></p><p>先处理原图，然后输入到模型中进行学习，最后对对于每个类，输出一个数字</p><p>显然这里给出的结果不是对应的概率，这就需要对原始的Loss进行处理</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503032319651.png" alt="image-20250303231924581"></p><p>在上面面的例子中，y的变换公式为<code>yi^ =  (e^yi)/(e^yi + e^yj + e^yk)</code>，显然这样就把原来数值之间的差距拉大了，得到了需要的输出结果</p><blockquote><p>上面公式规范表述为</p><script type="math/tex; mode=display">\hat{y}_i = \frac{     e^{y_i} }{     \sum_{j=1}^C e^{y_j} } \quad \text{where } C \text{ is total number of classes}</script></blockquote><h3 id="分类学习的过程中如何对模型进行优化？"><a href="#分类学习的过程中如何对模型进行优化？" class="headerlink" title="分类学习的过程中如何对模型进行优化？"></a>分类学习的过程中如何对模型进行优化？</h3><p>使用<strong>交叉熵损失</strong>来计算LOSS</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503032324043.png" alt="image-20250303232406976"></p><p>这里并不需要知道交叉熵到底是个啥玩意，直接看二分类的计算方法吧</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503032324286.png" alt="image-20250303232436201"></p><p>显而易见的，Loss需要越小越好，而这里loss要取负号，所以对于大括号内的数，我们需要他越大越好</p><p>我们看训练集的结果</p><p><strong>当y^=0</strong>，对应的y’ 表示预测错误，那么大括号里只剩下了</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503032327663.png" alt="image-20250303232713593"></p><p>更具体地说，只剩下了log(1-y’ ),需要让他越大越好，所以y需要尽可能的小，换而言之，这与我们追求的缩小错误选项的概率不谋而合</p><p>同理，当<strong>y^=1</strong>,只剩下了-y^logy’，这里就需要y’越大越好~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;初识神经网络的分类问题&quot;&gt;&lt;a href=&quot;#初识神经网络的分类问题&quot; class=&quot;headerlink&quot; title=&quot;初识神经网络的分类问题&quot;&gt;&lt;/a&gt;初识神经网络的分类问题&lt;/h1&gt;&lt;p&gt;在接触分类问题之前，我们先学过了回归问题&lt;/p&gt;
&lt;p&gt;&lt;img s</summary>
      
    
    
    
    <category term="知识笔记" scheme="https://hantoul.github.io/categories/%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="深度学习" scheme="https://hantoul.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="AI" scheme="https://hantoul.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>回归实战：预测新冠感染人数</title>
    <link href="https://hantoul.github.io/2025/03/02/2025-3-2-%E5%9B%9E%E5%BD%92%E5%AE%9E%E6%88%98%EF%BC%9A%E9%A2%84%E6%B5%8B%E6%96%B0%E5%86%A0%E6%84%9F%E6%9F%93%E4%BA%BA%E6%95%B0/"/>
    <id>https://hantoul.github.io/2025/03/02/2025-3-2-%E5%9B%9E%E5%BD%92%E5%AE%9E%E6%88%98%EF%BC%9A%E9%A2%84%E6%B5%8B%E6%96%B0%E5%86%A0%E6%84%9F%E6%9F%93%E4%BA%BA%E6%95%B0/</id>
    <published>2025-03-02T13:10:03.000Z</published>
    <updated>2025-03-02T13:10:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回归实战：预测新冠感染人数"><a href="#回归实战：预测新冠感染人数" class="headerlink" title="回归实战：预测新冠感染人数"></a>回归实战：预测新冠感染人数</h1><h2 id="先回顾下回归是个啥玩意"><a href="#先回顾下回归是个啥玩意" class="headerlink" title="先回顾下回归是个啥玩意"></a>先回顾下回归是个啥玩意</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503021913037.png" alt="image-20250302175207806"></p><ol><li>首先需要一组训练集，说人话就是通过一系列x[x1,x2…xn]通过神秘计算得到y的过程，当然人和机器现在都不知道什么计算是什么，这是一个<strong>黑箱</strong>。</li></ol><blockquote><ul><li><strong>黑箱比喻</strong>：把模型想象成自动售货机，投币（输入特征x）→ 内部神秘机制（模型计算）→ 吐出饮料（预测值y^）。</li><li><strong>核心任务</strong>：通过不断调整内部零件（参数w），让售货机吐出的饮料尽可能接近真实需求（真实值y）。</li></ul></blockquote><ol><li><p>然后我们先随机的选定一系列参数，然后把参数和x带入神秘公式，计算出预测值y^</p></li><li><p>将y^与实际的y进行计算，得到误差loss，预测y^与实际y相聚越远，loss显然越大，所以我们可以通过loss来评价一个模型的好坏</p></li><li><p>光知道这模型不准还没用，我们需要让预测值越来越接近，具体来说，就要使用<strong>梯度下降</strong>来将误差反馈给参数w</p><blockquote><p>for example:</p><p>​    w  = w - d(loss)/d(w) * lr</p></blockquote></li><li><p>在这循环往复的过程中，实现了机器的自主学习（额额。。参数不调好，也会越学越垃圾的，就像人学新知识也常常伴随踩雷和反复）</p></li></ol><blockquote><p><strong>训练过程</strong></p><ol><li><strong>随机初始化</strong>：给售货机随便装一堆零件（随机初始参数w）</li><li><strong>预测试错</strong>：投币测试，记录误差（计算预测y^与真实y的Loss）</li><li><strong>梯度下降</strong>：根据误差反向调整零件（w = w - 梯度×学习率）</li><li><strong>循环迭代</strong>：重复投币→调整→测试，直到误差最小</li></ol></blockquote><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503021913976.png" alt="image-20250302191203412"></p><hr><h2 id="实战代码主要部分解析"><a href="#实战代码主要部分解析" class="headerlink" title="实战代码主要部分解析"></a>实战代码主要部分解析</h2><p><a href="https://www.kaggle.com/competitions/ml2021spring-hw1/overview">样例所属的项目kaggle地址</a></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest, chi2</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader, Dataset</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_feature_importance</span>(<span class="params">feature_data, label_data, k =<span class="number">4</span>,column = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    特征重要性选择函数</span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        feature_data : 特征数据矩阵</span></span><br><span class="line"><span class="string">        label_data   : 对应标签数据</span></span><br><span class="line"><span class="string">        k           : 选择的最佳特征数量</span></span><br><span class="line"><span class="string">        column      : 特征名称列表（可选）</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        X_new       : 选择后的特征数据</span></span><br><span class="line"><span class="string">        indices     : 被选特征的列索引</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 使用卡方检验选择特征</span></span><br><span class="line">    model = SelectKBest(chi2, k=k)      <span class="comment">#定义一个选择k个最佳特征的函数</span></span><br><span class="line">    feature_data = np.array(feature_data, dtype=np.float64)<span class="comment"># 确保数据类型为float64以满足sklearn要求</span></span><br><span class="line">    <span class="comment"># label_data = np.array(label_data, dtype=np.float64)</span></span><br><span class="line">    X_new = model.fit_transform(feature_data, label_data)   <span class="comment">#用这个函数选择k个最佳特征</span></span><br><span class="line">    <span class="comment">#feature_data是特征数据，label_data是标签数据，该函数可以选择出k个特征</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x_new&#x27;</span>, X_new)</span><br><span class="line">    scores = model.scores_                <span class="comment"># scores即每一列与结果的相关性</span></span><br><span class="line">    <span class="comment"># 按重要性排序，选出最重要的 k 个</span></span><br><span class="line">    indices = np.argsort(scores)[::-<span class="number">1</span>]        <span class="comment">#[::-1]表示反转一个列表或者矩阵。</span></span><br><span class="line">    <span class="comment"># argsort这个函数， 可以矩阵排序后的下标。 比如 indices[0]表示的是，scores中最小值的下标。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> column:                            <span class="comment"># 如果需要打印选中的列</span></span><br><span class="line">        k_best_features = [column[i+<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> indices[<span class="number">0</span>:k].tolist()]         <span class="comment"># 选中这些列 打印</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;k best features are: &#x27;</span>,k_best_features)</span><br><span class="line">    <span class="keyword">return</span> X_new, indices[<span class="number">0</span>:k]                  <span class="comment"># 返回选中列的特征和他们的下标。</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;COVID数据加载器&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CovidDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">            file_path   : 数据文件路径</span></span><br><span class="line"><span class="string">            mode       : 数据集模式（train/val/test）</span></span><br><span class="line"><span class="string">            all_feature : 是否使用全部特征</span></span><br><span class="line"><span class="string">            feature_dim : 选择特征维度</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 数据预处理：给模型喂“干净粮食”</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, file_path, mode=<span class="string">&quot;train&quot;</span>, all_feature=<span class="literal">False</span>, feature_dim=<span class="number">6</span></span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            ori_data = <span class="built_in">list</span>(csv.reader(f))</span><br><span class="line">            column = ori_data[<span class="number">0</span>]</span><br><span class="line">            csv_data = np.array(ori_data[<span class="number">1</span>:])[:, <span class="number">1</span>:].astype(<span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line">        feature = np.array(ori_data[<span class="number">1</span>:])[:, <span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">        label_data = np.array(ori_data[<span class="number">1</span>:])[:, -<span class="number">1</span>]</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span> all_feature:</span><br><span class="line">            col = np.array([i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">93</span>)])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            _, col = get_feature_importance(feature, label_data, feature_dim, column)</span><br><span class="line">        col = col.tolist()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mode == <span class="string">&quot;train&quot;</span>:  <span class="comment"># 80%训练集</span></span><br><span class="line">            indices = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(csv_data)) <span class="keyword">if</span> i % <span class="number">5</span> != <span class="number">0</span>]</span><br><span class="line">            data = torch.tensor(csv_data[indices, :-<span class="number">1</span>])</span><br><span class="line">            self.y = torch.tensor(csv_data[indices, -<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">elif</span> mode == <span class="string">&quot;val&quot;</span>:  <span class="comment"># 20%验证集</span></span><br><span class="line">            indices = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(csv_data)) <span class="keyword">if</span> i % <span class="number">5</span> == <span class="number">0</span>]</span><br><span class="line">            data = torch.tensor(csv_data[indices, :-<span class="number">1</span>])</span><br><span class="line">            self.y = torch.tensor(csv_data[indices, -<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># test模式</span></span><br><span class="line">            indices = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(csv_data))]</span><br><span class="line">            data = torch.tensor(csv_data[indices])</span><br><span class="line"></span><br><span class="line">        <span class="comment">#  数据标准化处理(将不同尺度的数据变为同一尺度)</span></span><br><span class="line">        data = data[:, col]</span><br><span class="line">        self.data = (data - data.mean(dim=<span class="number">0</span>, keepdim=<span class="literal">True</span>)) / data.std(dim=<span class="number">0</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">        self.mode = mode</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取单条数据&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        <span class="keyword">if</span> self.mode != <span class="string">&quot;test&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> self.data[idx].<span class="built_in">float</span>(), self.y[idx].<span class="built_in">float</span>()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.data[idx].<span class="built_in">float</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上是数据装载部分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyModel</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义全连接神经网络&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, inDim</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">            inDim : 输入特征维度</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>(MyModel, self).__init__()</span><br><span class="line">        self.fc1 = nn.Linear(inDim, <span class="number">64</span>)</span><br><span class="line">        self.relu1 = nn.ReLU()</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">64</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):  <span class="comment"># 模型前向过程</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;前向传播&quot;&quot;&quot;</span></span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = self.relu1(x)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(x.size()) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> x.squeeze(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_val</span>(<span class="params">model, train_loader, val_loader, device, epochs, optimizer, loss, save_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    模型训练与验证函数</span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        model       : 待训练模型</span></span><br><span class="line"><span class="string">        train_loader: 训练数据加载器</span></span><br><span class="line"><span class="string">        val_loader  : 验证数据加载器</span></span><br><span class="line"><span class="string">        device     : 计算设备（CPU/GPU）</span></span><br><span class="line"><span class="string">        epochs     : 训练轮数</span></span><br><span class="line"><span class="string">        optimizer  : 优化器</span></span><br><span class="line"><span class="string">        loss       : 损失函数</span></span><br><span class="line"><span class="string">        save_path  : 模型保存路径</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    model = model.to(device)</span><br><span class="line">    plt_train_loss = []  <span class="comment"># 记录所有轮次的训练loss</span></span><br><span class="line">    plt_val_loss = []  <span class="comment"># 验证loss记录</span></span><br><span class="line"></span><br><span class="line">    min_val_loss = <span class="number">9999999999999999</span>  <span class="comment"># 最佳验证损失初始化</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):  <span class="comment"># 开始训练</span></span><br><span class="line">        train_loss = <span class="number">0.0</span></span><br><span class="line">        val_loss = <span class="number">0.0</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line"></span><br><span class="line">        model.train()  <span class="comment"># 模型调整为训练模式</span></span><br><span class="line">        <span class="keyword">for</span> batch_x, batch_y <span class="keyword">in</span> train_loader:</span><br><span class="line">            x, target = batch_x.to(device), batch_y.to(device)</span><br><span class="line">            pred = model(x)  <span class="comment"># 前向传播</span></span><br><span class="line">            train_bat_loss = loss(pred, target, model)</span><br><span class="line">            train_bat_loss.backward() <span class="comment"># 反向传播</span></span><br><span class="line">            optimizer.step()  <span class="comment"># 更新模型</span></span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            train_loss += train_bat_loss.cpu().item()</span><br><span class="line"></span><br><span class="line">        plt_train_loss.append(train_loss / train_loader.__len__())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 验证阶段</span></span><br><span class="line">        model.<span class="built_in">eval</span>()</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            <span class="keyword">for</span> batch_x, batch_y <span class="keyword">in</span> val_loader:</span><br><span class="line">                x, target = batch_x.to(device), batch_y.to(device)</span><br><span class="line">                pred = model(x)</span><br><span class="line">                val_bat_loss = loss(pred, target, model)</span><br><span class="line">                val_loss += val_bat_loss.cpu().item()</span><br><span class="line">        plt_val_loss.append(val_loss / val_loader.__len__())</span><br><span class="line">        <span class="comment"># 保存最佳模型</span></span><br><span class="line">        <span class="keyword">if</span> val_loss &lt; min_val_loss:</span><br><span class="line">            torch.save(model, save_path)</span><br><span class="line">            min_val_loss = val_loss</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[%03d/%03d] %2.2f sec(s) Trainloss: %.6f | Valloss: %.6f&quot;</span> % \</span><br><span class="line">              (epoch, epochs, time.time() - start_time, plt_train_loss[-<span class="number">1</span>], plt_val_loss[-<span class="number">1</span>]))</span><br><span class="line">    <span class="comment"># 损失曲线可视化</span></span><br><span class="line">    plt.plot(plt_train_loss)</span><br><span class="line">    plt.plot(plt_val_loss)</span><br><span class="line">    plt.title(<span class="string">&quot;loss&quot;</span>)</span><br><span class="line">    plt.legend([<span class="string">&quot;train&quot;</span>, <span class="string">&quot;val&quot;</span>])</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate</span>(<span class="params">save_path, test_loader, device, rel_path</span>):  <span class="comment"># 得出测试结果文件</span></span><br><span class="line">    <span class="comment"># 加载最佳模型</span></span><br><span class="line">    model = torch.load(save_path).to(device)</span><br><span class="line">    rel = []</span><br><span class="line">    <span class="comment"># 预测结果</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> test_loader:</span><br><span class="line">            pred = model(x.to(device))</span><br><span class="line">            rel.append(pred.cpu().item())</span><br><span class="line">    <span class="built_in">print</span>(rel)</span><br><span class="line">    <span class="comment"># 保存CSV结果</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(rel_path, <span class="string">&quot;w&quot;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        csvWriter = csv.writer(f)</span><br><span class="line">        csvWriter.writerow([<span class="string">&quot;id&quot;</span>, <span class="string">&quot;tested_positive&quot;</span>])</span><br><span class="line">        <span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(rel):</span><br><span class="line">            csvWriter.writerow([<span class="built_in">str</span>(i), <span class="built_in">str</span>(value)])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;文件已保存到&#123;&#125;&quot;</span>.<span class="built_in">format</span>(rel_path))</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 配置参数</span></span><br><span class="line">all_feature = <span class="literal">False</span>  <span class="comment"># 是否使用全部特征</span></span><br><span class="line">feature_dim = <span class="number">6</span>  <span class="comment"># 特征维度</span></span><br><span class="line"><span class="keyword">if</span> all_feature:</span><br><span class="line">    feature_dim = <span class="number">93</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    feature_dim = <span class="number">6</span></span><br><span class="line">    </span><br><span class="line">config = &#123;</span><br><span class="line">    <span class="string">&quot;lr&quot;</span>: <span class="number">0.001</span>,<span class="comment"># 学习率</span></span><br><span class="line">    <span class="string">&quot;epochs&quot;</span>: <span class="number">20</span>, <span class="comment"># 训练轮数</span></span><br><span class="line">    <span class="string">&quot;momentum&quot;</span>: <span class="number">0.9</span>,<span class="comment"># 动量系数</span></span><br><span class="line">    <span class="string">&quot;save_path&quot;</span>: <span class="string">&quot;model_save/best_model.pth&quot;</span>,<span class="comment"># 模型保存路径</span></span><br><span class="line">    <span class="string">&quot;rel_path&quot;</span>: <span class="string">&quot;pred.csv&quot;</span><span class="comment"># 预测结果路径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设备检测</span></span><br><span class="line">device = <span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span></span><br><span class="line"><span class="built_in">print</span>(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据加载</span></span><br><span class="line">train_file = <span class="string">&quot;covid.train.csv&quot;</span></span><br><span class="line">test_file = <span class="string">&quot;covid.test.csv&quot;</span></span><br><span class="line">train_dataset = CovidDataset(train_file, <span class="string">&quot;train&quot;</span>, all_feature, feature_dim)</span><br><span class="line">val_dataset = CovidDataset(train_file, <span class="string">&quot;val&quot;</span>, all_feature, feature_dim)</span><br><span class="line">test_dataset = CovidDataset(test_file, <span class="string">&quot;test&quot;</span>, all_feature, feature_dim)</span><br><span class="line"><span class="comment"># for data in train_dataset:</span></span><br><span class="line"><span class="comment">#     print(data)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据加载器</span></span><br><span class="line">batch_size = <span class="number">16</span></span><br><span class="line">train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=<span class="literal">True</span>)  <span class="comment"># 随机梯度下降</span></span><br><span class="line">val_loader = DataLoader(val_dataset, batch_size=batch_size, shuffle=<span class="literal">True</span>)  <span class="comment"># 随机梯度下降</span></span><br><span class="line">test_loader = DataLoader(test_dataset, batch_size=<span class="number">1</span>, shuffle=<span class="literal">False</span>)  <span class="comment"># 随机梯度下降</span></span><br><span class="line"><span class="comment"># for batch_x, batch_y in train_loader:</span></span><br><span class="line"><span class="comment">#     print(batch_x, batch_y)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mseLoss_with_reg</span>(<span class="params">pred, target, model</span>):</span><br><span class="line">    loss = nn.MSELoss(reduction=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; Calculate loss &#x27;&#x27;&#x27;</span></span><br><span class="line">    regularization_loss = <span class="number">0</span>                    <span class="comment"># 正则项</span></span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> model.parameters():</span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> you may implement L1/L2 regularization here</span></span><br><span class="line">        <span class="comment"># 使用L2正则项</span></span><br><span class="line">        <span class="comment"># regularization_loss += torch.sum(abs(param))</span></span><br><span class="line">        regularization_loss += torch.<span class="built_in">sum</span>(param ** <span class="number">2</span>)                  <span class="comment"># 计算所有参数平方</span></span><br><span class="line">    <span class="keyword">return</span> loss(pred, target) + <span class="number">0.00075</span> * regularization_loss             <span class="comment"># 返回损失。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = MyModel(inDim=feature_dim).to(device)  <span class="comment"># 向硬件挂载任务</span></span><br><span class="line"><span class="comment"># loss = nn.MSELoss()  # Loss函数</span></span><br><span class="line">loss = mseLoss_with_reg</span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=config[<span class="string">&quot;lr&quot;</span>], momentum=config[<span class="string">&quot;momentum&quot;</span>])  <span class="comment"># 优化器</span></span><br><span class="line"></span><br><span class="line">train_val(model, train_loader, val_loader, device, config[<span class="string">&quot;epochs&quot;</span>], optimizer, loss, config[<span class="string">&quot;save_path&quot;</span>])</span><br><span class="line"></span><br><span class="line">evaluate(config[<span class="string">&quot;save_path&quot;</span>], test_loader, device, config[<span class="string">&quot;rel_path&quot;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-数据读取"><a href="#1-数据读取" class="headerlink" title="1. 数据读取"></a>1. 数据读取</h3><p>其实对基本的模型来说，训练过程都是一样的，而最麻烦的是数据的输入，我们在输入过程中有时可以剔除部分不需要的数据，来更好的构建模型，但哪些重要哪些不重要，又是一个问题。。。</p><p>看看代码吧</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_feature_importance</span>(<span class="params">feature_data, label_data, k =<span class="number">4</span>,column = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    特征重要性选择函数</span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        feature_data : 特征数据矩阵</span></span><br><span class="line"><span class="string">        label_data   : 对应标签数据</span></span><br><span class="line"><span class="string">        k           : 选择的最佳特征数量</span></span><br><span class="line"><span class="string">        column      : 特征名称列表（可选）</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        X_new       : 选择后的特征数据</span></span><br><span class="line"><span class="string">        indices     : 被选特征的列索引</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 使用卡方检验选择特征</span></span><br><span class="line">    model = SelectKBest(chi2, k=k)      <span class="comment">#定义一个选择k个最佳特征的函数</span></span><br><span class="line">    feature_data = np.array(feature_data, dtype=np.float64)<span class="comment"># 确保数据类型为float64以满足sklearn要求</span></span><br><span class="line">    <span class="comment"># label_data = np.array(label_data, dtype=np.float64)</span></span><br><span class="line">    X_new = model.fit_transform(feature_data, label_data)   <span class="comment">#用这个函数选择k个最佳特征</span></span><br><span class="line">    <span class="comment">#feature_data是特征数据，label_data是标签数据，该函数可以选择出k个特征</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x_new&#x27;</span>, X_new)</span><br><span class="line">    scores = model.scores_                <span class="comment"># scores即每一列与结果的相关性</span></span><br><span class="line">    <span class="comment"># 按重要性排序，选出最重要的 k 个</span></span><br><span class="line">    indices = np.argsort(scores)[::-<span class="number">1</span>]        <span class="comment">#[::-1]表示反转一个列表或者矩阵。</span></span><br><span class="line">    <span class="comment"># argsort这个函数， 可以矩阵排序后的下标。 比如 indices[0]表示的是，scores中最小值的下标。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> column:                            <span class="comment"># 如果需要打印选中的列</span></span><br><span class="line">        k_best_features = [column[i+<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> indices[<span class="number">0</span>:k].tolist()]         <span class="comment"># 选中这些列 打印</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;k best features are: &#x27;</span>,k_best_features)</span><br><span class="line">    <span class="keyword">return</span> X_new, indices[<span class="number">0</span>:k]                  <span class="comment"># 返回选中列的特征和他们的下标。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>get_feature_importance()在所有的特征中 通过SelectKBest算法来找到K个影响最大的特征，借此排除无效计算</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;COVID数据加载器&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CovidDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">            file_path   : 数据文件路径</span></span><br><span class="line"><span class="string">            mode       : 数据集模式（train/val/test）</span></span><br><span class="line"><span class="string">            all_feature : 是否使用全部特征</span></span><br><span class="line"><span class="string">            feature_dim : 选择特征维度</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 数据预处理：给模型喂“干净粮食”</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, file_path, mode=<span class="string">&quot;train&quot;</span>, all_feature=<span class="literal">False</span>, feature_dim=<span class="number">6</span></span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            ori_data = <span class="built_in">list</span>(csv.reader(f))</span><br><span class="line">            column = ori_data[<span class="number">0</span>]</span><br><span class="line">            csv_data = np.array(ori_data[<span class="number">1</span>:])[:, <span class="number">1</span>:].astype(<span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line">        feature = np.array(ori_data[<span class="number">1</span>:])[:, <span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">        label_data = np.array(ori_data[<span class="number">1</span>:])[:, -<span class="number">1</span>]</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span> all_feature:</span><br><span class="line">            col = np.array([i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">93</span>)])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            _, col = get_feature_importance(feature, label_data, feature_dim, column)</span><br><span class="line">        col = col.tolist()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mode == <span class="string">&quot;train&quot;</span>:  <span class="comment"># 80%训练集</span></span><br><span class="line">            indices = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(csv_data)) <span class="keyword">if</span> i % <span class="number">5</span> != <span class="number">0</span>]</span><br><span class="line">            data = torch.tensor(csv_data[indices, :-<span class="number">1</span>])</span><br><span class="line">            self.y = torch.tensor(csv_data[indices, -<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">elif</span> mode == <span class="string">&quot;val&quot;</span>:  <span class="comment"># 20%验证集</span></span><br><span class="line">            indices = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(csv_data)) <span class="keyword">if</span> i % <span class="number">5</span> == <span class="number">0</span>]</span><br><span class="line">            data = torch.tensor(csv_data[indices, :-<span class="number">1</span>])</span><br><span class="line">            self.y = torch.tensor(csv_data[indices, -<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># test模式</span></span><br><span class="line">            indices = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(csv_data))]</span><br><span class="line">            data = torch.tensor(csv_data[indices])</span><br><span class="line"></span><br><span class="line">        <span class="comment">#  数据标准化处理(将不同尺度的数据变为同一尺度)</span></span><br><span class="line">        data = data[:, col]</span><br><span class="line">        self.data = (data - data.mean(dim=<span class="number">0</span>, keepdim=<span class="literal">True</span>)) / data.std(dim=<span class="number">0</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">        self.mode = mode</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取单条数据&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        <span class="keyword">if</span> self.mode != <span class="string">&quot;test&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> self.data[idx].<span class="built_in">float</span>(), self.y[idx].<span class="built_in">float</span>()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.data[idx].<span class="built_in">float</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.data)</span><br></pre></td></tr></table></figure><p>CovidDataset类是数据装载需要用到的</p><ul><li><strong>init</strong>函数对CovidDataset进行了初始化，将文件读入，并排除无用的行列之后，转化为张量的形式，同时根据训练的模式来选择传出全部数据还是部分关键数据，并且自动分割训练集和测试集。</li></ul><blockquote><p>说实话读数据的代码看着还不算难，但是自己写还真是一次写不出来。。</p><p>入门没有练度的时候，看这些东西都不知道为什么要设计这个环节</p></blockquote><p><strong>数据标准化：公平对待每个特征</strong></p><ul><li><strong>为什么要做</strong>：身高（170cm）和体重（70kg）单位不同，直接比较会扭曲模型判断。</li><li><strong>操作方法</strong>：对每个特征列，减去均值、除以标准差 → 数据服从标准正态分布（代码中的<code>(data - data.mean)/datastd</code>）。</li></ul><h3 id="2-核心模型"><a href="#2-核心模型" class="headerlink" title="2. 核心模型"></a>2. 核心模型</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyModel</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义全连接神经网络&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, inDim</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">            inDim : 输入特征维度</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>(MyModel, self).__init__()</span><br><span class="line">        self.fc1 = nn.Linear(inDim, <span class="number">64</span>)</span><br><span class="line">        self.relu1 = nn.ReLU()</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">64</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):  <span class="comment"># 模型前向过程</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;前向传播&quot;&quot;&quot;</span></span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = self.relu1(x)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(x.size()) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> x.squeeze(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>这是模型本身的算法类，这里直接使用nn现成的算法，不用再自己造轮子了</p><p>使用了Linear来线性预测，ReLu作为激活函数</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503021930466.png" alt="image-20250302193042383"></p><p>先从输入数据个参数，降到64个，最后直接降到1个，即输出本身</p><h3 id="3-训练模块"><a href="#3-训练模块" class="headerlink" title="3.  训练模块"></a>3.  训练模块</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_val</span>(<span class="params">model, train_loader, val_loader, device, epochs, optimizer, loss, save_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    模型训练与验证函数</span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        model       : 待训练模型</span></span><br><span class="line"><span class="string">        train_loader: 训练数据加载器</span></span><br><span class="line"><span class="string">        val_loader  : 验证数据加载器</span></span><br><span class="line"><span class="string">        device     : 计算设备（CPU/GPU）</span></span><br><span class="line"><span class="string">        epochs     : 训练轮数</span></span><br><span class="line"><span class="string">        optimizer  : 优化器</span></span><br><span class="line"><span class="string">        loss       : 损失函数</span></span><br><span class="line"><span class="string">        save_path  : 模型保存路径</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    model = model.to(device)</span><br><span class="line">    plt_train_loss = []  <span class="comment"># 记录所有轮次的训练loss</span></span><br><span class="line">    plt_val_loss = []  <span class="comment"># 验证loss记录</span></span><br><span class="line"></span><br><span class="line">    min_val_loss = <span class="number">9999999999999999</span>  <span class="comment"># 最佳验证损失初始化</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):  <span class="comment"># 开始训练</span></span><br><span class="line">        train_loss = <span class="number">0.0</span></span><br><span class="line">        val_loss = <span class="number">0.0</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line"></span><br><span class="line">        model.train()  <span class="comment"># 模型调整为训练模式</span></span><br><span class="line">        <span class="keyword">for</span> batch_x, batch_y <span class="keyword">in</span> train_loader:</span><br><span class="line">            x, target = batch_x.to(device), batch_y.to(device)</span><br><span class="line">            pred = model(x)  <span class="comment"># 前向传播</span></span><br><span class="line">            train_bat_loss = loss(pred, target, model)</span><br><span class="line">            train_bat_loss.backward() <span class="comment"># 反向传播</span></span><br><span class="line">            optimizer.step()  <span class="comment"># 更新模型</span></span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            train_loss += train_bat_loss.cpu().item()</span><br><span class="line"></span><br><span class="line">        plt_train_loss.append(train_loss / train_loader.__len__())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 验证阶段</span></span><br><span class="line">        model.<span class="built_in">eval</span>()</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            <span class="keyword">for</span> batch_x, batch_y <span class="keyword">in</span> val_loader:</span><br><span class="line">                x, target = batch_x.to(device), batch_y.to(device)</span><br><span class="line">                pred = model(x)</span><br><span class="line">                val_bat_loss = loss(pred, target, model)</span><br><span class="line">                val_loss += val_bat_loss.cpu().item()</span><br><span class="line">        plt_val_loss.append(val_loss / val_loader.__len__())</span><br><span class="line">        <span class="comment"># 保存最佳模型</span></span><br><span class="line">        <span class="keyword">if</span> val_loss &lt; min_val_loss:</span><br><span class="line">            torch.save(model, save_path)</span><br><span class="line">            min_val_loss = val_loss</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[%03d/%03d] %2.2f sec(s) Trainloss: %.6f | Valloss: %.6f&quot;</span> % \</span><br><span class="line">              (epoch, epochs, time.time() - start_time, plt_train_loss[-<span class="number">1</span>], plt_val_loss[-<span class="number">1</span>]))</span><br><span class="line">    <span class="comment"># 损失曲线可视化</span></span><br><span class="line">    plt.plot(plt_train_loss)</span><br><span class="line">    plt.plot(plt_val_loss)</span><br><span class="line">    plt.title(<span class="string">&quot;loss&quot;</span>)</span><br><span class="line">    plt.legend([<span class="string">&quot;train&quot;</span>, <span class="string">&quot;val&quot;</span>])</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><h3 id="4-输出模型结果"><a href="#4-输出模型结果" class="headerlink" title="4. 输出模型结果"></a>4. 输出模型结果</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate</span>(<span class="params">save_path, test_loader, device, rel_path</span>):  <span class="comment"># 得出测试结果文件</span></span><br><span class="line">    <span class="comment"># 加载最佳模型</span></span><br><span class="line">    model = torch.load(save_path).to(device)</span><br><span class="line">    rel = []</span><br><span class="line">    <span class="comment"># 预测结果</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> test_loader:</span><br><span class="line">            pred = model(x.to(device))</span><br><span class="line">            rel.append(pred.cpu().item())</span><br><span class="line">    <span class="built_in">print</span>(rel)</span><br><span class="line">    <span class="comment"># 保存CSV结果</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(rel_path, <span class="string">&quot;w&quot;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        csvWriter = csv.writer(f)</span><br><span class="line">        csvWriter.writerow([<span class="string">&quot;id&quot;</span>, <span class="string">&quot;tested_positive&quot;</span>])</span><br><span class="line">        <span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(rel):</span><br><span class="line">            csvWriter.writerow([<span class="built_in">str</span>(i), <span class="built_in">str</span>(value)])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;文件已保存到&#123;&#125;&quot;</span>.<span class="built_in">format</span>(rel_path))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-优化：正则化-loss-loss-W-W"><a href="#5-优化：正则化-loss-loss-W-W" class="headerlink" title="5. 优化：正则化 loss = loss+ W*W"></a>5. 优化：正则化 loss = loss+ W*W</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mseLoss_with_reg</span>(<span class="params">pred, target, model</span>):</span><br><span class="line">    loss = nn.MSELoss(reduction=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; Calculate loss &#x27;&#x27;&#x27;</span></span><br><span class="line">    regularization_loss = <span class="number">0</span>                    <span class="comment"># 正则项</span></span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> model.parameters():</span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> you may implement L1/L2 regularization here</span></span><br><span class="line">        <span class="comment"># 使用L2正则项</span></span><br><span class="line">        <span class="comment"># regularization_loss += torch.sum(abs(param))</span></span><br><span class="line">        regularization_loss += torch.<span class="built_in">sum</span>(param ** <span class="number">2</span>)                  <span class="comment"># 计算所有参数平方</span></span><br><span class="line">    <span class="keyword">return</span> loss(pred, target) + <span class="number">0.00075</span> * regularization_loss             <span class="comment"># 返回损失。</span></span><br></pre></td></tr></table></figure><p>我们如果直接使用MSELoss来计算loss,容易造成<strong>过拟合</strong></p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503022022178.png" alt="image-20250302202213888"></p><p>这是因为MSE的计算公式loss(xi,yi)=(xi−yi)^2，如果出现了一个非常离谱的噪声y，就会产生巨大的loss，模型就会努力的扭曲函数，让他勾到这个奇怪的噪声点，造成曲线的失真</p><p><u>相对而言的：</u></p><p>通过正则化的MSE：loss = loss+ W*W，(W为参数)能使曲线更为平滑，能避免过拟合。</p><p>我们想想，模型的目标是追求更低的loss，如果模型为了去抓任性的噪声而随意地变更参数w，由于此时<strong>w对loss造成的影响是指数上升</strong>的，所以会抑制w的无端突变，从而达成平滑曲线的目的</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503022034370.png" alt="image-20250302203410195"></p><hr><h2 id="避坑指南：新手常见错误"><a href="#避坑指南：新手常见错误" class="headerlink" title="避坑指南：新手常见错误"></a><strong>避坑指南：新手常见错误</strong></h2><ol><li><strong>特征未标准化</strong> → 模型被大范围特征（如人口数）主导，忽视小范围特征（如温度）。</li><li><strong>忽略验证集</strong> → 模型在训练集表现完美，实际预测一塌糊涂。</li><li><strong>学习率过大</strong> → Loss剧烈震荡无法收敛（如下右）。</li></ol><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503022104656.png" alt="img"></p><hr><h2 id="总结：回归实战四步曲"><a href="#总结：回归实战四步曲" class="headerlink" title="总结：回归实战四步曲"></a><strong>总结：回归实战四步曲</strong></h2><ol><li><strong>数据预处理</strong>：清洗 → 特征选择 → 标准化（给模型喂干净数据）</li><li><strong>模型设计</strong>：输入层 → 隐藏层（+ReLU） → 输出层（搭积木式构建）</li><li><strong>训练调参</strong>：Loss监控 → 梯度下降 → 早停机制（防止过拟合，这里还没有写）</li><li><strong>结果分析</strong>：Loss曲线 → 正则化效果 → 模型推理测试</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;回归实战：预测新冠感染人数&quot;&gt;&lt;a href=&quot;#回归实战：预测新冠感染人数&quot; class=&quot;headerlink&quot; title=&quot;回归实战：预测新冠感染人数&quot;&gt;&lt;/a&gt;回归实战：预测新冠感染人数&lt;/h1&gt;&lt;h2 id=&quot;先回顾下回归是个啥玩意&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="知识笔记" scheme="https://hantoul.github.io/categories/%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="深度学习" scheme="https://hantoul.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="AI" scheme="https://hantoul.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>神经网络代码入门解析</title>
    <link href="https://hantoul.github.io/2025/03/01/2025-3-1-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%A0%81%E5%85%A5%E9%97%A8%E8%A7%A3%E6%9E%90/"/>
    <id>https://hantoul.github.io/2025/03/01/2025-3-1-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%A0%81%E5%85%A5%E9%97%A8%E8%A7%A3%E6%9E%90/</id>
    <published>2025-03-01T04:53:55.000Z</published>
    <updated>2025-03-01T04:53:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>import torch<br>import matplotlib.pyplot as plt</p><p>import random</p><p>def create_data(w, b, data_num):  # 数据生成<br>    x = torch.normal(0, 1, (data_num, len(w)))<br>    y = torch.matmul(x, w) + b  # 矩阵相乘再加b</p><pre><code>noise = torch.normal(0, 0.01, y.shape)  # 为y添加噪声y += noisereturn x, y</code></pre><p>num = 500</p><p>true_w = torch.tensor([8.1, 2, 2, 4])<br>true_b = 1.1</p><p>X, Y = create_data(true_w, true_b, num)</p><h1 id="plt-scatter-X-3-Y-1-画散点图-对X取全部的行的第三列，标签Y，点大小"><a href="#plt-scatter-X-3-Y-1-画散点图-对X取全部的行的第三列，标签Y，点大小" class="headerlink" title="plt.scatter(X[:, 3], Y, 1)  # 画散点图 对X取全部的行的第三列，标签Y，点大小"></a>plt.scatter(X[:, 3], Y, 1)  # 画散点图 对X取全部的行的第三列，标签Y，点大小</h1><h1 id="plt-show"><a href="#plt-show" class="headerlink" title="plt.show()"></a>plt.show()</h1><p>def data_provider(data, label, batchsize):  # 每次取batchsize个数据<br>    length = len(label)<br>    indices = list(range(length))</p><pre><code># 这里需要把数据打乱random.shuffle(indices)for each in range(0, length, batchsize):    get_indices = indices[each: each+batchsize]    get_data = data[get_indices]    get_label = label[get_indices]    yield get_data, get_label  # 有存档点的return</code></pre><p>batchsize = 16</p><h1 id="for-batch-x-batch-y-in-data-provider-X-Y-batchsize"><a href="#for-batch-x-batch-y-in-data-provider-X-Y-batchsize" class="headerlink" title="for batch_x, batch_y in data_provider(X, Y, batchsize):"></a>for batch_x, batch_y in data_provider(X, Y, batchsize):</h1><h1 id="print-batch-x-batch-y"><a href="#print-batch-x-batch-y" class="headerlink" title="print(batch_x, batch_y)"></a>print(batch_x, batch_y)</h1><h1 id="break"><a href="#break" class="headerlink" title="break"></a>break</h1><h1 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h1><p>def fun(x, w, b):<br>    pred_y = torch.matmul(x, w) + b<br>    return pred_y</p><h1 id="定义loss"><a href="#定义loss" class="headerlink" title="定义loss"></a>定义loss</h1><p>def maeLoss(pre_y, y):<br>    return torch.sum(abs(pre_y-y))/len(y)</p><h1 id="sgd-梯度下降"><a href="#sgd-梯度下降" class="headerlink" title="sgd(梯度下降)"></a>sgd(梯度下降)</h1><p>def sgd(paras, lr):<br>    with torch.no<em>grad():  # 这部分代码不计算梯度<br>        for para in paras:<br>            para -= para.grad <em> lr  # 不能写成 para = para - paras.grad </em> lr !!!! 这句相当于要创建一个新的para，会导致报错<br>            para.grad.zero</em>()  # 将使用过的梯度归零</p><p>lr = 0.01<br>w_0 = torch.normal(0, 0.01, true_w.shape, requires_grad=True)<br>b_0 = torch.tensor(0.01, requires_grad=True)<br>print(w_0, b_0)</p><p>epochs = 50<br>for epoch in range(epochs):<br>    data_loss = 0<br>    for batch_x, batch_y in data_provider(X, Y, batchsize):<br>        pred_y = fun(batch_x, w_0, b_0)<br>        loss = maeLoss(pred_y, batch_y)<br>        loss.backward()<br>        sgd([w_0, b_0], lr)<br>        data_loss += loss</p><pre><code>print(&quot;epoch %03d: loss: %.6f&quot; % (epoch, data_loss))</code></pre><p>print(“真实函数值：”, true_w, true_b)<br>print(“训练得到的函数值：”, w_0, b_0)</p><p>idx = 0<br>plt.plot(X[:, idx].detach().numpy(), X[:, idx].detach().numpy()*w_0[idx].detach().numpy()+b_0.detach().numpy())<br>plt.scatter(X[:, idx].detach().numpy(), Y, 1)<br>plt.show()</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;import torch&lt;br&gt;import matplotlib.pyplot as plt&lt;/p&gt;
&lt;p&gt;import random&lt;/p&gt;
&lt;p&gt;def create_data(w, b, data_num):  # 数据生成&lt;br&gt;    x = torch.nor</summary>
      
    
    
    
    <category term="知识笔记" scheme="https://hantoul.github.io/categories/%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="深度学习" scheme="https://hantoul.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="AI" scheme="https://hantoul.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>一个普通学生的(365&gt;&gt;1)天跋涉_研途小记</title>
    <link href="https://hantoul.github.io/2025/02/28/2025-2-28-%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E5%AD%A6%E7%94%9F%E7%9A%84365%E5%A4%A9%E8%B7%8B%E6%B6%89%EF%BC%9A%E7%A0%94%E9%80%94%E5%B0%8F%E8%AE%B0/"/>
    <id>https://hantoul.github.io/2025/02/28/2025-2-28-%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E5%AD%A6%E7%94%9F%E7%9A%84365%E5%A4%A9%E8%B7%8B%E6%B6%89%EF%BC%9A%E7%A0%94%E9%80%94%E5%B0%8F%E8%AE%B0/</id>
    <published>2025-02-28T07:42:23.000Z</published>
    <updated>2025-03-02T09:42:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一个普通学生的-365-gt-gt-1-天跋涉-研途小记"><a href="#一个普通学生的-365-gt-gt-1-天跋涉-研途小记" class="headerlink" title="一个普通学生的(365&gt;&gt;1)天跋涉_研途小记"></a><strong>一个普通学生的(365&gt;&gt;1)天跋涉_研途小记</strong></h1><p>距离考研结束已经有一段时间了，成绩也已公布，回望这半年多的备考时光，我觉得有必要记录下这段旅程。无论结果如何，这段经历本身就是一笔宝贵的财富。</p><p>2024 年 6 月，我经历了一轮求职，但结果并不尽如人意。这让我重新审视自己的未来规划，也促使我坚定了考研的决心。既然要做，就全力以赴。从那时起，我开始了“两点一线”的生活——白天图书馆，晚上寝室，朝八晚十，持续到考研结束。这半年是挑战，也是蜕变。</p><p>这段考研的日子，我开始慢慢改变。曾经沉迷社交软件的我，开始践行”吸引力法则”：把刷短视频的15分钟换成背10个考研词汇，把焦虑内耗的深夜变成整理408考点的仪式。当自习室常坐的桌子逐渐聚起研友，我们默契地形成了”占座互助小组”，共同对抗臭脚各和眼罩姐，偶尔抬头看见周围伏案的背影，恍惚间竟觉得连空气都流动着向上的力量~</p><p>最珍贵的收获，是那些在自习时结识的陌生人。隔壁桌二战学长分享的408笔记，现在还静静躺在我的文档里。图书馆考前清场大家互相祝福的场景，让我突然读懂罗素说的”参差多态才是幸福本源”——原来追光的路上，我们早已成为彼此的光。</p><p>这些细碎的温暖，最终都化作查分时屏幕里跳动的数字。原来所谓成长，就是把”我做不到”的焦虑，酿成”再走一步”的勇气；把孤独的跋涉，走成群体的远征。那些在走廊尽头背书的清晨，在草稿纸上写满的”加油”，在深夜屏幕前啃专业课的侧影，都在此刻凝结成通向未来的船票。</p><p>虽然考研初试已经结束，但我的学习并未停止。本科阶段为了求职，我的主要技术栈是 Java，而研究生阶段将会涉及更多深度学习的内容。为了做好衔接，我想我有必要现在就开始入门AI课程了，虽然Ai对数学一般般的我而言理解起来有些困难，但现在在线资源这么多，多看多想，总能勤能补拙的。就像考研这半年一样，每一步的努力，最终都会成为未来成长的基石。</p><p>2025/2/28</p><hr><p>致谢</p><p>感谢武汉工程大学图书馆6楼阅览室左手靠墙奇怪图画下的那副桌椅（嗯，这篇博客也是在这位老伙计这写的）</p><p>感谢周洋鑫老师，虽然成绩最终平平无奇，但刷题做题的时候的快乐是真切的</p><p>感谢亲爱的室友宝宝们，祝你们二战上岸，仕途顺利</p><p>感谢所有家人们，一直以来提供的各种支持</p><p>最想对坚持到底的自己说声谢谢——那个在数学考砸后依然走向408考场的少年，终于迎来了属于他的春天~</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503021729852.jpg" alt="img"></p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503021730580.jpg" alt="img"></p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503021730530.jpg" alt="img"></p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503021730560.jpg" alt="img"></p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202503021731631.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一个普通学生的-365-gt-gt-1-天跋涉-研途小记&quot;&gt;&lt;a href=&quot;#一个普通学生的-365-gt-gt-1-天跋涉-研途小记&quot; class=&quot;headerlink&quot; title=&quot;一个普通学生的(365&amp;gt;&amp;gt;1)天跋涉_研途小记&quot;&gt;&lt;/a&gt;&lt;</summary>
      
    
    
    
    <category term="生活日常" scheme="https://hantoul.github.io/categories/%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>力扣刷题： 142.环形链表II</title>
    <link href="https://hantoul.github.io/2024/04/14/2024-4-15-%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    <id>https://hantoul.github.io/2024/04/14/2024-4-15-%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/</id>
    <published>2024-04-14T14:27:15.000Z</published>
    <updated>2024-04-14T16:45:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣刷题-142-环形链表II"><a href="#力扣刷题-142-环形链表II" class="headerlink" title="[力扣刷题]  142.环形链表II"></a>[力扣刷题]  <a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142.环形链表II</a></h2><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202404150042085.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 快慢双指针解法</span></span><br><span class="line">        <span class="comment">// 设置慢指针ps每次移动1步，而快指针pf每次移动2步</span></span><br><span class="line">        <span class="comment">// 设头结点距环入口距离为a，环长度为b; 快指针移动距离为f，慢指针移动距离为s，按照上面的条件，现在有f=2s</span></span><br><span class="line">        <span class="comment">// 这里显然相遇了就会有环</span></span><br><span class="line">        <span class="comment">// 则当第一次相遇时，有&#123;f = 2s; f = s + nb&#125; =&gt; s = nb</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">sp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fp != <span class="literal">null</span> &amp;&amp; fp.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            fp = fp.next.next;</span><br><span class="line">            sp = sp.next;</span><br><span class="line">            <span class="keyword">if</span>(fp == sp)&#123;</span><br><span class="line">                <span class="comment">// 我们再次观察题目，发现如果从头结点开始，走 a + nb 步后必然会停在环入口</span></span><br><span class="line">                <span class="comment">// 再看第一次相遇时得出的结果 s = nb？？ 这下nb有了，不是只差a了吗</span></span><br><span class="line">                <span class="comment">// 简而言之，慢指针此时在环中距离出口只差a距离</span></span><br><span class="line">                <span class="comment">// 从哪里获得a的计量呢？ 巧了吗这不是，头结点距离入口也是a；更巧的是我们有两个指针</span></span><br><span class="line">                <span class="comment">// 现在只需要让快指针回到头结点，让快慢指针速度一致，他们下次相遇的地点就会在环的入口</span></span><br><span class="line">                fp = head;</span><br><span class="line">                <span class="keyword">while</span>(fp != sp)&#123;</span><br><span class="line">                    fp = fp.next;</span><br><span class="line">                    sp = sp.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣刷题-142-环形链表II&quot;&gt;&lt;a href=&quot;#力扣刷题-142-环形链表II&quot; class=&quot;headerlink&quot; title=&quot;[力扣刷题]  142.环形链表II&quot;&gt;&lt;/a&gt;[力扣刷题]  &lt;a href=&quot;https://leetcode.cn/p</summary>
      
    
    
    
    <category term="算法学习" scheme="https://hantoul.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="力扣" scheme="https://hantoul.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E5%8A%9B%E6%89%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>在短链接前后端联调时遇见由Feign引发的“奇怪”问题（Feign使用中对于Get请求自动变成Push引发的 Sharding value null must implements Comparable 报错的解决方法）</title>
    <link href="https://hantoul.github.io/2024/04/12/2024-4-12-%E5%9C%A8%E7%9F%AD%E9%93%BE%E6%8E%A5%E5%89%8D%E5%90%8E%E7%AB%AF%E8%81%94%E8%B0%83%E6%97%B6%E9%81%87%E8%A7%81%E7%94%B1Feign%E5%BC%95%E5%8F%91%E7%9A%84%E2%80%9C%E5%A5%87%E6%80%AA%E2%80%9D%E9%97%AE%E9%A2%98/"/>
    <id>https://hantoul.github.io/2024/04/12/2024-4-12-%E5%9C%A8%E7%9F%AD%E9%93%BE%E6%8E%A5%E5%89%8D%E5%90%8E%E7%AB%AF%E8%81%94%E8%B0%83%E6%97%B6%E9%81%87%E8%A7%81%E7%94%B1Feign%E5%BC%95%E5%8F%91%E7%9A%84%E2%80%9C%E5%A5%87%E6%80%AA%E2%80%9D%E9%97%AE%E9%A2%98/</id>
    <published>2024-04-12T13:54:24.000Z</published>
    <updated>2024-04-12T13:54:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在短链接前后端联调时遇见由Feign引发的“奇怪”问题（Feign使用中对于Get请求自动变成Push引发的-Sharding-value-null-must-implements-Comparable-报错的解决方法）"><a href="#在短链接前后端联调时遇见由Feign引发的“奇怪”问题（Feign使用中对于Get请求自动变成Push引发的-Sharding-value-null-must-implements-Comparable-报错的解决方法）" class="headerlink" title="在短链接前后端联调时遇见由Feign引发的“奇怪”问题（Feign使用中对于Get请求自动变成Push引发的 Sharding value null must implements Comparable 报错的解决方法）"></a>在短链接前后端联调时遇见由Feign引发的“奇怪”问题（Feign使用中对于Get请求自动变成Push引发的 Sharding value null must implements Comparable 报错的解决方法）</h1><p>今天在做短链接系统的前后端联调，在前端查询短链接数据的时候发现了问题；</p><ul><li>在拉取<strong>短链接回收站</strong>和短链接分组中短链接数据时出现了异常，拉不到数据。回到后台日志中查看，发现是不支持Post方法</li></ul><p>对于短链接回收站的拉取异常，很快地就定位到了问题</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202404111937182.png" alt="image-20240411193722085">在哪显然这里是打错了，在用Feigin访问后管的时候，用错了方式</p><h2 id="既然两个基本一致的问题解决了一个，那另一个不是也差不多了？"><a href="#既然两个基本一致的问题解决了一个，那另一个不是也差不多了？" class="headerlink" title="既然两个基本一致的问题解决了一个，那另一个不是也差不多了？"></a>既然两个基本一致的问题解决了一个，那另一个不是也差不多了？</h2><p>这里就顺着之前的思路Debug，最后同样定位到了向后管发请求的地方，但是怎么都找不到是从哪里发的Post请求。</p><p>这时就觉得邪门了，哪里来的Post？？？</p><p>于是就试着把请求从<code>@GetMapping</code>改成了<code>@DeleteMapping</code>，居然又用Delete发了请求，这下邪门了。</p><blockquote><p>这里正好前一天晚上调试nacos的时候也遇见了<strong>玄学问题</strong></p><p>我在配置聚合服务注册到Nacos的服务名时怎么改都没有用，然后半夜折腾了一个多小时就放弃了睡觉了。然后今天一跑起来发现报错了，但是和昨天晚上报错不一样，原来是名称自己又改成我想要的名称了</p><p>敲代码，很神奇吧，我昨天也清空过Nacos缓存，重启过，但是并没有什么用。。。过了一个晚上自己就好了。。</p></blockquote><p>又试了下发现还是发PostMapping，然后就关电脑去吃饭跑步了，回来重启电脑发现还是不行。。。</p><p>在网上又搜不到相关的信息，所以又把请求打进来的路径逐一排除核实，最终将问题锁定到Feign中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分页查询短链接</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 分页查询短链接请求返回实体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/api/shortlink/v1/page&quot;)</span></span><br><span class="line">Result&lt;Page&lt;ShortLinkPageRespDTO&gt;&gt; <span class="title function_">pageShortLink</span><span class="params">(<span class="meta">@RequestBody</span> ShortLinkPageReqDTO requestParam)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再以 Feign Get 为关键字进行检索，发现若<strong>Feign中的Get请求若携带了RequestBody，就会自动转换成Post请求发送</strong></p><p>这里解决方法是将远程调用的调用端使用Post来发送请求，而为了保证外部传RestFul请求的语意，仍然使用Get来传入</p><blockquote><p>之所以之前的回收站能解决，是因为它用的是3个RequestParam；歪打正着了属于是</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202404112008304.png" alt="image-20240411200843247"></p></blockquote><h2 id="蒽，上面的解决方法是错的"><a href="#蒽，上面的解决方法是错的" class="headerlink" title="蒽，上面的解决方法是错的"></a>蒽，上面的解决方法是错的</h2><p>按照上面的方法再次进行调试，发现在聚合服务中，短链接后台向短链接中控发送请求时，将Post中的RequestBody丢弃了，然后ShardingSphere在查数据库的时候，由于在Params里面找不到分片键，所以报错了<code>Sharding value</code>null<code>must implements Comparable.</code>，我还以为是聚合服务的分片配错了，又浪费了半天debug</p><p>现在的解决方法非常粗暴，但是非常有效。。。。</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202404112055475.png" alt="image-20240411205527424"></p><blockquote><p>这里注意分页查询回收站并没有实现OrderTag，可能会在分类排序中</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在短链接前后端联调时遇见由Feign引发的“奇怪”问题（Feign使用中对于Get请求自动变成Push引发的-Sharding-value-null-must-implements-Comparable-报错的解决方法）&quot;&gt;&lt;a href=&quot;#在短链接前后端联调时</summary>
      
    
    
    
    <category term="知识笔记" scheme="https://hantoul.github.io/categories/%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="项目部署" scheme="https://hantoul.github.io/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    
    <category term="运维" scheme="https://hantoul.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（三）</title>
    <link href="https://hantoul.github.io/2024/03/14/2024-3-13-Docker%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://hantoul.github.io/2024/03/14/2024-3-13-Docker%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2024-03-14T08:42:52.000Z</published>
    <updated>2024-03-14T08:42:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403111436874.png" alt="image-20240311142734775"></p><h1 id="Docker入门笔记（3）"><a href="#Docker入门笔记（3）" class="headerlink" title="Docker入门笔记（3）"></a>Docker入门笔记（3）</h1><h2 id="容器资源管理"><a href="#容器资源管理" class="headerlink" title="容器资源管理"></a>容器资源管理</h2><h3 id="容器控制操作"><a href="#容器控制操作" class="headerlink" title="容器控制操作"></a>容器控制操作</h3><p>查看容器中输出的日志信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs 容器名</span><br></pre></td></tr></table></figure><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403140935048.png" alt="image-20240314092915737"></p><p>上面的打印操作还可以添加<code>-f</code>来持续打印日志信息</p><p>之前已经用过的重新进入容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attatch 容器名/id</span><br></pre></td></tr></table></figure><p>如果要回到主机上，需要<code>ctrl + p</code>再<code>ctrl + q</code>来退出，这时容器会保持运行，而使用<code>ctrl + c</code>会终止容器中正在运行的容器</p><p>我们还可以使用exec命令将指令传入终端并执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 容器名 指令</span><br></pre></td></tr></table></figure><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403140935075.png" alt="image-20240314093156121"></p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403140935287.png" alt="image-20240314093328698"></p><p>我们之前试过使用<code>stop</code>来停止容器，但他是会等待容器处理完结束程序后才会停止，我们可以使用<code>kill</code>来强制停止容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">kill</span> 容器名</span><br></pre></td></tr></table></figure><p>如果想让容器暂时挂起，就可以使用<code>pause</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pause 容器名</span><br></pre></td></tr></table></figure><p>恢复则使用<code>unpause</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker unpause 容器名</span><br></pre></td></tr></table></figure><h3 id="容器物理资源管理"><a href="#容器物理资源管理" class="headerlink" title="容器物理资源管理"></a>容器物理资源管理</h3><p>我们可以限制容器使用的如内存等物理资源上限</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rum -m 内存上限 --memory-swap=内存和交换分区一共的内存限制 镜像名</span><br></pre></td></tr></table></figure><p>默认内存和内存与交换分区无上限，默认都为-1；</p><p>我们把内存给小一点，再次试着启动刚才打开的Springboot程序</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403140959094.png" alt="image-20240314095905958"></p><p>可以看到，内存太小，直接寄了</p><p>我们还可以分配CPU资源，不过在Docker中是个<strong>相对的概念</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -c 1024 test1</span><br><span class="line">docker run -c 512 test2</span><br></pre></td></tr></table></figure><p>这里两个镜像在压力拉满的情况下，docker分配给他们的CPU资源比例是2：1；</p><p>注意这时分配的CPU资源是一个相对的概念，如果有一个容器闲置，那么另一个容器还是有可能拿到全部的CPU资源</p><p>Docker也为我们提供了直接指定容器使用的CPU核心的方法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --cpuset-cpus=1 ubuntu</span><br></pre></td></tr></table></figure><p>上面就只分了CPU的1号核心</p><p>如果要分配多颗核心，需要使用逗号隔开</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --cpuset-cpus=0,1,2 ubuntu</span><br></pre></td></tr></table></figure><p>也可以限制数量</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --cpuset-cpus=1 ubuntu</span><br></pre></td></tr></table></figure><p>不只是CPU和内存，磁盘IO也可以被管理</p><p>我们先测试一下容器内的读写速度</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/tmp/1G bs=4k count=256000 oflag=direct</span><br></pre></td></tr></table></figure><p>跑一下中途ctrl+c就行，不用测完</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403141007443.png" alt="image-20240314100754376"></p><p>可以看到当前的读写速度为8.4 MB/s，我们可以通过<code>--device-read/write-bps</code>和<code>--device-read/write-iops</code>参数对其进行限制。</p><blockquote><ul><li>bps：每秒读写的数据量。</li><li>iops：每秒IO的次数。</li></ul></blockquote><p>这里限制bps</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --device-write-bps=/dev/sda:3MB ubuntu</span><br></pre></td></tr></table></figure><p>再次测试读写速度，发现读写速度就只有3mb/s左右了</p><h3 id="容器监控"><a href="#容器监控" class="headerlink" title="容器监控"></a>容器监控</h3><p>我们可以对容器的实时运行状态进行监控</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats</span><br></pre></td></tr></table></figure><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403141024915.png" alt="image-20240314102415807"></p><p>除了笼统的使用stats来监控，还可以使用<code>top</code>来查看容器中的进程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器<span class="built_in">id</span>/名称</span><br></pre></td></tr></table></figure><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403141026071.png" alt="image-20240314102647978"></p><hr><h2 id="单机容器编排"><a href="#单机容器编排" class="headerlink" title="单机容器编排"></a>单机容器编排</h2><p>我之前部署问卷项目到docker的时候，不是因为数据库那些没有一起传上去所以跑不通吗，这下有办法了。</p><p>Docker-Compose可以对我们的容器进行编排，让多个容器按照我们自己的编排进行部署</p><p><a href="https://docs.docker.com/get-started/08_using_compose/">Docker-Compose官方文档</a></p><h2 id="这里弃了，之后把短链接和问卷项目整合完善了再搞吧"><a href="#这里弃了，之后把短链接和问卷项目整合完善了再搞吧" class="headerlink" title="这里弃了，之后把短链接和问卷项目整合完善了再搞吧"></a>这里弃了，之后把短链接和问卷项目整合完善了再搞吧</h2><hr><p>参考视频：<a href="https://www.bilibili.com/video/BV1r34y1p7j9?p=10&amp;vd_source=ccb7919bcde1355acd4bb39725e50302">Docker 容器技术 已完结（2022 最新版）4K蓝光画质+杜比音效 从内卷到开摆</a></p><p>视频教程文档：<a href="https://www.itbaima.cn/document/zj9uvg0sp3b0sok8">Docker容器技术</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403111436874.png&quot; alt=&quot;image-20240311142734775&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Docker入门</summary>
      
    
    
    
    <category term="知识笔记" scheme="https://hantoul.github.io/categories/%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Docker" scheme="https://hantoul.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（二）</title>
    <link href="https://hantoul.github.io/2024/03/13/2024-3-13-Docker%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://hantoul.github.io/2024/03/13/2024-3-13-Docker%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2024-03-13T07:34:21.000Z</published>
    <updated>2024-03-14T01:37:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker入门笔记（2）"><a href="#Docker入门笔记（2）" class="headerlink" title="Docker入门笔记（2）"></a>Docker入门笔记（2）</h1><h2 id="容器网络管理"><a href="#容器网络管理" class="headerlink" title="容器网络管理"></a>容器网络管理</h2><h3 id="容器网络类型"><a href="#容器网络类型" class="headerlink" title="容器网络类型"></a>容器网络类型</h3><p>Docker安装以后，会在我们的主机上创建三个网络</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403121306465.png" alt="image-20240312130610389"></p><p>可以看到有bridge、host和none三种网络类型</p><p>我们先把ubuntu的网络环境配置一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu</span><br><span class="line">apt update</span><br><span class="line">apt install net-tools iputils-ping curl</span><br></pre></td></tr></table></figure><p>这样环境就配置好了，接下来就退出容器，打包成为新的镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit &lt;容器name&gt; &lt;新镜像名&gt;</span><br></pre></td></tr></table></figure><p>现在我们来研究一下刚才上面的显示的三种网络类型</p><ul><li><p><strong>none网络</strong>：既然是none网络了，基本就是“没网络”，它只有一个<strong>本地的环回网络</strong></p><p>我们在创建容器时可以指定none网络来看看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --network=none ubuntu-net</span><br></pre></td></tr></table></figure><p>进入容器后可以<code>ifconfig</code>来查看一下网络</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403121312621.png" alt="image-20240312131219509"></p><p>他是无法连接到外界的互联网的，是一个真单机运行，没有人能从外部访问它</p></li><li><p><strong>bridge网络</strong>：容器默认会使用bridge网络，即桥接网络，它被广泛应用</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403121314227.png" alt="image-20240312131459070"></p><p>我们进入桥接模式再ifconfig，发现相比none网络，它多了一个新的网络接口；其实这是Docker创建的虚拟网络，docker在此时就充当了一个桥接的角色，一边链接宿主网络，一头连接自己的虚拟子网</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403121316626.png" alt="image-20240312131634536"></p><p>通过这样的网桥，我们可以对容器的网络进行管控，可以使用<code>network inspect</code>来查看docker0网桥的配置信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect bridge</span><br></pre></td></tr></table></figure><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403121318213.png" alt="image-20240312131840073"></p></li><li><p><strong>host网络</strong>：当容器使用host网络时，会共享宿主网络，他们的配置完全一致</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --network=host ubuntu-net</span><br></pre></td></tr></table></figure><p>在host网络的情况下，只要宿主主机能连上互联网，那么容器内部也没问题；这样一来就可以直接使用宿主的网络了，也不需要去开放端口了， 比桥接网络要方便的多，但相应的，安全性会有所下降。</p><p>在使用时要根据实际情况来选择这三种网络的使用。</p></li></ul><h3 id="用户自定义网络"><a href="#用户自定义网络" class="headerlink" title="用户自定义网络"></a>用户自定义网络</h3><p>Docker为我们默认提供了三种网络驱动：bridge、overlay、macvlan。</p><p>我们可以用bridge来试着实现一下自定义的桥接网络</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver bridge <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>这里就创建好了一个名为test的桥接网络</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403121402040.png" alt="image-20240312140247955"></p><p>我们新建一个使用test网络的容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --network=<span class="built_in">test</span> ubuntu-net</span><br></pre></td></tr></table></figure><p>使用ifconfig来看一下网络情况</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403121358766.png" alt="image-20240312135734646"></p><p>我们现在退出这个容器，但不是关闭它，而是将其挂到后台</p><p>这里按<code>ctrl + q</code>和<code>ctrl + p</code>就能挂起</p><p>我们再次创建一个容器，这次不指定网络，看他的网络如下</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403121358800.png" alt="image-20240312135750061"></p><p>很明显他们不在一个网段，应该是相互隔离的，这是ping是ping不通的</p><p>接下来我把他的网络也接入test网络</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect <span class="built_in">test</span> &lt;容器ID/名称&gt;</span><br></pre></td></tr></table></figure><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403121358879.png" alt="image-20240312135823757"></p><p>使用<code>docker attach &lt;容器id&gt;</code>来重新进入容器，再看看ifconfig里的配置</p><p>发现多了一个网络设备，现在两个容器就成功接入同一个网络环境下了</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403121358099.png" alt="img"></p><p>现在再试试ping原来的容器，就可以顺利ping通了</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403121358275.png" alt="img"></p><h3 id="容器间网络"><a href="#容器间网络" class="headerlink" title="容器间网络"></a>容器间网络</h3><p>上面我们完成了通过自定义的网桥来实现容器间的通信，下面还可以直接配置容器间的网络来管理他们的通信</p><p>我们海狮先创建两个ubuntu-net容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu-net</span><br></pre></td></tr></table></figure><p>我们直接在另外一个容器中ping它，由于他们都默认使用beidge网络处在同一个子网下，所以是可以顺利ping通的。</p><p>我们可以通过指定容器的ip来实现容器间通信，但是这样写的比较死。我们在配置容器的时候常常是自动分配的ip，这该怎么办呢</p><p>我们可以通过Docker为我们提供的DNS服务器来完成对域名的解析，只需要在启动容器时为容器所爱的网络命名，然后就可以实现互相的通信</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=test01 --network=<span class="built_in">test</span> ubuntu-net</span><br><span class="line">docker run -it --name=test02 --network=<span class="built_in">test</span> ubuntu-net</span><br></pre></td></tr></table></figure><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403131426976.png" alt="image-20240313142337144"></p><p>我们还可以直接让两个容器共享一个网络（设备），就相当于让他们处于同一网络环境下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=test03 --network=container:test02 ubuntu-net</span><br></pre></td></tr></table></figure><p>现在test02和test03的ip就完全一致了；</p><p>我们可以试着在test02中安装nginx</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install -y systemctl nginx</span><br><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure><p>然后在tesst03中访问nginx</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl localhost</span><br></pre></td></tr></table></figure><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403131429450.png" alt="image-20240313142907208"></p><p>成功访问，这俩容器的网络就接上了，实现了你中有我我中有你的网络状态</p><h3 id="容器外部网络"><a href="#容器外部网络" class="headerlink" title="容器外部网络"></a>容器外部网络</h3><p>上面了解了容器间的通信，接下来看看容器与外网的通信</p><p>在容器的三种网络模式下， 显然none模式是连不了外网的，这下只剩下共享和桥接两种模式来连接网络了。</p><p>学过计网的话，这里的物理机可以看做一个路由，容器将网络数据发给物理机，物理机通过地址变换再进行转发；所以这里公网是<strong>无法</strong>直接访问容器的</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403131436596.png" alt="image-20240313143609477"></p><p>上面的图是我们一般意义上的网络的转发，而对于Docker容器的也是差不多的</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403131437127.png" alt="image-20240313143716050"></p><p>这里有一个问题，如果只依靠NAT的话，我们的容器只能发送数据，而不能接收数据，该怎么办呢？</p><p>我们以前通过nginx实现过端口映射，这里的逻辑也是差不多的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 nginx</span><br></pre></td></tr></table></figure><p>这里的-p是port端口映射，规则是<code>宿主端口：容器端口</code>，这里就是把容器的80端口映射到主机的80端口上</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403131444821.png" alt="image-20240313144404741"></p><p>我们可以使用<code>docker ps</code>，然后在PORTS里查看端口的映射情况</p><p>以上就是Docker中单机下的网络操作~</p><hr><h2 id="容器存储管理"><a href="#容器存储管理" class="headerlink" title="容器存储管理"></a>容器存储管理</h2><p>我们前面学习了容器的网络，现在接受到了数据，如果需要存储数据，就涉及到了容器的存储管理。</p><h3 id="容器持久化存储"><a href="#容器持久化存储" class="headerlink" title="容器持久化存储"></a>容器持久化存储</h3><p>之前介绍过，对容器内的文件操作，实际上是在最顶层的容器层操作的，这是为了保证镜像本身的文件的安全性，但是这样特性也会造成删除容器时，容器存储的数据的全部丢失。</p><p>在某些情况下（比如说操作数据库数据），我们希望对容器内的部分数据进行持久化的存储，这是就需要用到数据卷了</p><p>先准备一个新的镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu</span><br><span class="line">apt update</span><br><span class="line">apt install -y vim</span><br></pre></td></tr></table></figure><p>安装vim完毕后打包成新的镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit &lt;容器名/id&gt; 镜像名:&lt;TAG&gt;</span><br></pre></td></tr></table></figure><p>我们在主机上创建一个文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> <span class="built_in">test</span></span><br><span class="line">vim <span class="built_in">test</span>/hello.txt</span><br></pre></td></tr></table></figure><p>在文件中随便写点东西，然后将主机的目录或文件挂载到容器的某个目录中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v ~/test:/root/test/ ubuntu-vim</span><br></pre></td></tr></table></figure><p>这里的<code>-v</code>就是要挂载文件，把我们刚才的test目录挂载到容器的/root/test目录中</p><p>然后我们在容器上也可以打开该文件了</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403131518193.png" alt="image-20240313151542805"></p><p>这时候我们销毁容器，文件还会存在吗？</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line">docker <span class="built_in">rm</span> &lt;容器名/id&gt;</span><br></pre></td></tr></table></figure><p>我们再次查看文件</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403131518171.png" alt="image-20240313151808681"></p><p>能看见容器内的修改，同时显然这个文件没有随着容器的删除而消失</p><p>如果我们不想让容器与主机之间以这种类似于共享文件夹的方式共享文件的话，我们可以使用<code>cp</code>指令来在容器和主机之间复制文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> ~/test/hello.txt ubuntu-vim:/root/test</span><br></pre></td></tr></table></figure><h3 id="容器间数据共享"><a href="#容器间数据共享" class="headerlink" title="容器间数据共享"></a>容器间数据共享</h3><p>上面说了容器与主机间的数据共享，如果我们想实现容器之间的数据共享，可以怎么做？</p><ul><li>通过上面学的，最直接的办法就是把两个容器挂到主机的同一个目录上，既然你俩都指向同一块区域了，那可不是实现共享了吗</li></ul><p>我们先创建一个容器，让他挂载主机上的某个目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v ~/test:root/test --name=data_test ubuntu-vim</span><br></pre></td></tr></table></figure><p>然后再创建一个容器，使用<code>--volumes-from</code>来指定要挂载到的另一个容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --volumes-from data_test ubuntu-vim</span><br></pre></td></tr></table></figure><p>这下挂载成功了</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403131541350.png" alt="image-20240313154105295"></p><p>显然上面的方式很麻烦，而且明明是两个容器间的共享，却要牵扯到主机，我们不想要这样。</p><ul><li>我们可以创建一个专门的容器来将容器中打包好的数据分享给其他容器（其本质上仍然是一个由Docker管理的数据卷），虽然没有完全脱离主机，但是移植性大大提升了</li></ul><p>我们编写一个Docklefile来创建这个数据卷</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> hello.txt /usr/share/test/</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /usr/share/test</span></span><br></pre></td></tr></table></figure><p>这里的VOLUME和之前的<code>-v</code>一样，会在容器中创建一个挂载点</p><p>然后创建镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t data .</span><br></pre></td></tr></table></figure><p>然后运行容器，进入对应的挂载点，就能找到我们设置的数据卷了</p><hr><p>参考视频：<a href="https://www.bilibili.com/video/BV1r34y1p7j9?p=10&amp;vd_source=ccb7919bcde1355acd4bb39725e50302">Docker 容器技术 已完结（2022 最新版）4K蓝光画质+杜比音效 从内卷到开摆</a></p><p>视频教程文档：<a href="https://www.itbaima.cn/document/zj9uvg0sp3b0sok8">Docker容器技术</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker入门笔记（2）&quot;&gt;&lt;a href=&quot;#Docker入门笔记（2）&quot; class=&quot;headerlink&quot; title=&quot;Docker入门笔记（2）&quot;&gt;&lt;/a&gt;Docker入门笔记（2）&lt;/h1&gt;&lt;h2 id=&quot;容器网络管理&quot;&gt;&lt;a href=&quot;#容器网</summary>
      
    
    
    
    <category term="知识笔记" scheme="https://hantoul.github.io/categories/%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Docker" scheme="https://hantoul.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记（一）</title>
    <link href="https://hantoul.github.io/2024/03/12/2024-3-12-Docker%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://hantoul.github.io/2024/03/12/2024-3-12-Docker%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2024-03-12T06:16:22.000Z</published>
    <updated>2024-03-13T00:56:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker入门笔记（1）"><a href="#Docker入门笔记（1）" class="headerlink" title="Docker入门笔记（1）"></a>Docker入门笔记（1）</h1><h2 id="容器技术入门"><a href="#容器技术入门" class="headerlink" title="容器技术入门"></a>容器技术入门</h2><p>之前我的WIT问卷管理系统在阿里云上部署需要好多配置，各个环境耦合的比较紧密，花了不少时间去做部署和调配。</p><p>现在有了Docker以后，我们可以把各种组件配置好，然后打包成镜像使用Docker直接一键部署，实现开箱即用。</p><h3 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a>Docker部署</h3><p>这里使用阿里云ECS作为Linux终端进行部署，系统为Ubuntu22.04。</p><ol><li><p>安装工具</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ca-certificates curl gnupg lsb-release</span><br></pre></td></tr></table></figure></li><li><p>安装GPG Key</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/apt/keyrings</span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br></pre></td></tr></table></figure></li><li><p>将Docker的库添加到apt资源列表</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure></li><li><p>再次更新apt</p></li><li><p>安装Docker CE版本</p></li><li><p>将当前用户添加到Docker用户组</p></li></ol><h4 id="案例-使用Docker部署Nginx"><a href="#案例-使用Docker部署Nginx" class="headerlink" title="[案例]使用Docker部署Nginx"></a>[案例]使用Docker部署Nginx</h4><p>直接执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d -p 80:80 nginx</span><br></pre></td></tr></table></figure><p>如果没有配置过安全组，记得在阿里云后台的安全组配置里<u><strong>开启HTTP的80接口访问权限</strong></u>，不然外网会访问失败</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403111436851.png" alt="image-20240311143528906"></p><p>轻松地部署好了Docker</p><h4 id="从虚拟机到Docker"><a href="#从虚拟机到Docker" class="headerlink" title="从虚拟机到Docker"></a>从虚拟机到Docker</h4><p>一般来说，服务器具有远超家用PC的资源，比如说CPU核心数量，网络带宽，内存大小等，为了让这些资源更高效的利用，我们就需要用到虚拟机。</p><p>我们可以通过虚拟化技术把物理硬件变成可以按需分配给每一台虚拟机，然后在虚拟机上运行我们编写的服务程序。</p><p>如果我们要部署一个大型项目，为了安全稳定和高效，就需要部署服务器集群，如果我们采用传统的部署方式，需要逐台调试每台虚拟机的环境，最后还需要联调，这会耗费我们大量的时间精力。</p><blockquote><p>之前上线WIT问卷系统到阿里云时，由于是第一次部署项目上云，需要配置很多环境，比如说mysql，java，redis，rabbitmq，nginx的环境全都需要逐一配置，非常繁琐</p></blockquote><p>随着云服务的发展繁荣，容器技术走上历史舞台，Docker应运而生。</p><p>Docker的集装箱是一只驮着集装箱的鲸鱼，它也表现了Docker一个最大的特性，每个集装箱其实是一个程序的环境+应用程序，他们可以基于Docker提供的环境在多平台上平稳运行，无需额外配置环境</p><p>我们可以通过Docker将一个组件打包成一个轻量级、可移植、自包含的容器，其可以运行在几乎所有的OS上</p><h4 id="Docker工作机制简述"><a href="#Docker工作机制简述" class="headerlink" title="Docker工作机制简述"></a>Docker工作机制简述</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403111547298.png" alt="image-20220630184857540"></p><p>Docker主要分为三个部分</p><ul><li>Docker客户端：我们之前的docker指令是在客户端上执行的，客户端会把操作发送到服务端处理</li><li>Docker服务端：服务器是启动容器的主体，一般也是作为服务在后台运行，其支持远程连接</li><li>Register仓库：其可以存放Docker镜像，都看Docker了应该没有人没学过Maven吧，和maven一样，Docker也分为公有和私有，当需要时，Docker会从远程仓库下载Docker镜像到本地运行</li></ul><p>当我们需要部署一个已经打包好的应用和环境，只需要通过docker下载已经打包好的镜像即可</p><p>我们之前输入<code>sudo docker run -d -p 80:80 nginx</code>后，Docker其实执行了以下操作</p><ol><li>Docker客户端将操作发送给服务端</li><li>Docker服务端在本地仓库查找对应镜像，若没有，则从服务器上下载到本地</li><li>加载本地的镜像，启动容器开始运行（容器之间，容器与外部之间都是互相隔离的，互不影响）</li></ol><p>一句话，Docker开箱即用</p><hr><h2 id="容器与镜像"><a href="#容器与镜像" class="headerlink" title="容器与镜像"></a>容器与镜像</h2><h3 id="初识容器镜像"><a href="#初识容器镜像" class="headerlink" title="初识容器镜像"></a>初识容器镜像</h3><p>简单了解一下镜像的相关操作，以官方提供的hello-world为例子</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull hello-world</span><br></pre></td></tr></table></figure><p>一个镜像的名称是有两个部分组成的，repository和tag，tag表示版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 名称:版本</span><br></pre></td></tr></table></figure><p>pull之后<strong>镜像会存放在本地</strong>，需要的话需要run</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>若<strong>不想要立刻执行容器</strong>，则可以换成</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create hello-world</span><br></pre></td></tr></table></figure><p>启动成功以后，可以输入<code>ps</code>来<strong>查看容器列表</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>这里的-a是为了看到所有容器，若不加-a，则只会显示当前正在运行的容器</p><p>我们在对某个容器进行操作的时候，需要输入容器的id或者名称，如果我们采用默认的名称，会难以记录和区分，我们可以在<code>run</code>时添加<code>--name</code>参数来<strong>为容器命名</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=hantou hello-world</span><br></pre></td></tr></table></figure><p>我们可以手动使用start来<strong>开启处于停止状态的容器</strong>（我们在run一个非持续性的程序时，它执行完了就结束了，就会被终止；比如说之前的hello-world）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start &lt;容器名称/id&gt;</span><br></pre></td></tr></table></figure><p>如果想<strong>手动停止容器</strong>直接输入stop就行了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;容器名称/id&gt;</span><br></pre></td></tr></table></figure><p><strong>重启容器</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart &lt;容器名称/id&gt;</span><br></pre></td></tr></table></figure><p><strong>删除容器</strong>(只有<u>非运行状态的容器才能被删除</u>)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> &lt;容器名称/id&gt;</span><br></pre></td></tr></table></figure><p><strong>设置运行后自动删除容器</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> 镜像名称</span><br></pre></td></tr></table></figure><p><strong>删除镜像</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 镜像名称</span><br></pre></td></tr></table></figure><p><strong>查看本地镜像</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h3 id="镜像结构介绍"><a href="#镜像结构介绍" class="headerlink" title="镜像结构介绍"></a>镜像结构介绍</h3><p>镜像是容器的基石，有了镜像才能创建容器实例，接下来我们就要浅浅研究一下镜像的基本结构</p><p>我们在打包项目的时候往往需要一个基本的环境，比如说数据库、缓存等等，这样我们才能基于这个系统来安装软件，这种基本的系统镜像我们称之为<strong>base镜像</strong></p><p>一般的base镜像就是各个Linux系统的发行版，比如说Ubuntu、Centos等</p><p>我们还是以centos为例子</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure><p>这里解释下base镜像的机制</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403112342960.png" alt="image-20240311234214834"></p><p>Linux操作体系由内核和用户空间组成，内核空间是Linux的核心，Linux启动后会先加载bootfs文件系统，然后在加载完毕后卸载bootfs，然后再加载用户空间的文件系统，而这一层正是我们可以操作的部分</p><ul><li>bootfs包含了BootLoader和Linux内核，用户无权修改</li><li>rootfs则包含了我们常常操作的较为熟悉的linux目录结构</li></ul><p>base镜像底层会直接调用宿主机的内核，也就是说，镜像与宿主机linux内核保持一致</p><p>可以使用<code>uname</code>指令来查看当前内核版本</p><p>我们来启动下刚才下载的centos的base镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it centos</span><br></pre></td></tr></table></figure><p>这里的<code>-it</code>是开启一个标准的数据接口并且分配一个伪tty设备，其可以支持终端登录，如果不同时使用这两个的话，base容器会在启动后自动终止</p><p>我们输入<code>exit</code>就可以退出base容器了</p><p>再次启动时需要加入<code>-i</code>才能在前台启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start -i &lt;容器名称/id&gt;</span><br></pre></td></tr></table></figure><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403112348590.png" alt="image-20240311234816544"></p><p>我们在基于base镜像的基础上，可以进行软件的安装与适配，我们可以一层一层的对镜像进行封装，这样的多层结构可以让软件环境自由的组合，让他们互相之间可以拼装使用。</p><p>可以看见图上的最上层有一层可写容器层，它有什么作用呢？</p><p>所有的镜像在组合后应该要叠加形成一个统一的文件系统，如果镜像之间的文件系统保持独立的话，那么一层一层的叠起来就很难操作</p><p>所以Docker为我们提供了<strong>可写容器层</strong>，我们可以通过修改读写层中的数据来访问下面镜像中的文件，各个操作如下</p><ul><li>文件读取：要读取一个文件，Docker会最上层往下依次寻找，找到后则打开文件。</li><li>文件创建和修改：创建新文件会<u>直接添加到可写容器层</u>中，修改文件会从上往下依次寻找各个镜像中的文件，如果找到，则将其<u>复制到可写容器层</u>，再进行修改。</li><li>删除文件：删除文件也会从上往下依次寻找各个镜像中的文件，一旦找到，<u>并不会直接删除</u>镜像中的文件，而是在可写容器层<strong>标记</strong>这个删除操作。</li></ul><p>我们对容器内文件的操作，都是基于最上层的可写容器层来进行的，这样就可以保护镜像的完整性</p><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>我们可以手动的构建自己需要的镜像，构建镜像有两种方式</p><ul><li>使用commit命令来完成</li><li>使用DockerFIle来完成</li></ul><p><strong>这里先看第一种</strong></p><p>我们以Ubuntu镜像为例</p><p>首先从仓库中拉取ubuntu镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu</span><br></pre></td></tr></table></figure><p>然后直接启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu</span><br></pre></td></tr></table></figure><p>接着安装一下jdk8</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install openjdk-8-jdk</span><br></pre></td></tr></table></figure><p>完成安装后我们就可以使用commit来提交当前的容器，并保存为新的镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit 容器名称/id 新的镜像名称</span><br></pre></td></tr></table></figure><p>再查看一下镜像仓库，就可以看见我们刚才创建的带有jdk8的centos镜像了</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403112359686.png" alt="image-20240311235957633"></p><p>可以看见装了jdk的镜像比原来的镜像大了好几倍，但我们可以直接通过这个镜像来启动一个带有java环境的容器了。</p><p>虽然但是，Docker官方并不推荐这样创建新镜像，因为这种容器就是一个黑箱了，使用者很难知道这个镜像内有什么，安全性低；同时要一个一个的构建这样的镜像也很费事。</p><p><strong>下面使用Dockerfile的形式来创建一个同样的镜像</strong></p><p>首先新建一个名为Dockerfile的文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure><p>然后在里面编写如下的指令来告诉Docker我们需要什么</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN apt update</span><br><span class="line">RUN apt install -y openjdk-8-jdk</span><br></pre></td></tr></table></figure><p>其实文件里的内容刚跟之前手动执行的差不多</p><p>我们保存文件后来告诉Docker要按照这个文件来创建镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &lt;镜像名称&gt; &lt;构建目录&gt;</span><br></pre></td></tr></table></figure><p>按回车，Docker就会执行我们的文件内的指令</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403120020707.png" alt="image-20240312002045647"></p><p>执行中的每一步我们都可以很清晰直观的看见（Docker镜像有缓存机制，就算现在中途退出了，然后重新build一遍，Docker也会将之前构建好的镜像拿来用，需要注意的是，底层发生变化会导致其所有上层的缓存失效）</p><p>构建好了我们就可以在本地镜像仓库看见它了</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403120016533.png" alt="image-20240312001650479"></p><p>因为实际山执行的步骤和手动设置是一样的，所以他们打包的大小也几乎一致</p><p>但是我们可以使用<code>histry</code>来查看它的构建历史，它保存了我们刚才执行的操作和之前他人的操作</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403120024244.png" alt="image-20240312002406181"></p><p>而我们手动通过<code>commit</code>来创建的镜像则没有保存我们刚才手动提交的记录</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403120025321.png" alt="image-20240312002532262"></p><h3 id="发布远程镜像到仓库"><a href="#发布远程镜像到仓库" class="headerlink" title="发布远程镜像到仓库"></a>发布远程镜像到仓库</h3><p>Docker这玩意某种意义上是不是跟Git很像？Git有GitHub，那我们Docker自然也得安排上DockerHub</p><p>首先在<a href="">DockerHub官网</a>上注册一个账号，然后创建一个仓库，创建过程不多赘述了，都学Docker了应该都用过github吧，大差不差的</p><p>这里我们创建好Docker仓库后，就可以上传本地的镜像了，最好把名称改的规范一点，这里使用<code>tag</code>来打标签</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag ubuntu-java-file:latest 用户名/仓库名称:版本</span><br></pre></td></tr></table></figure><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403120035502.png" alt="image-20240312003505435"></p><p>接着我们需要登录一下docker</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login user -u &lt;用户名&gt;</span><br></pre></td></tr></table></figure><p>登录成功后就可以上传了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push &lt;镜像名&gt;:版本</span><br></pre></td></tr></table></figure><p>阿里云的小水管上传了好久。。。</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403120038498.png" alt="image-20240312003832450"></p><p>最后上传好了就可以在之前创建的DockerHub仓库中看见了</p><p>刚才创建的仓库如果是公开仓库的话就可以被随意的下载，这里就可以先删除本地的镜像，然后从我们刚才创建的仓库中拉取镜像</p><p>先搜索一下仓库里存不存在这个镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search hantou/hantou_repo</span><br></pre></td></tr></table></figure><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403120044288.png" alt="image-20240312004437243"></p><p>接下来选择我们要下载的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull hantou/hantou_repo：1.0</span><br></pre></td></tr></table></figure><p>由于镜像在上传后会被压缩，所以拉取下来的镜像比我们实际上传的600多m要小不少</p><p>这就是大概的DockerHub的基本操作</p><hr><h2 id="实战：使用IDEA构建SpringBoot程序的镜像"><a href="#实战：使用IDEA构建SpringBoot程序的镜像" class="headerlink" title="实战：使用IDEA构建SpringBoot程序的镜像"></a>实战：使用IDEA构建SpringBoot程序的镜像</h2><p>这里就以我之前写的<a href="">WIT问卷管理系统</a>为例子吧。</p><p>首先在之前写好的SpringBoot项目中新建一个DockerFile</p><p>在Dockerfile中写入我们的base镜像，之前我已经创建好了并且传到docker仓库了，这里就直接拉取</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403120957031.png" alt="image-20240312095124511"></p><p>接下来需要连接我们虚拟机/云服务器下的docker服务</p><p>这里我用的是阿里云</p><p>这里需要配置Docker的服务器，也就是我们在Ubuntu服务器安装的Docker，这里我们填写服务器相关信息，我们首选需要去修改一下Docker的一些配置，开启远程客户端访问：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/systemd/system/multi-user.target.wants/docker.service </span><br></pre></td></tr></table></figure><p>打开后，添加高亮部分：</p><p><img src="https://s2.loli.net/2022/07/01/OVMDGqiYWU9E7fA.png" alt="image-20220701202846707"></p><p>修改完成后，重启Docker服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker.service </span><br></pre></td></tr></table></figure><p>由于我们用的是云服务器，需要在后台开放2375 TCP连接端口</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403120957021.png" alt="image-20240312095308125"></p><p>现在接着在IDEA中进行配置：</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403120957016.png" alt="image-20240312095323016"></p><p>先在edit中添加一个服务器链接</p><p>新增一个server，选择tcp链接，输入<code>tcp://IP:2375</code>即可</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403120958312.png" alt="image-20240312095849222"></p><p>添加好以后我们接着对Springboot包用maven打包</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403121009666.png" alt="image-20240312100911598"></p><p>打包完成后我们将构建好的jar包导入Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> target/my-project-backend-0.0.1-SNAPSHOT.jar app.jar</span></span><br></pre></td></tr></table></figure><p>这里是使用copy指令将文件拷贝到docker的默认路径中</p><p>然后设置在容器启动时开启我们的java程序，这里通过CMD完成</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> java -jar app.jar</span></span><br></pre></td></tr></table></figure><p>CMD命令可以设定容器启动后执行的命令，EXPOSE可以指定容器需要暴露的端口，但是现在我们还没有学习网络相关的知识，所以暂时不使用，这里指定为我们启动Java项目的命令。配置完成后在左侧点击运行，如果出现<code>Failed to deploy XXX Dockerfile: Dockerfile&#39;: Not connected to docker</code>错误，在排除服务器未开放的情况下，可能是idea权限不足导致的，退出idea再以管理员身份重新运行即可</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403121022222.png" alt="image-20240312102248151"></p><p>在构建成功后我们就可以在Docker 服务器中看到我们刚才传上来的新镜像了</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403121026555.png" alt="image-20240312102622470"></p><p>在镜像中可以看见我们刚才添加Springboot的操作</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403121027893.png" alt="image-20240312102745769"></p><p>接着在IDEA中启动镜像</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403121031683.png" alt="image-20240312103111610"></p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403121031716.png" alt="image-20240312103129637"></p><p>点击启动即可，这里有点小翻车，因为我的项目用的是jdk17，而我们得镜像里只安装了jdk8</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403121033638.png" alt="image-20240312103325574"></p><p>只需要把之前添加jdk的操作版本换成17即可</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403121041939.png" alt="image-20240312104128830"></p><p>更换后再次启动，就发现成功运行在docker里了，不过我这个项目还用到了Redis，Mysql和RabbitMQ，那些还没有在base镜像里配置，所以功能还无法完全实现，但是总而言之确实在docker里跑起来了</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403121043549.png" alt="image-20240312104330393"></p><p>我们尝试访问一下8080端口，会发现无法访问，这是因为docker容器内部和外部的网络是隔离的，如果我们想要访问容器的服务器，就需要将对应端口绑定在宿主机上，同时让宿主机也开放这个端口，这样才能实现容器内的网络连接</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 -d wit-questionnaire:1.1</span><br></pre></td></tr></table></figure><p>配置完成后，点击重新创建容器</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403121055981.png" alt="image-20240312105540935"></p><p>这下端口映射成功了，这里再次强调，如果是云服务器，需要<u>去安全组中开启对应的端口</u></p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403121053165.png" alt="image-20240312105336101"></p><p>为了方便以后使用，我们还是可以把它推送到DockerHub去</p><p>直接在IDEA上操作</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403121056327.png" alt="image-20240312105631278"></p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403121056024.png" alt="image-20240312105640965"></p><p>填写之前Dockerhub仓库的对应信息，点击ok就可以push到远程仓库了</p><hr><p>参考视频：<a href="https://www.bilibili.com/video/BV1r34y1p7j9?p=10&amp;vd_source=ccb7919bcde1355acd4bb39725e50302">Docker 容器技术 已完结（2022 最新版）4K蓝光画质+杜比音效 从内卷到开摆</a></p><p>视频教程文档：<a href="https://www.itbaima.cn/document/zj9uvg0sp3b0sok8">Docker容器技术</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker入门笔记（1）&quot;&gt;&lt;a href=&quot;#Docker入门笔记（1）&quot; class=&quot;headerlink&quot; title=&quot;Docker入门笔记（1）&quot;&gt;&lt;/a&gt;Docker入门笔记（1）&lt;/h1&gt;&lt;h2 id=&quot;容器技术入门&quot;&gt;&lt;a href=&quot;#容器技</summary>
      
    
    
    
    <category term="知识笔记" scheme="https://hantoul.github.io/categories/%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Docker" scheme="https://hantoul.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>记一次痛苦的项目部署经历（Git&amp;VITE&amp;VUE&amp;NPM&amp;NODE部署踩坑指北）</title>
    <link href="https://hantoul.github.io/2024/03/11/2024-3-16-%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%97%9B%E8%8B%A6%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E7%BB%8F%E5%8E%86%EF%BC%88VITE-VUE-NPM-NODE%E9%83%A8%E7%BD%B2%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%EF%BC%89/"/>
    <id>https://hantoul.github.io/2024/03/11/2024-3-16-%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%97%9B%E8%8B%A6%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E7%BB%8F%E5%8E%86%EF%BC%88VITE-VUE-NPM-NODE%E9%83%A8%E7%BD%B2%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%EF%BC%89/</id>
    <published>2024-03-11T06:46:22.000Z</published>
    <updated>2024-03-16T15:12:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记一次痛苦的项目部署经历（VITE-amp-VUE-amp-NPM-amp-NODE部署踩坑指北）"><a href="#记一次痛苦的项目部署经历（VITE-amp-VUE-amp-NPM-amp-NODE部署踩坑指北）" class="headerlink" title="记一次痛苦的项目部署经历（VITE&amp;VUE&amp;NPM&amp;NODE部署踩坑指北）"></a>记一次痛苦的项目部署经历（VITE&amp;VUE&amp;NPM&amp;NODE部署踩坑指北）</h1><p>最近自己的轻薄本16G的内存做项目时完全不够用了，所以又配了一台64G的主机来写项目。</p><p>既然是用了双主机，当然要涉及到项目间的同步问题，之前还没有做过多设备的协同开发，所以在摸索的过程中今天踩了非常多非常多非常多的坑。</p><h2 id="创建项目时git仓库的选择"><a href="#创建项目时git仓库的选择" class="headerlink" title="创建项目时git仓库的选择"></a>创建项目时git仓库的选择</h2><p>这里是想同步之前开发的<a href="https://hantoul.github.io/2024/01/12/2024-1-12-%E9%97%AE%E5%8D%B7%E8%B0%83%E6%9F%A5%E7%B3%BB%E7%BB%9F/">问卷管理系统</a>的代码；</p><p>这是之前预期的项目结构</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403111815121.png" alt="image-20240309213229994"></p><p>结果成了这样</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403111815097.png" alt="image-20240309213551045"></p><p>我记得之前创建的时候，是直接用的Idea做的commit，当时是直接在外层的Project里面点的提交，然后又因为前端和后端，还有最外层的文件夹都是各算一个项目，这里的版本控制可以说是一团乱麻，这就导致我直接将我认为的项目的git本地仓库push到github时发现哥们我后端文件呢？？？</p><p>非常酸爽，我做了各种尝试</p><ul><li>试图将后端仓库的<code>.git</code>文件夹删掉； -&gt; 无果，push之后虽然显示文件夹，但是点一下就404</li><li>试图删除全部的<code>.git</code>，然后重新创建本地git再push，前端跑不起来寄了</li><li>试图将整个项目先做一个git仓库，然后后端部分引用另一个git仓库（其实这也算一种解耦合?（笑。最后没找到这个引用方法，同时我作为全干开发的话，这样我都不知道怎么版本管理了。。。</li></ul><p>最后做了下面的决定</p><h2 id="先解决前端报错的问题"><a href="#先解决前端报错的问题" class="headerlink" title="先解决前端报错的问题"></a>先解决前端报错的问题</h2><p>删除本地git仓库后，执行npm run dev 就会报如下的错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] Could not resolve &quot;vue-demi&quot;</span><br><span class="line"></span><br><span class="line">pgsql</span><br><span class="line">../node_modules/vue-echarts/dist/index.esm.min.js:1:216:</span><br><span class="line">  1 │ ... as s,getCurrentInstance as c,onMounted as l,onBeforeUnmount as f,h as p,nextTick as v&#125;from&quot;vue-demi&quot;;import&#123;throttle as d,init as h&#125;from&quot;echarts/core&quot;;import&#123;addListener as g,removeListener ...</span><br><span class="line">    ╵                                                                                               ~~~~~~~~~~</span><br><span class="line">You can mark the path &quot;vue-demi&quot; as external to exclude it from the bundle, which will remove this</span><br><span class="line">error.</span><br><span class="line"></span><br><span class="line">X [ERROR] Could not resolve &quot;resize-detector&quot;</span><br><span class="line"></span><br><span class="line">javascript</span><br><span class="line">../node_modules/vue-echarts/dist/index.esm.min.js:1:325:</span><br><span class="line">  1 │ ...ttle as d,init as h&#125;from&quot;echarts/core&quot;;import&#123;addListener as g,removeListener as m&#125;from&quot;resize-detector&quot;;var O=function()&#123;return O=Object.assign||function(e)&#123;for(var t,n=1,r=arguments.length;... </span><br><span class="line">    ╵                                                                                           ~~~~~~~~~~~~~~~~~</span><br><span class="line">You can mark the path &quot;resize-detector&quot; as external to exclude it from the bundle, which will</span><br><span class="line">remove this error.</span><br></pre></td></tr></table></figure><p><strong>按照道理来说</strong>，git应该只负责版本控制，把它的文件删了并不会影响程序的运行，但是他就是寄了，同一台电脑上，环境完全一致。</p><p>试了很多方法，疯狂的调npm，vite和vue的配置，然后把依赖包删了下下了删重复了很多次无果。</p><p>最后决定把在笔记本上能跑的代码先复制到主机上看能不能跑，结果不出所料，寄了</p><p>还是到处查解决办法，但好像这个问题独一家，就是没办法解决</p><p>最后折腾了五六个小时，突然想想是不是大的框架版本有问题</p><p>最后和能跑起来的程序分别<strong>比对了npm、vite、node的版本，果然不一样</strong></p><p>有预感是找到大问题了，所以就照着网上的教学把他们的版本都改成和以前一样的版本</p><p>然后跑一下前端，发现已经进入了，点开不会跟之前一样直接error退出，而是给出提示框，显而易见是有一些依赖没有自动导入进来</p><p>就是把pinia，axios，element-plus手动安一下，前端程序就正常跑起来啦</p><h2 id="后端部分"><a href="#后端部分" class="headerlink" title="后端部分"></a>后端部分</h2><p>前端的部分暂时结局了，现在需要解决git仓库的问题了</p><p>直接删除项目中所有git文件，然后开启idea打开项目文件夹，发现前端和后端都没有被自动识别为模块，我手动将其<strong>添加到Project Settings的Modules</strong>中，但是前端能正常跑，而后端就各种报错，maven直接不识别后端的文件，导致所有依赖都没有被正常引入</p><p>原因经过漫长的尝试发现是因为之前直接引入了后端的文件夹</p><p><strong>这时就会找不到启动类；Run/Debug Configuration中找不到SpringBoot项目等问题</strong></p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403110914372.png" alt="image-20240311091402382"></p><p>正确的做法是选中后端的<code>pom.xml</code>文件</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403110914807.png" alt="image-20240311091455732"></p><p>经过快几个周末的折腾成功传到了github上实现了两台电脑之间的代码同步，并且两边都能跑起来；虽然这不是个很复杂的活，但是这些坑真的很难避免 T T</p><h2 id="今天的部署流程为总结以下经验"><a href="#今天的部署流程为总结以下经验" class="headerlink" title="今天的部署流程为总结以下经验"></a>今天的部署流程为总结以下经验</h2><ul><li><p>在<strong>创建项目的git仓库时要仔细仔细再仔细</strong>，多确认一下仓库的结构，不要跟这次一样搞了几个月最后得删掉重新部署</p></li><li><p>与后端完备的SpringBoot项目不同，<strong>前端项目的部署对系统环境非常及其超级敏感</strong>，在部署的时候要注意版本</p></li><li><p>在写前端的时候，<strong>尽量使用确定的版本</strong>，避免安装一时爽，部署火葬场！</p><p>比如<code>npm install pinia@1.8.21</code>而不是<code>npm install pinia</code></p></li><li><p>导入项目时要导入<strong>正确的文件</strong>，比如SpingBoot要导入<code>pom.xml</code>文件</p></li><li><p>使用git同步文件时要提前<strong>规划好gitignore文件</strong>的内容，避免上传过多无用的非必要代码部分</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;记一次痛苦的项目部署经历（VITE-amp-VUE-amp-NPM-amp-NODE部署踩坑指北）&quot;&gt;&lt;a href=&quot;#记一次痛苦的项目部署经历（VITE-amp-VUE-amp-NPM-amp-NODE部署踩坑指北）&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="知识笔记" scheme="https://hantoul.github.io/categories/%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="项目部署" scheme="https://hantoul.github.io/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    
    <category term="运维" scheme="https://hantoul.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>JUC笔记（二）</title>
    <link href="https://hantoul.github.io/2024/03/11/2024-3-11-JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://hantoul.github.io/2024/03/11/2024-3-11-JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2024-03-11T03:26:42.000Z</published>
    <updated>2024-03-11T03:26:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-JUC-笔记（2）"><a href="#Java-JUC-笔记（2）" class="headerlink" title="Java JUC 笔记（2）"></a>Java JUC 笔记（2）</h1><h2 id="锁框架"><a href="#锁框架" class="headerlink" title="锁框架"></a>锁框架</h2><p>JDK5以后增加了Lock接口用来实现锁功能，其提供了与synchronized类似的同步功能，但是在使用时手动的获取和释放锁</p><h3 id="Lock和Condition锁"><a href="#Lock和Condition锁" class="headerlink" title="Lock和Condition锁"></a>Lock和Condition锁</h3><p>这里的锁与<code>synchronized</code>锁不太一样，我们可以认为是Lock一把真正意义上的锁，每个锁都是一个对应的锁对象，我们在应用时只需要对这个锁对象进行上锁或者解锁的操作即可。我们首先来看看，此接口中定义了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">  <span class="comment">//获取锁，拿不到锁会阻塞，等待其他线程释放锁，获取到锁后返回</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//同上，但是等待过程中会响应中断</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="comment">//非阻塞地获取锁，如果能获取到会返回true，不能返回false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//尝试获取锁，但是可以限定超时时间，如果超出时间还没拿到锁返回false，否则返回true，可以响应中断</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="comment">//释放锁</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//暂时可以理解为替代传统的Object的wait()、notify()等操作的工具</span></span><br><span class="line">    Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样按照（一）中的案例，演示如何使用Lock类来进行加锁和释放锁操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">testLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();   <span class="comment">//可重入锁ReentrantLock类是Lock类的一个实现，我们后面会进行介绍</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">action</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;   <span class="comment">//还是以自增操作为例</span></span><br><span class="line">                testLock.lock();    <span class="comment">//加锁，加锁成功后其他线程如果也要获取锁，会阻塞，等待当前线程释放</span></span><br><span class="line">                i++;</span><br><span class="line">                testLock.unlock();  <span class="comment">//解锁，释放锁之后其他线程就可以获取这把锁了（注意在这之前一定得加锁，不然报错）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(action).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(action).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);   <span class="comment">//等上面两个线程跑完</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的线程在执行到action中的代码时，是真的回去请求获取main中定义的锁对象的，他们俩争抢唯一的一把锁，自然也不会出现交错的自增导致线程冲突的问题了。</p><blockquote><p>上面的代码中出现了ReentrantLock，这里简单说一下</p><p>reetrantlock可以用来当做synchronized使用的，它比synchronized更安全，在线程tryLock()失败时不会导致死锁，它不会在获取不到锁时无限等待，因为我们必须先获取到锁，然后再进入代码块，最后在finally里释放锁，才能完成全部流程</p></blockquote><p>但是这样开了两个线程去自发地争抢锁，那我们如何去控制线程等待和唤醒等待中（wait()和notify()）的线程呢？这里并发包提供了Condition接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">  <span class="comment">//与调用锁对象的wait方法一样，会进入到等待状态，但是这里需要调用Condition的signal或signalAll方法进行唤醒（感觉就是和普通对象的wait和notify是对应的）同时，等待状态下是可以响应中断的</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="comment">//同上，但不响应中断（看名字都能猜到）</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//等待指定时间，如果在指定时间（纳秒）内被唤醒，会返回剩余时间，如果超时，会返回0或负数，可以响应中断</span></span><br><span class="line">  <span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="comment">//等待指定时间（可以指定时间单位），如果等待时间内被唤醒，返回true，否则返回false，可以响应中断</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="comment">//可以指定一个明确的时间点，如果在时间点之前被唤醒，返回true，否则返回false，可以响应中断</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="comment">//唤醒一个处于等待状态的线程，注意还得获得锁才能接着运行</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//同上，但是是唤醒所有等待线程</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以直接通过我们创建的锁对象来<code>lock.getCondition()</code>来获取Condition对象，然后调用Condition对象实现唤醒和等待</p><p>△ 同一把锁内可以存在<strong><u>多个</u></strong>Condition对象，他们的等待队列是分开计算的（所以可以实现多等待队列）</p><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>大家可否学过操作系统或者计组？这里跟CPU响应中断有点像。</p><blockquote><p>CPU需要处理许多事，而每件事的优先级都不同。如果CPU在处理一件事时，有一件更紧急的事来了，CPU就需要先放下手上的事，优先处理更紧急的事，以此类推，不断的套娃（笑</p><p>虽然跟这篇文章主题没什么关系，但是在CPU中，它心情不好的时候是可以只干自己愿意干的事的（关中断），在那时就无法响应更高的请求了</p></blockquote><p>可重入锁简单的理解其实也还是套娃（同一个线程可以<strong>反复上锁</strong>），不过这里可重入锁要锁的对象是他自己，在一个锁它负责的代码范围内可以套入一次锁，同时每次上锁和解锁操作必须<strong>一一对应</strong>，不然显然会出现问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    lock.lock();</span><br><span class="line">    lock.lock();   <span class="comment">//连续加锁2次</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程2想要获取锁&quot;</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程2成功获取到锁&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    lock.unlock();</span><br><span class="line">    System.out.println(<span class="string">&quot;线程1释放了一次锁&quot;</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    lock.unlock();</span><br><span class="line">    System.out.println(<span class="string">&quot;线程1再次释放了一次锁&quot;</span>);  <span class="comment">//释放两次后其他线程才能加锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在一段线程内通过锁调用<code>getHoleCount()</code>方法来查询当前套娃的层数。</p><p>实际上，若有线程拿到锁了，如果有其他线程也来获取锁，他们会进入一个等待队列，我们同样可以通过锁对象调用<code>Lock.getQueueLength()</code>方法来获取等待该锁的线程数量的估计值</p><p>同样的,锁也能通过<code>lock.getWaitQueueLength(Condition condition)</code>方法来查询等待Condition的线程数量</p><blockquote><p>这里再次强调一下关系，锁拥有不同的condition，然后通过锁来查询condition的等待队列的线程对象</p></blockquote><p>锁对象还提供了<code>hasQueuedThread(Thread t)</code>的方法来查询一个线程是否在等待队列中</p><h4 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h4><p>之前提到若线程间争抢同一把锁，会让他们暂时进入到等待队列中，那么线程获取锁的顺序是否是按照进入等待队列的先后顺序呢？</p><p>在ReentrantLock的构造方法中是这样写的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();   <span class="comment">//看名字貌似是非公平的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实锁分为公平锁和非公平锁，可以看出默认创建出来的是非公平锁</p><ul><li>公平锁：多个线程按照进入等待队列的次序来获得锁</li><li>非公平锁：多个线程锁获取锁时，各个线程会直接去抢锁，若获取不到才回去排队</li></ul><blockquote><p>公平锁一定是公平的吗？</p></blockquote><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁并不是专门用作读写操作的的锁，但是可以以读写操作来举例理解</p><blockquote><p>还是以操作系统举例</p><ul><li>在没有线程在写某个文件时，同时可以有多个线程在读该文件</li><li>在没有线程在读某个文件时，同时只能有一个线程写该文件</li></ul></blockquote><p>这里的读写锁机制如下</p><ul><li>读锁：写锁未占用，同时可以多个线程加读锁</li><li>写锁：读锁未占用，同时只能有一个线程加写锁</li></ul><p>读写锁与可重入锁一样，有专门的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line">    <span class="comment">//获取读锁</span></span><br><span class="line">    Lock <span class="title function_">readLock</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//获取写锁</span></span><br><span class="line">    Lock <span class="title function_">writeLock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReadWriteLock接口有一个实现类ReentrantReadWriteLock（它本身不是锁），我们操作ReentrantReadWriteLock时不能直接上锁，而是要先获取读锁或写锁后再上锁。</p><p>并且，ReentrantReadWriteLock不仅具有读写锁的功能，还保留了可重入锁和公平/非公平机制，比如同一个线程可以重复为写锁加锁，并且必须全部解锁才真正释放锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;成功获取到写锁！&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    System.out.println(<span class="string">&quot;释放第一层锁！&quot;</span>);</span><br><span class="line">    lock.writeLock().unlock();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;释放第二层锁！&quot;</span>);</span><br><span class="line">    lock.writeLock().unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="锁降级和锁升级"><a href="#锁降级和锁升级" class="headerlink" title="锁降级和锁升级"></a>锁降级和锁升级</h4><p>锁降级指的是写锁<strong>降级</strong>成读锁；</p><p>当一个线程持有写锁，虽然别的线程不能申请读锁，但是持有写锁的线程可以将加一把读锁，这就是锁降级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    lock.readLock().lock();</span><br><span class="line">    System.out.println(<span class="string">&quot;成功加读锁！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，如果我们在同时加了写锁和读锁的情况下，释放写锁，是否其他的线程就可以一起加读锁了呢？</p><p>在一个线程同时持有写锁和读锁的情况下，释放了写锁，其他线程也会获取到写锁，这种情况就叫做<strong>锁降级</strong></p><p>注意在仅持有读锁的情况下去申请写锁，属于”<strong>锁升级</strong>“，ReentrantReadWriteLock是不支持的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    lock.readLock().lock();</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    System.out.println(<span class="string">&quot;锁升级成功！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到线程直接卡在加写锁的那一句了。</p><blockquote><p><strong>锁降级</strong>： 有写锁 -&gt; 可以再申请读锁； 释放写锁后其他线程也可以申请读锁了<br><strong>锁升级</strong>（ReentrantReadWriteLock不支持）： 有读锁 -&gt; 无法申请写锁；</p></blockquote><h3 id="线程同步器AQS"><a href="#线程同步器AQS" class="headerlink" title="线程同步器AQS"></a>线程同步器AQS</h3><h4 id="底层实现（以公平锁为例）"><a href="#底层实现（以公平锁为例）" class="headerlink" title="底层实现（以公平锁为例）"></a>底层实现（以公平锁为例）</h4><p>锁执行lock对象时，实际上是调用的Sync对象的方法，而Sync又继承自AbstractQueuedSynchronizer（队列同步器AQS）</p><p>既然是AQS中的Q是Queued，那么它自然需要维护一个队列</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403051659198.png" alt="image-20240305165944081"></p><p>对于每个<strong>节点</strong>，他有几个比较重要的字段和方法</p><ul><li>Prev和Next，显而易见是指向前序节点和后续节点的指针</li><li>status：表示节点不同的状态</li><li>thread：记录被封装到该节点内的线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每个处于等待状态的线程都可以是一个节点，并且每个节点是有很多状态的</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="comment">//每个节点都可以被分为独占模式节点或是共享模式节点，分别适用于独占锁和共享锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//等待状态，这里都定义好了</span></span><br><span class="line">   <span class="comment">//唯一一个大于0的状态，表示已失效，可能是由于超时或中断，此节点被取消。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//此节点后面的节点被挂起（进入等待状态）</span></span><br><span class="line">    <span class="comment">//注意这里是后面</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="comment">//在条件队列中的节点才是这个状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">  <span class="comment">//传播，一般用于共享锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;    <span class="comment">//等待状态值</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;   <span class="comment">//双向链表基操</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;   <span class="comment">//每一个线程都可以被封装进一个节点进入到等待队列</span></span><br><span class="line">  </span><br><span class="line">    Node nextWaiter;   <span class="comment">//在等待队列中表示模式，条件队列中作为下一个结点的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="type">int</span> waitStatus) &#123;</span><br><span class="line">        <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一开始的时候，<code>head</code>和<code>tail</code>都是<code>null</code>，<code>state</code>为默认值<code>0</code></p><p>继续看AQS初始化的其他内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接使用Unsafe类进行操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"><span class="comment">//记录类中属性的在内存中的偏移地址，方便Unsafe类直接操作内存进行赋值等（直接修改对应地址的内存）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> stateOffset;   <span class="comment">//这里对应的就是AQS类中的state成员字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> headOffset;    <span class="comment">//这里对应的就是AQS类中的head头结点成员字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> tailOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> waitStatusOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;   <span class="comment">//静态代码块，在类加载的时候就会自动获取偏移地址</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stateOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;state&quot;</span>));</span><br><span class="line">        headOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;head&quot;</span>));</span><br><span class="line">        tailOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;tail&quot;</span>));</span><br><span class="line">        waitStatusOffset = unsafe.objectFieldOffset</span><br><span class="line">            (Node.class.getDeclaredField(<span class="string">&quot;waitStatus&quot;</span>));</span><br><span class="line">        nextOffset = unsafe.objectFieldOffset</span><br><span class="line">            (Node.class.getDeclaredField(<span class="string">&quot;next&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过CAS操作来修改头结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetHead</span><span class="params">(Node update)</span> &#123;</span><br><span class="line">  <span class="comment">//调用的是Unsafe类的compareAndSwapObject方法，通过CAS算法比较对象并替换</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="built_in">this</span>, headOffset, <span class="literal">null</span>, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同上，省略部分代码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetWaitStatus</span><span class="params">(Node node, <span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetNext</span><span class="params">(Node node, Node expect, Node update)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>可以发现，队列同步器由于要使用到CAS算法，所以，直接使用了Unsafe工具类，Unsafe类中提供了CAS操作的方法（Java无法实现，底层由C++实现）所有对AQS类中成员字段的修改，都有对应的CAS操作封装。</p><p>CAS类提供了一些可重写的方法，同时也为独占式和非独占式锁都提供了对应的方法，已经一些已经写好的模板方法（他们会调用重写的方法）。</p><p>首先看一些可重写方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//独占式获取同步状态，查看同步状态是否和参数一致，如果返没有问题，那么会使用CAS操作设置同步状态并返回true</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//独占式释放同步状态</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//共享式获取同步状态，返回值大于0表示成功，否则失败</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//共享式释放同步状态</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否在独占模式下被当前线程占用（锁是否被当前线程持有）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这些需要重写的方法默认是直接抛出<code>UnsupportedOperationException</code>，也就是说根据不同的锁类型，我们需要去实现对应的方法，我们可以来看一下ReentrantLock（此类是全局独占式的）中的公平锁是如何借助AQS实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//加锁操作调用了模板方法acquire</span></span><br><span class="line">  <span class="comment">//为了防止各位绕晕，请时刻记住，lock方法一定是在某个线程下为了加锁而调用的，并且同一时间可能会有其他线程也在调用此方法</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先看看加锁操作干了什么事情，这里直接调用了AQS提供的模板方法<code>acquire()</code>，我们来看看它在AQS类中的实现细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span> <span class="comment">//这个是JEP 270添加的新注解，它会保护被注解的方法，通过添加一些额外的空间，防止在多线程运行的时候出现栈溢出，下同</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))   <span class="comment">//节点为独占模式Node.EXCLUSIVE</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的<code>tryAcquire()方法</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">  <span class="comment">//可重入独占锁的公平实现</span></span><br><span class="line">    <span class="meta">@ReservedStackAccess</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();   <span class="comment">//先获取当前线程的Thread对象</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();     <span class="comment">//获取当前AQS对象状态（独占模式下0为未占用，大于0表示已占用）</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;       <span class="comment">//如果是0，那就表示没有占用，现在我们的线程就要来尝试占用它</span></span><br><span class="line">            <span class="comment">//一直到这里为止还可能有多个线程在这一步</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;    <span class="comment">//等待队列是否不为空且当前线程没有拿到锁，其实就是看看当前线程有没有必要进行排队，如果没必要排队，就说明可以直接获取锁</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;   <span class="comment">//CAS设置状态，如果成功则说明成功拿到了这把锁，失败则说明可能这个时候其他线程在争抢，并且还比你先抢到</span></span><br><span class="line">                setExclusiveOwnerThread(current);    <span class="comment">//成功拿到锁，会将独占模式所有者线程设定为当前线程（这个方法是父类AbstractOwnableSynchronizer中的，就表示当前这把锁已经是这个线程的了）</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">//占用锁成功，返回true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;   <span class="comment">//如果不是0，那就表示被线程占用了，这个时候看看是不是自己占用的，如果是，由于是可重入锁，可以继续加锁</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;    <span class="comment">//多次加锁会将状态值进行增加，状态值就是加锁次数</span></span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)   <span class="comment">//加到int值溢出了？</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);   <span class="comment">//设置为新的加锁次数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//其他任何情况都是加锁失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403051727284.png" alt="image-20240305172706008"></p><p>在了解了公平锁的实现之后，是不是感觉有点恍然大悟的感觉，虽然整个过程非常复杂，但是只要理清思路，还是比较简单的。</p><p>接着我们看<code>addWaiter(Node.EXCLUSIVE)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 先尝试使用CAS直接入队，如果这个时候其他线程也在入队（就是不止一个线程在同一时间争抢这把锁）就进入enq()</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//此方法是CAS快速入队失败时调用</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">  <span class="comment">//自旋形式入队，可以看到这里是一个无限循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;  <span class="comment">//这种情况只能说明头结点和尾结点都还没初始化</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))   <span class="comment">//初始化头结点和尾结点</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;   <span class="comment">//只有CAS成功的情况下，才算入队成功，如果CAS失败，那说明其他线程同一时间也在入队，并且手速还比当前线程快，刚好走到CAS操作的时候，其他线程就先入队了，那么这个时候node.prev就不是我们预期的节点了，而是另一个线程新入队的节点，所以说得进下一次循环再来一次CAS，这种形式就是自旋</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403051741919.png" alt="img"></p><p>再看<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;   <span class="comment">//可以看到当此节点位于队首(node.prev == head)时，会再次调用tryAcquire方法获取锁，如果获取成功，会返回此过程中是否被中断的值</span></span><br><span class="line">                setHead(node);    <span class="comment">//新的头结点设置为当前结点</span></span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// 原有的头结点没有存在的意义了</span></span><br><span class="line">                failed = <span class="literal">false</span>;   <span class="comment">//没有失败</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;   <span class="comment">//直接返回等待过程中是否被中断</span></span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//依然没获取成功，</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;   <span class="comment">//将当前节点的前驱节点等待状态设置为SIGNAL，如果失败将直接开启下一轮循环，直到成功为止，如果成功接着往下</span></span><br><span class="line">                parkAndCheckInterrupt())   <span class="comment">//挂起线程进入等待状态，等待被唤醒，如果在等待状态下被中断，那么会返回true，直接将中断标志设为true，否则就是正常唤醒，继续自旋</span></span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);   <span class="comment">//通过unsafe类操作底层挂起线程（会直接进入阻塞状态）</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403051741616.png" alt="img"></p><p>上面是获取锁</p><p>释放锁其实也是类似的，在释放的过程中，需要唤醒队列中下一个结点中的线程，然后还要维护AQS中的状态（删除挂起的队列，减少等待队列中节点数量）</p><blockquote><p>还记得JVM的垃圾回收器吗，这里将结点设置为空，然后把指向他的指针知道别的地方，他稍后就会被垃圾回收器回收</p></blockquote><p>具体的代码也贴一下吧</p><blockquote><p><code>unlock()</code>方法是在AQS中实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line"> sync.release(<span class="number">1</span>);    <span class="comment">//直接调用了AQS中的release方法，参数为1表示解锁一次state值-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (tryRelease(arg)) &#123;   <span class="comment">//和tryAcquire一样，也得子类去重写，释放锁操作</span></span><br><span class="line">     <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;    <span class="comment">//释放锁成功后，获取新的头结点</span></span><br><span class="line">     <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)   <span class="comment">//如果新的头结点不为空并且不是刚刚建立的结点（初始状态下status为默认值0，而上面在进行了shouldParkAfterFailedAcquire之后，会被设定为SIGNAL状态，值为-1）</span></span><br><span class="line">         unparkSuccessor(h);   <span class="comment">//唤醒头节点下一个节点中的线程</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line"> <span class="comment">// 将等待状态waitStatus设置为初始值0</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line"> <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">     compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//获取下一个结点</span></span><br><span class="line"> <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line"> <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;   <span class="comment">//如果下一个结点为空或是等待状态是已取消，那肯定是不能通知unpark的，这时就要遍历所有节点再另外找一个符合unpark要求的节点了</span></span><br><span class="line">     s = <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)   <span class="comment">//这里是从队尾向前，因为enq()方法中的t.next = node是在CAS之后进行的，而 node.prev = t 是CAS之前进行的，所以从后往前一定能够保证遍历所有节点</span></span><br><span class="line">         <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">             s = t;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (s != <span class="literal">null</span>)   <span class="comment">//要是找到了，就直接unpark，要是还是没找到，那就算了</span></span><br><span class="line">     LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们来看看<code>tryRelease()</code>方法是怎么实现的，具体实现在Sync中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line"> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;   <span class="comment">//先计算本次解锁之后的状态值</span></span><br><span class="line"> <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())   <span class="comment">//因为是独占锁，那肯定这把锁得是当前线程持有才行</span></span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();   <span class="comment">//否则直接抛异常</span></span><br><span class="line"> <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"> <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;  <span class="comment">//如果解锁之后的值为0，表示已经完全释放此锁</span></span><br><span class="line">     free = <span class="literal">true</span>;</span><br><span class="line">     setExclusiveOwnerThread(<span class="literal">null</span>);  <span class="comment">//将独占锁持有线程设置为null</span></span><br><span class="line"> &#125;</span><br><span class="line"> setState(c);   <span class="comment">//状态值设定为c</span></span><br><span class="line"> <span class="keyword">return</span> free;  <span class="comment">//如果不是0表示此锁还没完全释放，返回false，是0就返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>这样就大概讲完了可重入锁的公平锁实现，实际上也不是无法理解的（迫真</p><p>下面是讲师总结的流程图</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403051742702.png" alt="image-20230306171428206"></p><p>这是我自己总结的</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403052017121.png" alt="img"></p><h4 id="公平锁真的公平吗？"><a href="#公平锁真的公平吗？" class="headerlink" title="公平锁真的公平吗？"></a>公平锁真的公平吗？</h4><p>在并发的情况下，公平锁是有概率变得不公平的</p><p>对于每个需要尝试获取锁的进程，他们都会先执行tryAcquire()来尝试获取锁，在尝试获取锁的过程中会先判断在队列中是否有节点处于等待队列，然后一旦发现没有，就会执行CAP操作</p><p>现在假设有线程1，线程2和线程3；线程1已经拿到锁了，这时线程2开始尝试获取锁，它发现虽然等待队列是空的，但是CAS操作失败，显然有线程在用锁，这时他开始准备排队了；</p><p>现在，突然线程3也开始尝试获取锁，恰巧在这时线程1释放锁了，线程3说：“消息队列没人在排队，CAS也没人在用，那我就不客气了”，于是线程3顺利地拿到了锁，实现了插队的目的。线程2：“我转个身怎么前面大哥换人了？”</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403052034838.png" alt="image-20240305203430604"></p><p>虽然概率很低，但高并发的情况也不是遇不见这样离谱的情况。</p><p>所以，严格来讲，公平锁只有在等待队列非空的时候才是公平的，就算是公平，也不是按照发请求的先后的公平，而是按照进入等待队列的时间的公平。</p><h4 id="Condition实现原理"><a href="#Condition实现原理" class="headerlink" title="Condition实现原理"></a>Condition实现原理</h4><p>之前我们看了Condition，了解了它实际上就是替代传统对象实现wait/notify操作（在Condition中是await/signal操作）的，并且同一把锁可以创建多个Condition对象，我们现在对Condition对象进行解析</p><p>在AQS中，Condition类有一个实现类ConditionObject，其同样使用链表实现了条件队列</p><blockquote><p>这里的条件队列能允许线程在某些条件不满足的情况下先进入等待状态，并且等待被唤醒；在某个对象进入调用wait()后会被放入条件队列，等待notify()唤醒以争夺锁</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1173984872572414699L</span>;</span><br><span class="line">    <span class="comment">/** 条件队列的头结点 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">/** 条件队列的尾结点 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>这里条件队列直接借用了AQS的Node类，但是使用的是Node类中的nextWaiter字段来连接节点，并且Node的状态设置为CONDITION（处于条件队列中）</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403071305298.png" alt="image-20240307130533174"></p><p>当一个线程调用await()方法时，会进入等待状态（进入<strong>条件</strong>队列），直到其他线程使用signal()方法将其唤醒（进入AQS的<strong>等待</strong>队列）</p><p>下面将会研究await()方法的实现，这里先明确这个方法的目标</p><ul><li>仅有已经持有锁的方法才能够调用await</li><li>当调用await方法后，无论加了多少次锁，都会直接释放锁</li><li>只有其他线程调用signal或者是被中断时，才会唤醒等待中的线程</li><li>被唤醒的线程依然需要等待其他线程释放锁，并且等真正抢到锁以后才会继续执行，并且会恢复到await()时的状态（和await时一样的锁层数）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();   <span class="comment">//如果在调用await之前就被添加了中断标记，那么会直接抛出中断异常</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();    <span class="comment">//为当前线程创建一个新的节点，并将其加入到条件队列中</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);    <span class="comment">//完全释放当前线程持有的锁，并且保存一下state值，因为唤醒之后还得恢复</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;     <span class="comment">//用于保存中断状态</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;   <span class="comment">//循环判断是否位于同步队列中，如果等待状态下的线程被其他线程唤醒，那么会正常进入到AQS的等待队列中（之后我们会讲）</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);   <span class="comment">//如果依然处于等待状态，那么继续挂起</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)   <span class="comment">//看看等待的时候是不是被中断了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//出了循环之后，那线程肯定是已经醒了，这时就差拿到锁就可以恢复运行了</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)  <span class="comment">//直接开始acquireQueued尝试拿锁（之前已经讲过了）从这里开始基本就和一个线程去抢锁是一样的了</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">  <span class="comment">//已经拿到锁了，基本可以开始继续运行了，这里再进行一下后期清理工作</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) </span><br><span class="line">        unlinkCancelledWaiters();  <span class="comment">//将等待队列中，不是Node.CONDITION状态的节点移除</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)   <span class="comment">//依然是响应中断</span></span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">  <span class="comment">//OK，接着该干嘛干嘛</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简而言之</p><ol><li>首先判断当前调用的线程是否处于中断的状态，若已在中断状态了，那么还谈什么等待状态呢，直接抛异常</li><li>在条件队列中加入一个新的节点，并保存当前线程的各种状态</li><li><strong>循环判断</strong>当前线程是否还处于条件队列中，并且在循环里监视有没有在等待时被中断（被中断了一样会醒）</li><li>当跳出循环，表示当前线程一定是醒了，现在只需要拿到锁就可以开始运行了</li><li>在拿到锁后进行<u>收尾工作</u>，打扫一下等待队列，再回头看一眼有没有被中断，之后就正式开始执行自己的任务了</li></ol><p>实际上<code>await()</code>方法比较中规中矩，大部分操作也在我们的意料之中，那么我们接着来看<code>signal()</code>方法是如何实现的，同样的，为了防止各位绕晕，先明确signal的目标：</p><ul><li>只有持有锁的线程才能唤醒<strong>锁所属</strong>（等着这把锁）Condition的的线程</li><li>优先唤醒条件队列队首，若出现问题，就按顺序往下找，直到找到可以唤醒的</li><li>唤醒的本质是将线程从条件队列中移出至等待队列</li><li>拿到锁之后，线程才能恢复运行</li></ul><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403071320891.png" alt="image-20230306171620786"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())    <span class="comment">//先看看当前线程是不是持有锁的状态</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();   <span class="comment">//不是？那你不配唤醒别人</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;    <span class="comment">//获取条件队列的第一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>)    <span class="comment">//如果队列不为空，获取到了，那么就可以开始唤醒操作</span></span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)   <span class="comment">//如果当前节点在本轮循环没有后继节点了，条件队列就为空了</span></span><br><span class="line">            lastWaiter = <span class="literal">null</span>;   <span class="comment">//所以这里相当于是直接清空</span></span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;   <span class="comment">//将给定节点的下一个结点设置为null，因为当前结点马上就会离开条件队列了</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;   <span class="comment">//接着往下看</span></span><br><span class="line">             (first = firstWaiter) != <span class="literal">null</span>);   <span class="comment">//能走到这里只能说明给定节点被设定为了取消状态，那就继续看下一个结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果这里CAS失败，那有可能此节点被设定为了取消状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CAS成功之后，结点的等待状态就变成了默认值0，接着通过enq方法直接将节点丢进AQS的等待队列中，相当于唤醒并且可以等待获取锁了</span></span><br><span class="line">  <span class="comment">//这里enq方法返回的是加入之后等待队列队尾的前驱节点，就是原来的tail</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;   <span class="comment">//保存前驱结点的等待状态</span></span><br><span class="line">  <span class="comment">//如果上一个节点的状态为取消, 或者尝试设置上一个节点的状态为SIGNAL失败（可能是在ws&gt;0判断完之后马上变成了取消状态，导致CAS失败）</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);  <span class="comment">//直接唤醒线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实思路也不是很复杂， 跟之前消费等待队列的思路大差不差</p><ul><li><p>先判断调用signal的线程的状态，是不是有锁，没锁你唤醒个锤子</p></li><li><p>若持有锁，就从条件队列取队首，并进行消费，不断循环判断该节点是否为取消状态，若是则继续看下一个节点；若发现条件队列都空了，就要进行一些收尾工作</p></li><li><p>消费等待队列结点的过程：</p><ol><li>先进行CAS判断，若成功了表明已经有资格进入等待队列了</li><li>将线程加入等待队列，并且获取前驱节点的等待状态</li><li>若上一个节点的状态为取消（上一个节点都被取消了还管他干啥，直接开抢）, 或者尝试设置上一个节点的状态为SIGNAL时失败（想把我挂起？没门，开抢！）</li></ol><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403071333699.png" alt="image-20240307133318626"></p></li></ul><p>其实最让人不理解的就是倒数第二行，明明上面都正常进入到AQS等待队列了，应该是可以开始走正常流程了，那么这里为什么还要提前来一次unpark呢？</p><p>这里其实是为了进行优化而编写，直接unpark会有两种情况：</p><ul><li>如果插入结点前，AQS等待队列的队尾节点就已经被取消，则满足wc &gt; 0</li><li>如果插入node后，AQS内部等待队列的队尾节点已经稳定，满足tail.waitStatus == 0，但在执行ws &gt;0之后 !compareAndSetWaitStatus(p, ws,Node.SIGNAL)之前被取消，则CAS也会失败，满足compareAndSetWaitStatus(p, ws,Node.SIGNAL) == false</li></ul><p>如果这里被提前unpark，那么在<code>await()</code>方法中将可以被直接唤醒，并跳出while循环，直接开始争抢锁，因为前一个等待结点是被取消的状态，没有必要再等它了。</p><p>大致流程如下</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403071333363.png" alt="image-20230306171643082"></p><p>其实不难理解吧。。就是概念比较多，讲师带着顺一遍其实基本能跑通思路</p><hr><h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><p>原子类，正如其名，是可以实现原子操作的类，JUC为我们提供的原子类底层采用CAS算法；所有的原子类都位于<code>java.util.concurrent.atomic</code>包下。</p><h3 id="原子类介绍"><a href="#原子类介绍" class="headerlink" title="原子类介绍"></a>原子类介绍</h3><p>常用的基本数据类型有其对应的原子类封装：</p><ul><li>AutomicInteger：原子更新int</li><li>AtomicLon：原子更新long</li><li>AtomicBoolean：原子更新boolean</li></ul><p>现在我们使用int类型对应的原子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        System.out.println(i.getAndIncrement());  <span class="comment">//如果想实现i += 2这种操作，可以使用 addAndGet() 自由设置delta 值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将int数值封装到此类中（注意必须调用构造方法，它不像Integer那样有装箱机制），并且通过调用此类提供的方法来获取或是对封装的int值进行自增。</p><h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">(<span class="type">int</span> initialValue)</span> &#123;</span><br><span class="line">    value = initialValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AtomicInteger的底层本质是实现了一个<code>volatile</code>类型的int值，这样就可以保证在CAS时的可见性，进而实现原子性</p><p>原子类底层也是采用了CAS算法来保证的原子性，包括<code>getAndSet</code>、<code>getAndAdd</code>等方法都是这样。原子类也直接提供了CAS操作方法，我们可以直接使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">10</span>);</span><br><span class="line">    System.out.println(integer.compareAndSet(<span class="number">30</span>, <span class="number">20</span>));</span><br><span class="line">    System.out.println(integer.compareAndSet(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">    System.out.println(integer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想以普通变量的方式来设定值，那么可以使用<code>lazySet()</code>方法，这样就不采用<code>volatile</code>的立即可见机制了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">integer.lazySet(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>除了基本类有原子类以外，基本类型的数组类型也有原子类：</p><ul><li>AtomicIntegerArray：原子更新int数组</li><li>AtomicLongArray：原子更新long数组</li><li>AtomicReferenceArray：原子更新引用数组</li></ul><p>其实原子数组和原子类型一样的，不过我们可以对数组内的元素进行原子操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">AtomicIntegerArray</span> <span class="variable">array</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">            array.getAndAdd(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(array.get(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JDK8之后，新增了<code>DoubleAdder</code>和<code>LongAdder</code>，在高并发情况下，<code>LongAdder</code>的性能比<code>AtomicLong</code>的性能更；</p><p>比如说在自增时普通的原子类会只对一个value进行CAS，而<code>DoubleAdder</code>和<code>LongAdder</code>会对一个数组进行分散的CAS操作（即不同线程可以对数组中不同的元素进行CAS自增），这样就避免了所有线程都对同一个值进行CAS</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403081057251.png" alt="image-20240308105732094"></p><p>使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">LongAdder</span> <span class="variable">adder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">            adder.add(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();   <span class="comment">//100个线程</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(adder.sum());   <span class="comment">//最后求和即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了对基本数据类型支持原子操作外，对于引用类型，也是可以实现原子操作的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    AtomicReference&lt;String&gt; reference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(a);</span><br><span class="line">    reference.compareAndSet(a, b);</span><br><span class="line">    System.out.println(reference.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JUC还提供了字段原子更新器，可以对类中的某个指定字段进行原子操作（<strong>注意字段必须添加volatile关键字</strong>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        AtomicIntegerFieldUpdater&lt;Student&gt; fieldUpdater =</span><br><span class="line">                AtomicIntegerFieldUpdater.newUpdater(Student.class, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(fieldUpdater.incrementAndGet(student));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ABA问题及其解决方案"><a href="#ABA问题及其解决方案" class="headerlink" title="ABA问题及其解决方案"></a>ABA问题及其解决方案</h4><p>之前的Redis中提过，这里不再赘述<a href="https://hantoul.github.io/2024/02/21/2024-2-21-Redis-%E7%A7%92%E6%9D%80%E7%AC%94%E8%AE%B01-copy/">Redis 秒杀 笔记1</a></p><p>这里的解决方法时记录一个不会重复的版本号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    AtomicStampedReference&lt;String&gt; reference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(a, <span class="number">1</span>);  <span class="comment">//在构造时需要指定初始值和对应的版本号</span></span><br><span class="line">    reference.attemptStamp(a, <span class="number">2</span>);   <span class="comment">//可以中途对版本号进行修改，注意要填写当前的引用对象</span></span><br><span class="line">    System.out.println(reference.compareAndSet(a, b, <span class="number">2</span>, <span class="number">3</span>));   <span class="comment">//CAS操作时不仅需要提供预期值和修改值，还要提供预期版本号和新的版本号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><h3 id="传统容器线程安全吗"><a href="#传统容器线程安全吗" class="headerlink" title="传统容器线程安全吗?"></a>传统容器线程安全吗?</h3><p>以ArrayList为例子，我们创建两个线程，同时向ArrayList中添加数据，各添加1万次，最后获得的队列长度应该是2万。但是在实际情况下，一般都会小于2万个</p><p>ArrayList的入队操作是先确认是否有足够的容量进行插入操作，在确认可以插入后就执行插入操作。在多线程的情况下，A线程执行确认和插入操作之间，B线程执行了插入，导致A线程插入时队列的长度不足，就会导致数组越界，造成最后的结果与预期不一致。</p><p>传统容器虽然在单线程情况下很好用，但是在多线程情况下就会产生安全问题，下面会介绍一些常用的线程安全的并发容器</p><h3 id="并发容器介绍"><a href="#并发容器介绍" class="headerlink" title="并发容器介绍"></a>并发容器介绍</h3><p>如何让传统线程容器安全？显而易见的我们可以使用<code>synchronized</code>关键字，但是这样效率太低了。</p><p>我们直接使用JUC提供的专用于并发场景下的容器。</p><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>比如之前的ArrayList我们可以替换为CopyOnWriteArrayList，它是线程安全的，就不会造成线程之间互相冲突的问题</p><p>那么它是如何执行add()操作的呢?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();   <span class="comment">//直接加锁，保证同一时间只有一个线程进行添加操作</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();  <span class="comment">//获取当前存储元素的数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);   <span class="comment">//直接复制一份数组</span></span><br><span class="line">        newElements[len] = e;   <span class="comment">//修改复制出来的数组</span></span><br><span class="line">        setArray(newElements);   <span class="comment">//将元素数组设定为复制出来的数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到添加操作是直接上锁，并且会先拷贝一份当前存放元素的数组，然后对数组进行修改，再将此数组替换（CopyOnWrite）接着我们来看读操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如其名，CopyOnWriteArrayList会对写操作加上锁，而读操作不需要加锁，毕竟再多人读都不会改变数组的内容，但是有人在写就可能造成前后读取的数据不一致的问题</p><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>接着我们来看对于HashMap的并发容器<code>ConcurrentHashMap</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span>; j++)</span><br><span class="line">                map.put(finalI * <span class="number">100</span> + j, <span class="string">&quot;lbwnb&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(map.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多线程的情况下， 多个线程会争抢同一把锁，我们之前的LongAdder中有一种分散出几个锁来缓解压力的思想，这里也是类似的；在JDK7以前，ConcurrentHashMap的原理是将数据分段存储，每一段都有自己的锁，这样当给一段数据加了锁也不会影响对其他段的操作了</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403111052678.png" alt="image-20240311105110251"></p><p>在JDK8之后，ConcurrentHashMap又引入了红黑树和哈希表综合的机制</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403111055595.png" alt="image-20240311105441364"></p><p>当插入数据时，会先计算对应的哈希值，根据哈希值找到应在数组中存放的位置，然后创建一个新的结点并添加到对应下标的链表后面，打拿个链表长度达到8以后，会自动将链表<strong>转化为红黑树</strong>，这样就能提升查询效率。</p><p><strong>ConcurrentHashMap的<code>put()</code>实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(); <span class="comment">//键值不能为空，基操</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());    <span class="comment">//计算键的hash值，用于确定在哈希表中的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//一会用来记录链表长度的，忽略</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;    <span class="comment">//无限循环，而且还是并发包中的类，盲猜一波CAS自旋锁</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();    <span class="comment">//如果数组（哈希表）为空肯定是要进行初始化的，然后再重新进下一轮循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;   <span class="comment">//如果哈希表该位置为null，直接CAS插入结点作为头结即可（注意这里会将f设置当前哈希表位置上的头结点）</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))  </span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// 如果CAS成功，直接break结束put方法，失败那就继续下一轮循环</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)   <span class="comment">//头结点哈希值为-1，这里只需要知道是因为正在扩容即可</span></span><br><span class="line">            tab = helpTransfer(tab, f);   <span class="comment">//帮助进行迁移，完事之后再来下一次循环</span></span><br><span class="line">        <span class="keyword">else</span> &#123;     <span class="comment">//特殊情况都完了，这里就该是正常情况了，</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;   <span class="comment">//在前面的循环中f肯定是被设定为了哈希表某个位置上的头结点，这里直接把它作为锁加锁了，防止同一时间其他线程也在操作哈希表中这个位置上的链表或是红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;    <span class="comment">//头结点的哈希值大于等于0说明是链表，下面就是针对链表的一些列操作</span></span><br><span class="line">                        ...实现细节略</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;   <span class="comment">//肯定不大于0，肯定也不是-1，还判断是不是TreeBin，所以不用猜了，肯定是红黑树，下面就是针对红黑树的情况进行操作</span></span><br><span class="line">                      <span class="comment">//在ConcurrentHashMap并不是直接存储的TreeNode，而是TreeBin</span></span><br><span class="line">                        ...实现细节略</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//根据链表长度决定是否要进化为红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);   <span class="comment">//注意这里只是可能会进化为红黑树，如果当前哈希表的长度小于64，它会优先考虑对哈希表进行扩容</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下就是：</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403111057872.png" alt="image-20230306172102878"></p><blockquote><p>讲师的图画的也太好！</p></blockquote><p><strong>ConcurrentHashMap的<code>get()</code>实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());   <span class="comment">//计算哈希值</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果头结点就是我们要找的，那直接返回值就行了</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//要么是正在扩容，要么就是红黑树，负数只有这两种情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">//确认无误，肯定在列表里，开找</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//没找到只能null了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，ConcurrentHashMap的put操作，实际上是对哈希表上的所有头结点元素分别加锁，理论上来说哈希表的长度很大程度上决定了ConcurrentHashMap在同一时间能够处理的线程数量，这也是为什么<code>treeifyBin()</code>会优先考虑为哈希表进行扩容的原因。显然，这种加锁方式比JDK7的分段锁机制性能更好。</p><p>get操作就是根据hash来找到对应的队列/红黑树，然后在里面找到对应的数据并且返回</p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>了我们常用的容器类之外，JUC还提供了各种各样的阻塞队列，用于不同的工作场景。</p><p>阻塞队列本身也是队列，但是它是适用于多线程环境下的，基于ReentrantLock实现的，它的接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Queue</span>&lt;E&gt; &#123;</span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队，如果队列已满，返回false否则返回true（非阻塞）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队，如果队列已满，阻塞线程直到能入队为止</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队，如果队列已满，阻塞线程直到能入队或超时、中断为止，入队成功返回true否则false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e, <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队，如果队列为空，阻塞线程直到能出队为止</span></span><br><span class="line">    E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队，如果队列为空，阻塞线程直到能出队超时、中断为止，出队成功正常返回，否则返回null</span></span><br><span class="line">    E <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回此队列理想情况下（在没有内存或资源限制的情况下）可以不阻塞地入队的数量，如果没有限制，则返回 Integer.MAX_VALUE</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">remainingCapacity</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//一次性从BlockingQueue中获取所有可用的数据对象（还可以指定获取数据的个数）</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">drainTo</span><span class="params">(Collection&lt;? <span class="built_in">super</span> E&gt; c)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">drainTo</span><span class="params">(Collection&lt;? <span class="built_in">super</span> E&gt; c, <span class="type">int</span> maxElements)</span>;</span><br></pre></td></tr></table></figure><p>比如现在有一个容量为3的阻塞队列，这个时候一个线程<code>put</code>向其添加了三个元素，第二个线程接着<code>put</code>向其添加三个元素，那么这个时候由于容量已满，会直接被阻塞，而这时第三个线程从队列中取走2个元素，线程二停止阻塞，先丢两个进去，还有一个还是进不去，所以说继续阻塞。</p><p><img src="https://s2.loli.net/2023/03/06/nRik6PHxY24Nlzr.png" alt="image-20230306172123711"></p><p>利用阻塞队列，我们可以轻松地实现消费者和生产者模式；</p><p>一共有三种常用的阻塞队列：</p><ul><li>ArrayBlockingQueue：有界带缓冲阻塞队列（就是队列是有容量限制的，装满了肯定是不能再装的，只能阻塞，数组实现）</li><li>SynchronousQueue：无缓冲阻塞队列（相当于没有容量的ArrayBlockingQueue，因此只有阻塞的情况）</li><li>LinkedBlockingQueue：无界带缓冲阻塞队列（没有容量限制，也可以限制容量，也会阻塞，链表实现）</li></ul><p>对SynchronousQueue，它没有容量，也就是说入队必须和出队同时出现，我们需要通过<code>transfer</code>方法来对生产者和消费者之间的数据来进行操作</p><p>如果只有消费者或者只有生产者都不能完成数据传递，所以会被阻塞；只有生产者和消费者全部到齐了才能进行消费</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403111120677.png" alt="image-20230306172203832"></p><p>LinkedBlockingQueue更牛逼了，它在SynchronousQueue的基础上加了容量，可以暂时让多个消费者/生产者在队列中多等着</p><p>了解一些其他的队列：</p><ul><li>PriorityBlockingQueue - 是一个支持优先级的阻塞队列，元素的获取顺序按优先级决定。</li><li>DelayQueue - 它能够实现延迟获取元素，同样支持优先级。</li></ul><p>DelayQueue可以实现代优先级的延迟出队，在这个情况下，就算优先级比较低的结点已经可以出队了，还是需要等待优先级更高的结点结束延迟出队后才能进行出队操作</p><hr><p>参考视频：<a href="https://www.bilibili.com/video/BV1JT4y1S7K8?spm_id_from=333.1245.0.0">Java JUC 并发编程 已完结（IDEA 2021版本）4K蓝光画质 玩转多线程</a></p><p>视频教程文档：<a href="https://www.itbaima.cn/document/5tr1sm4ho6ygpt9q">柏码-JUC笔记（二）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-JUC-笔记（2）&quot;&gt;&lt;a href=&quot;#Java-JUC-笔记（2）&quot; class=&quot;headerlink&quot; title=&quot;Java JUC 笔记（2）&quot;&gt;&lt;/a&gt;Java JUC 笔记（2）&lt;/h1&gt;&lt;h2 id=&quot;锁框架&quot;&gt;&lt;a href=&quot;#锁框</summary>
      
    
    
    
    <category term="知识笔记" scheme="https://hantoul.github.io/categories/%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JUC" scheme="https://hantoul.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>线程同步器AQS源码简析</title>
    <link href="https://hantoul.github.io/2024/03/07/2024-3-7-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%99%A8AQS%E7%AE%80%E6%9E%90/"/>
    <id>https://hantoul.github.io/2024/03/07/2024-3-7-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%99%A8AQS%E7%AE%80%E6%9E%90/</id>
    <published>2024-03-07T05:44:27.000Z</published>
    <updated>2024-03-07T06:10:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程同步器AQS"><a href="#线程同步器AQS" class="headerlink" title="线程同步器AQS"></a>线程同步器AQS</h3><h4 id="底层实现（以公平锁为例）"><a href="#底层实现（以公平锁为例）" class="headerlink" title="底层实现（以公平锁为例）"></a>底层实现（以公平锁为例）</h4><p>锁执行lock对象时，实际上是调用的Sync对象的方法，而Sync又继承自AbstractQueuedSynchronizer（队列同步器AQS）</p><p>既然是AQS中的Q是Queued，那么它自然需要维护一个队列</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403051659198.png" alt="image-20240305165944081"></p><p>对于每个<strong>节点</strong>，他有几个比较重要的字段和方法</p><ul><li>Prev和Next，显而易见是指向前序节点和后续节点的指针</li><li>status：表示节点不同的状态</li><li>thread：记录被封装到该节点内的线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每个处于等待状态的线程都可以是一个节点，并且每个节点是有很多状态的</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="comment">//每个节点都可以被分为独占模式节点或是共享模式节点，分别适用于独占锁和共享锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//等待状态，这里都定义好了</span></span><br><span class="line">   <span class="comment">//唯一一个大于0的状态，表示已失效，可能是由于超时或中断，此节点被取消。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//此节点后面的节点被挂起（进入等待状态）</span></span><br><span class="line">    <span class="comment">//注意这里是后面</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="comment">//在条件队列中的节点才是这个状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">  <span class="comment">//传播，一般用于共享锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;    <span class="comment">//等待状态值</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;   <span class="comment">//双向链表基操</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;   <span class="comment">//每一个线程都可以被封装进一个节点进入到等待队列</span></span><br><span class="line">  </span><br><span class="line">    Node nextWaiter;   <span class="comment">//在等待队列中表示模式，条件队列中作为下一个结点的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="type">int</span> waitStatus) &#123;</span><br><span class="line">        <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一开始的时候，<code>head</code>和<code>tail</code>都是<code>null</code>，<code>state</code>为默认值<code>0</code></p><p>继续看AQS初始化的其他内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接使用Unsafe类进行操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"><span class="comment">//记录类中属性的在内存中的偏移地址，方便Unsafe类直接操作内存进行赋值等（直接修改对应地址的内存）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> stateOffset;   <span class="comment">//这里对应的就是AQS类中的state成员字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> headOffset;    <span class="comment">//这里对应的就是AQS类中的head头结点成员字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> tailOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> waitStatusOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;   <span class="comment">//静态代码块，在类加载的时候就会自动获取偏移地址</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stateOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;state&quot;</span>));</span><br><span class="line">        headOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;head&quot;</span>));</span><br><span class="line">        tailOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;tail&quot;</span>));</span><br><span class="line">        waitStatusOffset = unsafe.objectFieldOffset</span><br><span class="line">            (Node.class.getDeclaredField(<span class="string">&quot;waitStatus&quot;</span>));</span><br><span class="line">        nextOffset = unsafe.objectFieldOffset</span><br><span class="line">            (Node.class.getDeclaredField(<span class="string">&quot;next&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过CAS操作来修改头结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetHead</span><span class="params">(Node update)</span> &#123;</span><br><span class="line">  <span class="comment">//调用的是Unsafe类的compareAndSwapObject方法，通过CAS算法比较对象并替换</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="built_in">this</span>, headOffset, <span class="literal">null</span>, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同上，省略部分代码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetWaitStatus</span><span class="params">(Node node, <span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetNext</span><span class="params">(Node node, Node expect, Node update)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>可以发现，队列同步器由于要使用到CAS算法，所以，直接使用了Unsafe工具类，Unsafe类中提供了CAS操作的方法（Java无法实现，底层由C++实现）所有对AQS类中成员字段的修改，都有对应的CAS操作封装。</p><p>CAS类提供了一些可重写的方法，同时也为独占式和非独占式锁都提供了对应的方法，已经一些已经写好的模板方法（他们会调用重写的方法）。</p><p>首先看一些可重写方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//独占式获取同步状态，查看同步状态是否和参数一致，如果返没有问题，那么会使用CAS操作设置同步状态并返回true</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//独占式释放同步状态</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//共享式获取同步状态，返回值大于0表示成功，否则失败</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//共享式释放同步状态</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否在独占模式下被当前线程占用（锁是否被当前线程持有）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这些需要重写的方法默认是直接抛出<code>UnsupportedOperationException</code>，也就是说根据不同的锁类型，我们需要去实现对应的方法，我们可以来看一下ReentrantLock（此类是全局独占式的）中的公平锁是如何借助AQS实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//加锁操作调用了模板方法acquire</span></span><br><span class="line">  <span class="comment">//为了防止各位绕晕，请时刻记住，lock方法一定是在某个线程下为了加锁而调用的，并且同一时间可能会有其他线程也在调用此方法</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先看看加锁操作干了什么事情，这里直接调用了AQS提供的模板方法<code>acquire()</code>，我们来看看它在AQS类中的实现细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span> <span class="comment">//这个是JEP 270添加的新注解，它会保护被注解的方法，通过添加一些额外的空间，防止在多线程运行的时候出现栈溢出，下同</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))   <span class="comment">//节点为独占模式Node.EXCLUSIVE</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的<code>tryAcquire()方法</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">  <span class="comment">//可重入独占锁的公平实现</span></span><br><span class="line">    <span class="meta">@ReservedStackAccess</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();   <span class="comment">//先获取当前线程的Thread对象</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();     <span class="comment">//获取当前AQS对象状态（独占模式下0为未占用，大于0表示已占用）</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;       <span class="comment">//如果是0，那就表示没有占用，现在我们的线程就要来尝试占用它</span></span><br><span class="line">            <span class="comment">//一直到这里为止还可能有多个线程在这一步</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;    <span class="comment">//等待队列是否不为空且当前线程没有拿到锁，其实就是看看当前线程有没有必要进行排队，如果没必要排队，就说明可以直接获取锁</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;   <span class="comment">//CAS设置状态，如果成功则说明成功拿到了这把锁，失败则说明可能这个时候其他线程在争抢，并且还比你先抢到</span></span><br><span class="line">                setExclusiveOwnerThread(current);    <span class="comment">//成功拿到锁，会将独占模式所有者线程设定为当前线程（这个方法是父类AbstractOwnableSynchronizer中的，就表示当前这把锁已经是这个线程的了）</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">//占用锁成功，返回true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;   <span class="comment">//如果不是0，那就表示被线程占用了，这个时候看看是不是自己占用的，如果是，由于是可重入锁，可以继续加锁</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;    <span class="comment">//多次加锁会将状态值进行增加，状态值就是加锁次数</span></span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)   <span class="comment">//加到int值溢出了？</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);   <span class="comment">//设置为新的加锁次数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//其他任何情况都是加锁失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403051727284.png" alt="image-20240305172706008"></p><p>在了解了公平锁的实现之后，是不是感觉有点恍然大悟的感觉，虽然整个过程非常复杂，但是只要理清思路，还是比较简单的。</p><p>接着我们看<code>addWaiter(Node.EXCLUSIVE)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 先尝试使用CAS直接入队，如果这个时候其他线程也在入队（就是不止一个线程在同一时间争抢这把锁）就进入enq()</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//此方法是CAS快速入队失败时调用</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">  <span class="comment">//自旋形式入队，可以看到这里是一个无限循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;  <span class="comment">//这种情况只能说明头结点和尾结点都还没初始化</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))   <span class="comment">//初始化头结点和尾结点</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;   <span class="comment">//只有CAS成功的情况下，才算入队成功，如果CAS失败，那说明其他线程同一时间也在入队，并且手速还比当前线程快，刚好走到CAS操作的时候，其他线程就先入队了，那么这个时候node.prev就不是我们预期的节点了，而是另一个线程新入队的节点，所以说得进下一次循环再来一次CAS，这种形式就是自旋</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403051741919.png" alt="img"></p><p>再看<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;   <span class="comment">//可以看到当此节点位于队首(node.prev == head)时，会再次调用tryAcquire方法获取锁，如果获取成功，会返回此过程中是否被中断的值</span></span><br><span class="line">                setHead(node);    <span class="comment">//新的头结点设置为当前结点</span></span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// 原有的头结点没有存在的意义了</span></span><br><span class="line">                failed = <span class="literal">false</span>;   <span class="comment">//没有失败</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;   <span class="comment">//直接返回等待过程中是否被中断</span></span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//依然没获取成功，</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;   <span class="comment">//将当前节点的前驱节点等待状态设置为SIGNAL，如果失败将直接开启下一轮循环，直到成功为止，如果成功接着往下</span></span><br><span class="line">                parkAndCheckInterrupt())   <span class="comment">//挂起线程进入等待状态，等待被唤醒，如果在等待状态下被中断，那么会返回true，直接将中断标志设为true，否则就是正常唤醒，继续自旋</span></span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);   <span class="comment">//通过unsafe类操作底层挂起线程（会直接进入阻塞状态）</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403051741616.png" alt="img"></p><p>上面是获取锁</p><p>释放锁其实也是类似的，在释放的过程中，需要唤醒队列中下一个结点中的线程，然后还要维护AQS中的状态（删除挂起的队列，减少等待队列中节点数量）</p><blockquote><p>还记得JVM的垃圾回收器吗，这里将结点设置为空，然后把指向他的指针知道别的地方，他稍后就会被垃圾回收器回收</p></blockquote><p>具体的代码也贴一下吧</p><blockquote><p><code>unlock()</code>方法是在AQS中实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line"> sync.release(<span class="number">1</span>);    <span class="comment">//直接调用了AQS中的release方法，参数为1表示解锁一次state值-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (tryRelease(arg)) &#123;   <span class="comment">//和tryAcquire一样，也得子类去重写，释放锁操作</span></span><br><span class="line">     <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;    <span class="comment">//释放锁成功后，获取新的头结点</span></span><br><span class="line">     <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)   <span class="comment">//如果新的头结点不为空并且不是刚刚建立的结点（初始状态下status为默认值0，而上面在进行了shouldParkAfterFailedAcquire之后，会被设定为SIGNAL状态，值为-1）</span></span><br><span class="line">         unparkSuccessor(h);   <span class="comment">//唤醒头节点下一个节点中的线程</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line"> <span class="comment">// 将等待状态waitStatus设置为初始值0</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line"> <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">     compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//获取下一个结点</span></span><br><span class="line"> <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line"> <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;   <span class="comment">//如果下一个结点为空或是等待状态是已取消，那肯定是不能通知unpark的，这时就要遍历所有节点再另外找一个符合unpark要求的节点了</span></span><br><span class="line">     s = <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)   <span class="comment">//这里是从队尾向前，因为enq()方法中的t.next = node是在CAS之后进行的，而 node.prev = t 是CAS之前进行的，所以从后往前一定能够保证遍历所有节点</span></span><br><span class="line">         <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">             s = t;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (s != <span class="literal">null</span>)   <span class="comment">//要是找到了，就直接unpark，要是还是没找到，那就算了</span></span><br><span class="line">     LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们来看看<code>tryRelease()</code>方法是怎么实现的，具体实现在Sync中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line"> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;   <span class="comment">//先计算本次解锁之后的状态值</span></span><br><span class="line"> <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())   <span class="comment">//因为是独占锁，那肯定这把锁得是当前线程持有才行</span></span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();   <span class="comment">//否则直接抛异常</span></span><br><span class="line"> <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"> <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;  <span class="comment">//如果解锁之后的值为0，表示已经完全释放此锁</span></span><br><span class="line">     free = <span class="literal">true</span>;</span><br><span class="line">     setExclusiveOwnerThread(<span class="literal">null</span>);  <span class="comment">//将独占锁持有线程设置为null</span></span><br><span class="line"> &#125;</span><br><span class="line"> setState(c);   <span class="comment">//状态值设定为c</span></span><br><span class="line"> <span class="keyword">return</span> free;  <span class="comment">//如果不是0表示此锁还没完全释放，返回false，是0就返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>这样就大概讲完了可重入锁的公平锁实现，实际上也不是无法理解的（迫真</p><p>下面是讲师总结的流程图</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403051742702.png" alt="image-20230306171428206"></p><p>这是我自己总结的</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403052017121.png" alt="img"></p><h4 id="公平锁真的公平吗？"><a href="#公平锁真的公平吗？" class="headerlink" title="公平锁真的公平吗？"></a>公平锁真的公平吗？</h4><p>在并发的情况下，公平锁是有概率变得不公平的</p><p>对于每个需要尝试获取锁的进程，他们都会先执行tryAcquire()来尝试获取锁，在尝试获取锁的过程中会先判断在队列中是否有节点处于等待队列，然后一旦发现没有，就会执行CAP操作</p><p>现在假设有线程1，线程2和线程3；线程1已经拿到锁了，这时线程2开始尝试获取锁，它发现虽然等待队列是空的，但是CAS操作失败，显然有线程在用锁，这时他开始准备排队了；</p><p>现在，突然线程3也开始尝试获取锁，恰巧在这时线程1释放锁了，线程3说：“消息队列没人在排队，CAS也没人在用，那我就不客气了”，于是线程3顺利地拿到了锁，实现了插队的目的。线程2：“我转个身怎么前面大哥换人了？”</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403052034838.png" alt="image-20240305203430604"></p><p>虽然概率很低，但高并发的情况也不是遇不见这样离谱的情况。</p><p>所以，严格来讲，公平锁只有在等待队列非空的时候才是公平的，就算是公平，也不是按照发请求的先后的公平，而是按照进入等待队列的时间的公平。</p><h4 id="Condition实现原理"><a href="#Condition实现原理" class="headerlink" title="Condition实现原理"></a>Condition实现原理</h4><p>之前我们看了Condition，了解了它实际上就是替代传统对象实现wait/notify操作（在Condition中是await/signal操作）的，并且同一把锁可以创建多个Condition对象，我们现在对Condition对象进行解析</p><p>在AQS中，Condition类有一个实现类ConditionObject，其同样使用链表实现了条件队列</p><blockquote><p>这里的条件队列能允许线程在某些条件不满足的情况下先进入等待状态，并且等待被唤醒；在某个对象进入调用wait()后会被放入条件队列，等待notify()唤醒以争夺锁</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1173984872572414699L</span>;</span><br><span class="line">    <span class="comment">/** 条件队列的头结点 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">/** 条件队列的尾结点 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>这里条件队列直接借用了AQS的Node类，但是使用的是Node类中的nextWaiter字段来连接节点，并且Node的状态设置为CONDITION（处于条件队列中）</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403071305298.png" alt="image-20240307130533174"></p><p>当一个线程调用await()方法时，会进入等待状态（进入<strong>条件</strong>队列），直到其他线程使用signal()方法将其唤醒（进入AQS的<strong>等待</strong>队列）</p><p>下面将会研究await()方法的实现，这里先明确这个方法的目标</p><ul><li>仅有已经持有锁的方法才能够调用await</li><li>当调用await方法后，无论加了多少次锁，都会直接释放锁</li><li>只有其他线程调用signal或者是被中断时，才会唤醒等待中的线程</li><li>被唤醒的线程依然需要等待其他线程释放锁，并且等真正抢到锁以后才会继续执行，并且会恢复到await()时的状态（和await时一样的锁层数）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();   <span class="comment">//如果在调用await之前就被添加了中断标记，那么会直接抛出中断异常</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();    <span class="comment">//为当前线程创建一个新的节点，并将其加入到条件队列中</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);    <span class="comment">//完全释放当前线程持有的锁，并且保存一下state值，因为唤醒之后还得恢复</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;     <span class="comment">//用于保存中断状态</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;   <span class="comment">//循环判断是否位于同步队列中，如果等待状态下的线程被其他线程唤醒，那么会正常进入到AQS的等待队列中（之后我们会讲）</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);   <span class="comment">//如果依然处于等待状态，那么继续挂起</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)   <span class="comment">//看看等待的时候是不是被中断了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//出了循环之后，那线程肯定是已经醒了，这时就差拿到锁就可以恢复运行了</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)  <span class="comment">//直接开始acquireQueued尝试拿锁（之前已经讲过了）从这里开始基本就和一个线程去抢锁是一样的了</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">  <span class="comment">//已经拿到锁了，基本可以开始继续运行了，这里再进行一下后期清理工作</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) </span><br><span class="line">        unlinkCancelledWaiters();  <span class="comment">//将等待队列中，不是Node.CONDITION状态的节点移除</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)   <span class="comment">//依然是响应中断</span></span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">  <span class="comment">//OK，接着该干嘛干嘛</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简而言之</p><ol><li>首先判断当前调用的线程是否处于中断的状态，若已在中断状态了，那么还谈什么等待状态呢，直接抛异常</li><li>在条件队列中加入一个新的节点，并保存当前线程的各种状态</li><li><strong>循环判断</strong>当前线程是否还处于条件队列中，并且在循环里监视有没有在等待时被中断（被中断了一样会醒）</li><li>当跳出循环，表示当前线程一定是醒了，现在只需要拿到锁就可以开始运行了</li><li>在拿到锁后进行<u>收尾工作</u>，打扫一下等待队列，再回头看一眼有没有被中断，之后就正式开始执行自己的任务了</li></ol><p>实际上<code>await()</code>方法比较中规中矩，大部分操作也在我们的意料之中，那么我们接着来看<code>signal()</code>方法是如何实现的，同样的，为了防止各位绕晕，先明确signal的目标：</p><ul><li>只有持有锁的线程才能唤醒<strong>锁所属</strong>（等着这把锁）Condition的的线程</li><li>优先唤醒条件队列队首，若出现问题，就按顺序往下找，直到找到可以唤醒的</li><li>唤醒的本质是将线程从条件队列中移出至等待队列</li><li>拿到锁之后，线程才能恢复运行</li></ul><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403071320891.png" alt="image-20230306171620786"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())    <span class="comment">//先看看当前线程是不是持有锁的状态</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();   <span class="comment">//不是？那你不配唤醒别人</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;    <span class="comment">//获取条件队列的第一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>)    <span class="comment">//如果队列不为空，获取到了，那么就可以开始唤醒操作</span></span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)   <span class="comment">//如果当前节点在本轮循环没有后继节点了，条件队列就为空了</span></span><br><span class="line">            lastWaiter = <span class="literal">null</span>;   <span class="comment">//所以这里相当于是直接清空</span></span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;   <span class="comment">//将给定节点的下一个结点设置为null，因为当前结点马上就会离开条件队列了</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;   <span class="comment">//接着往下看</span></span><br><span class="line">             (first = firstWaiter) != <span class="literal">null</span>);   <span class="comment">//能走到这里只能说明给定节点被设定为了取消状态，那就继续看下一个结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果这里CAS失败，那有可能此节点被设定为了取消状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CAS成功之后，结点的等待状态就变成了默认值0，接着通过enq方法直接将节点丢进AQS的等待队列中，相当于唤醒并且可以等待获取锁了</span></span><br><span class="line">  <span class="comment">//这里enq方法返回的是加入之后等待队列队尾的前驱节点，就是原来的tail</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;   <span class="comment">//保存前驱结点的等待状态</span></span><br><span class="line">  <span class="comment">//如果上一个节点的状态为取消, 或者尝试设置上一个节点的状态为SIGNAL失败（可能是在ws&gt;0判断完之后马上变成了取消状态，导致CAS失败）</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);  <span class="comment">//直接唤醒线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实思路也不是很复杂， 跟之前消费等待队列的思路大差不差</p><ul><li><p>先判断调用signal的线程的状态，是不是有锁，没锁你唤醒个锤子</p></li><li><p>若持有锁，就从条件队列取队首，并进行消费，不断循环判断该节点是否为取消状态，若是则继续看下一个节点；若发现条件队列都空了，就要进行一些收尾工作</p></li><li><p>消费等待队列结点的过程：</p><ol><li>先进行CAS判断，若成功了表明已经有资格进入等待队列了</li><li>将线程加入等待队列，并且获取前驱节点的等待状态</li><li>若上一个节点的状态为取消（上一个节点都被取消了还管他干啥，直接开抢）, 或者尝试设置上一个节点的状态为SIGNAL时失败（想把我挂起？没门，开抢！）</li></ol><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403071333699.png" alt="image-20240307133318626"></p></li></ul><p>其实最让人不理解的就是倒数第二行，明明上面都正常进入到AQS等待队列了，应该是可以开始走正常流程了，那么这里为什么还要提前来一次unpark呢？</p><p>这里其实是为了进行优化而编写，直接unpark会有两种情况：</p><ul><li>如果插入结点前，AQS等待队列的队尾节点就已经被取消，则满足wc &gt; 0</li><li>如果插入node后，AQS内部等待队列的队尾节点已经稳定，满足tail.waitStatus == 0，但在执行ws &gt;0之后 !compareAndSetWaitStatus(p, ws,Node.SIGNAL)之前被取消，则CAS也会失败，满足compareAndSetWaitStatus(p, ws,Node.SIGNAL) == false</li></ul><p>如果这里被提前unpark，那么在<code>await()</code>方法中将可以被直接唤醒，并跳出while循环，直接开始争抢锁，因为前一个等待结点是被取消的状态，没有必要再等它了。</p><p>大致流程如下</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403071333363.png" alt="image-20230306171643082"></p><p>其实不难理解吧。。就是概念比较多，讲师带着顺一遍其实基本能跑通思路</p><hr><p>参考视频：<a href="https://www.bilibili.com/video/BV1JT4y1S7K8?spm_id_from=333.1245.0.0">Java JUC 并发编程 已完结（IDEA 2021版本）4K蓝光画质 玩转多线程</a></p><p>视频教程文档：<a href="https://www.itbaima.cn/document/5tr1sm4ho6ygpt9q">柏码-JUC笔记（二）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;线程同步器AQS&quot;&gt;&lt;a href=&quot;#线程同步器AQS&quot; class=&quot;headerlink&quot; title=&quot;线程同步器AQS&quot;&gt;&lt;/a&gt;线程同步器AQS&lt;/h3&gt;&lt;h4 id=&quot;底层实现（以公平锁为例）&quot;&gt;&lt;a href=&quot;#底层实现（以公平锁为例）&quot; cla</summary>
      
    
    
    
    <category term="知识笔记" scheme="https://hantoul.github.io/categories/%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JUC" scheme="https://hantoul.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC笔记（一）</title>
    <link href="https://hantoul.github.io/2024/03/02/2024-3-2-JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://hantoul.github.io/2024/03/02/2024-3-2-JUC%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2024-03-02T06:46:50.000Z</published>
    <updated>2024-03-02T06:46:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-JUC-笔记（1）"><a href="#Java-JUC-笔记（1）" class="headerlink" title="Java JUC 笔记（1）"></a>Java JUC 笔记（1）</h1><h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><p>使用synchronized加锁时，一定是和某个对象关联的； </p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403021445234.png" alt="image-20230306170923799"></p><p>当带锁的方法反编译成字节码后，我们会看到有一个monitor enter指令和monitor exit指令，他们就分别对应加锁和释放锁； 每个对象都有一个monitor监视器与之对应的是，而monitor enter正是要获取该对象监视器的所有权，一旦某个对象的监视器被获取，其他对象就无法得到（唯一）</p><p>仔细看字节码中，其实有两个monitor exit; 如果程序是正常退出，会直接从第一个exit跳转回return， 若不是正常退出，就会从exit2出去，执行10~14行的异常处理程序，通过athrow抛出异常</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403021104547.png" alt="image-20240302110324708"></p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>在JDK6之前，synchronized被称为重量级锁，monitor依赖于底层操作系统的lock来实现，而虚拟机上的线程是<strong>映射</strong>到原生系统的线程上，切换成本高。</p><p>对于每个对象，都有一个monitor与之关联，在Java虚拟机（HotSpot）中，monitor是由ObjectMonitor实现的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ObjectMonitor</span>() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">//记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>;</span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个等待锁的线程都会被封装成ObjectWaiter对象，进入到如下机制：</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403021114737.png" alt="image-20230306171005840"></p><p>ObjectWaiter先进入EntrySet等待，获取到对象的监视器后进入The Owner区，若线程调用wait方法，就释放监视器，并进入WaitSet等待唤醒。</p><p>在JDK1.4.2时引入了自旋锁（JDK6后默认开启），它会让处于等待状态的线程不断地<strong>循环</strong>尝试获取锁。这种锁在等待时间不长的情况下表现很好，但是等待时间过长，就会浪费处理器资源；因此，自旋锁的循环次数一般是有限的（JDK6以后自旋次数自适应变化），超过次数以后，就会采用重量级锁机制。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁的目标是在竞争的情况下减少重量级锁产生的性能消耗。</p><p>在开始执行同步代码块前，先检查对象的MarkWord，查看锁对象是否被占用，若未被占用，则会在当前线程的帧栈中开一个名为<u>Lock Record的空间，用于复制并存储对象的Mark Word信息</u>。</p><p>接着虚拟机使用CAS操作将Mark Word更新为当前轻量级锁的状态（数据结构变为指向Lock Record的指针，指向的是当前的栈帧）。</p><blockquote><p>CAS在之前的Redis秒杀的笔记中有体积到</p><p><a href="https://hantoul.github.io/2024/02/21/2024-2-21-Redis-%E7%A7%92%E6%9D%80%E7%AC%94%E8%AE%B01-copy/">Redis - 秒杀笔记 1</a></p></blockquote><p>根据CAS操作的结果来判定是否有线程占用当前同步代码块。若发现有线程在占用，则只好将锁膨胀为重量级锁，按照重量级锁来进行操作（锁的膨胀不可逆）</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403021216110.png" alt="image-20230306171031953"></p><p>更新锁记录的过程就是将线程的本地的栈帧记录和对象的MarkWord进行比较，若不存在或指向自身，说明可以直接获取锁；若不同，说明有其他线程在占用锁，执行膨胀操作。解锁过程仍然执行CAS，若对象的MarkWord还指向自身帧栈记录，则将他们交换。若指向其他线程帧栈，说明有其他线程也曾尝试获取过锁，这需要执行唤醒操作。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁相比于轻量级锁，消除了CAS操作；其专门为单个线程服务，当某个线程第一次获取锁，若后续都没有其他线程来获取该锁，那么持有该所的线程不需要进行同步操作。</p><p>若有其他锁来请求获取锁，那么偏向锁就会根据当前状态，决定是否要将当前锁恢复到未锁定或膨胀为轻量级锁。</p><p>可以添加<code>-XX:+UseBiased</code>参数来开启偏向锁</p><blockquote><p>值得注意的是，如果对象通过调用<code>hashCode()</code>方法计算过对象的一致性哈希值，那么它是不支持偏向锁的，会直接进入到轻量级锁状态，因为Hash是需要被保存的，而偏向锁的Mark Word数据结构，无法保存Hash值；如果对象已经是偏向锁状态，再去调用<code>hashCode()</code>方法，那么会直接将锁升级为重量级锁，并将哈希值存放在<code>monitor</code>（有预留位置保存）中。</p></blockquote><p><strong>综上，最终的锁等级为：未锁定 &lt; 偏向锁 &lt; 轻量级锁 &lt; 重量级锁</strong></p><h3 id="锁消除和锁粗化"><a href="#锁消除和锁粗化" class="headerlink" title="锁消除和锁粗化"></a>锁消除和锁粗化</h3><p>锁消除和锁粗化都是在运行时的一些优化方案，比如我们某段代码虽然加了锁，但是在运行时根本不可能出现各个线程之间资源争夺的情况，这种情况下，完全不需要任何加锁机制，所以锁会被消除。锁粗化则是我们代码中频繁地出现互斥同步操作，比如在一个循环内部加锁，这样明显是非常消耗性能的，所以虚拟机一旦检测到这种操作，会将整个同步范围进行扩展。</p><hr><h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403021322551.png" alt="image-20230306171115671"></p><p>JVM的内存模型规定如下</p><ul><li><p>所有变量全都存储在主内存（这里包括下面提到的内存都指的是可能会出现竞争的变量，不包括局部变量）</p></li><li><p>每个线程都有自己的工作内存，线程对变量的所有操作，都需要通过工作内存，然后通过工作内存和主内存之间的save和load操作实现操作</p></li><li>不同线程之间的工作内存互相隔离，线程之间的内容传递必须经过主内存完成</li></ul><p>之前的JVM笔记中提到一个案例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开两个线程对变量i进行自增操作，每个线程自增一万次</span><br><span class="line">最后执行的结果却不是2万</span><br><span class="line">这是因为这两个线程在操作工作内存与主内存的交互间出现了穿插，造成了数据的覆写，所以就会产生错误的结果</span><br></pre></td></tr></table></figure><p>在之前我们就可以通过synchronized关键字添加同步代码块轻松解决，在后面会讲解通过原子类方法解决这类问题的方案</p><h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>在程序编译或执行时，为了优化程序执行效率，编译器或处理器通常会对指令进行重排序</p><ul><li>编译器重排序：Java编译器通过对Java代码的解析，根据优化规则对代码进行重排序</li><li>机器指令级的重排序：现代处理器能自主判断和变更机器指令的执行顺序</li></ul><p>虽然但是，多线程环境下的指令重排序可能会导致一些问题。</p><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p>先介绍三个词</p><ul><li>原子性：要么全执行，要么全不执行</li><li>可见性：当多个线程访问同一个变量，一旦一个线程修改了改变了，其他线程立马就能看见修改后的值</li><li>有序性：程序按照代码先后顺序执行</li></ul><p>volatile关键字可以使其修饰的变量具有<strong>可见性</strong>，但是其<u><strong>无法保证原子性</strong></u></p><p>比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (a == <span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程结束！&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;正在修改a的值...&quot;</span>);</span><br><span class="line">        a = <span class="number">1</span>;   <span class="comment">//很明显，按照我们的逻辑来说，a的值被修改那么另一个线程将不再循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样直接执行肯定会让while无限循环，如果我们使用synchronized加一把锁，显然是可以解决问题的，但是这样造成了大量的开销，这是就可以引入volatile关键字了</p><p><code>private static volatile int a = 0;</code></p><p>由于volatile关键字无法保证原子性；对这个案例做分析，一个简单的自增操作是由很多个指令组合而成的（写入，修改，写回），当线程a完成写回操作后，线程b正在执行写回操作，这是已经无法刹住车了，就算知道了写回变量的最新的值了，也无法进行修正了</p><p>这种情况会使用后面的<strong>原子类</strong>来解决这类问题</p><p>volatile关键字会<strong>禁止指令重排</strong>，这样就会保证多线程状态下不出岔子；</p><p>对于volatile关键字修饰的变量，在编译时会在指令序列中插入<strong>内存屏障</strong>来禁止特定类型的处理器重排序</p><blockquote><p>内存屏障作用</p><ul><li>保证特定操作顺序</li><li>保证某些变量的内存<u>可见性</u></li></ul><div class="table-container"><table><thead><tr><th>屏障类型</th><th>指令示例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad</td><td>Load1;LoadLoad;Load2</td><td>保证Load1的读取操作在Load2及后续读取操作之前执行</td></tr><tr><td>StoreStore</td><td>Store1;StoreStore;Store2</td><td>在Store2及其后的写操作执行前，保证Store1的写操作已刷新到主内存</td></tr><tr><td>LoadStore</td><td>Load1;LoadStore;Store2</td><td>在Store2及其后的写操作执行前，保证Load1的读操作已读取结束</td></tr><tr><td>StoreLoad</td><td>Store1;StoreLoad;Load2</td><td>保证load1的写操作已刷新到主内存之后，load2及其后的读操作才能执行</td></tr></tbody></table></div></blockquote><h3 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h3><p>JMM提出了<code>happens-before</code>（先行发生）原则，定义一些禁止编译优化的场景，来做一些保证，只要我们是按照原则进行编程，那么就能够保持并发编程的正确性。具体如下：</p><ul><li><strong>程序次序规则：</strong> 同一个线程中，按照程序的顺序，前面的操作happens-before后续的任何操作。<ul><li>同一个线程内，代码的执行结果是有序的。其实就是，可能会发生指令重排，但是保证代码的执行结果一定是和按照顺序执行得到的一致，程序前面对某一个变量的修改一定对后续操作可见的，不可能会出现前面才把a修改为1，接着读a居然是修改前的结果，这也是程序运行最基本的要求。</li></ul></li><li><strong>监视器锁规则：</strong> 对一个锁的解锁操作，happens-before后续对这个锁的加锁操作。<ul><li>就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果。比如前一个线程将变量<code>x</code>的值修改为了<code>12</code>并解锁，之后另一个线程拿到了这把锁，对之前线程的操作是可见的，可以得到<code>x</code>是前一个线程修改后的结果<code>12</code>（所以synchronized是有happens-before规则的）</li></ul></li><li><strong>volatile变量规则：</strong> 对一个volatile变量的写操作happens-before后续对这个变量的读操作。<ul><li>就是如果一个线程先去写一个<code>volatile</code>变量，紧接着另一个线程去读这个变量，那么这个写操作的结果一定对读的这个变量的线程可见。</li></ul></li><li><strong>线程启动规则：</strong> 主线程A启动线程B，线程B中可以看到主线程启动B之前的操作。<ul><li>在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。</li></ul></li><li><strong>线程加入规则：</strong> 如果线程A执行操作<code>join()</code>线程B并成功返回，那么线程B中的任意操作happens-before线程A<code>join()</code>操作成功返回。</li><li><strong>传递性规则：</strong> 如果A happens-before B，B happens-before C，那么A happens-before C。</li></ul><hr><p>本文参考白马讲师写的文档按照自己的理解进行部分修改，推荐大家去B站加入讲师的知识之海~</p><p>参考视频：<a href="https://www.bilibili.com/video/BV1JT4y1S7K8?spm_id_from=333.1245.0.0">Java JUC 并发编程 已完结（IDEA 2021版本）4K蓝光画质 玩转多线程</a></p><p>参考视频教程文档：<a href="https://www.itbaima.cn/document/asncyye9ya18gfar">柏码-JUC笔记（一）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-JUC-笔记（1）&quot;&gt;&lt;a href=&quot;#Java-JUC-笔记（1）&quot; class=&quot;headerlink&quot; title=&quot;Java JUC 笔记（1）&quot;&gt;&lt;/a&gt;Java JUC 笔记（1）&lt;/h1&gt;&lt;h2 id=&quot;锁机制&quot;&gt;&lt;a href=&quot;#锁机</summary>
      
    
    
    
    <category term="知识笔记" scheme="https://hantoul.github.io/categories/%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JUC" scheme="https://hantoul.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Redis高级(2) - 多级缓存</title>
    <link href="https://hantoul.github.io/2024/03/01/2024-3-1-Redis%E9%AB%98%E7%BA%A7-2-%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    <id>https://hantoul.github.io/2024/03/01/2024-3-1-Redis%E9%AB%98%E7%BA%A7-2-%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/</id>
    <published>2024-03-01T02:45:32.000Z</published>
    <updated>2024-03-01T02:45:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis高级-2-—-多级缓存"><a href="#Redis高级-2-—-多级缓存" class="headerlink" title="Redis高级(2)  —- 多级缓存"></a>Redis高级(2)  —- 多级缓存</h1><p>传统的缓存的请求要经过Tomcat,性能收到Tomcat限制; 同时若Redis中不存在所需要的数据,还要去MySql中进行进一步的查找操作,也比较耗时; 设置后就可以采用多级缓存方案</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402281559039.png" alt="image-20240228155655591"></p><h2 id="JVM进程缓存"><a href="#JVM进程缓存" class="headerlink" title="JVM进程缓存"></a>JVM进程缓存</h2><p>我们把缓存分为两类：</p><ul><li>分布式缓存，例如Redis：<ul><li>优点：存储容量更大、可靠性更好、可以在集群间共享</li><li>缺点：访问缓存有网络开销</li><li>场景：缓存数据量较大、可靠性要求较高、需要在集群间共享</li></ul></li><li>进程本地缓存，例如HashMap、GuavaCache：<ul><li>优点：读取本地内存，没有网络开销，速度更快</li><li>缺点：存储容量有限、可靠性较低、无法共享</li><li>场景：性能要求较高，缓存数据量较小</li></ul></li></ul><h3 id="Caffeine"><a href="#Caffeine" class="headerlink" title="Caffeine"></a>Caffeine</h3><p><u>Caffeine</u>是一个基于Java8开发的，提供了近乎最佳命中率的高性能的本地缓存库。目前Spring内部的缓存使用的就是Caffeine。</p><p>它的使用也很简单</p><p>缓存使用的基本API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBasicOps</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 构建cache对象</span></span><br><span class="line">    Cache&lt;String, String&gt; cache = Caffeine.newBuilder().build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存数据</span></span><br><span class="line">    cache.put(<span class="string">&quot;gf&quot;</span>, <span class="string">&quot;迪丽热巴&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">gf</span> <span class="operator">=</span> cache.getIfPresent(<span class="string">&quot;gf&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;gf = &quot;</span> + gf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取数据，包含两个参数：</span></span><br><span class="line">    <span class="comment">// 参数一：缓存的key</span></span><br><span class="line">    <span class="comment">// 参数二：Lambda表达式，表达式参数就是缓存的key，方法体是查询数据库的逻辑</span></span><br><span class="line">    <span class="comment">// 优先根据key查询JVM缓存，如果未命中，则执行参数二的Lambda表达式</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">defaultGF</span> <span class="operator">=</span> cache.get(<span class="string">&quot;defaultGF&quot;</span>, key -&gt; &#123;</span><br><span class="line">        <span class="comment">// 根据key去数据库查询数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;柳岩&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;defaultGF = &quot;</span> + defaultGF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在创建它时-可以配置他的最大缓存数量-初始缓存数量-缓存过期时间等"><a href="#在创建它时-可以配置他的最大缓存数量-初始缓存数量-缓存过期时间等" class="headerlink" title="在创建它时,可以配置他的最大缓存数量,初始缓存数量,缓存过期时间等"></a>在创建它时,可以配置他的最大缓存数量,初始缓存数量,缓存过期时间等</h2><h2 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h2><p>下面是目标要实现的缓存架构</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402291407246.png" alt="yeVDlwtfMx"></p><h3 id="OpenResty"><a href="#OpenResty" class="headerlink" title="OpenResty"></a>OpenResty</h3><p>我们可以通过先OpenResty借助nginx实现反向代理</p><ul><li>windows上的nginx用来做反向代理,将前端查询的ajax请求代理到centos上的OpenResty集群</li><li>OpenResty集群用来编写多级缓存的业务</li></ul><p>具体配置过程省略</p><ul><li><p>网页访问请求首先通过nginx转发到centos服务器上的nginx端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">upstream nginx-cluster&#123;</span><br><span class="line">    server 192.168.159.137:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>centos服务器上的nginx在接收到转发过来的请求后,调用OpenResty进行根据编写的lua脚本进行进一步的处理并返回请求的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#lua 模块</span><br><span class="line">lua_package_path &quot;/usr/local/openresty/lualib/?.lua;;&quot;;</span><br><span class="line">#c模块     </span><br><span class="line">lua_package_cpath &quot;/usr/local/openresty/lualib/?.so;;&quot;;  ...</span><br><span class="line">server&#123;</span><br><span class="line">   location /api/item &#123;</span><br><span class="line">           #默认响应类型</span><br><span class="line">           default_type application/json;</span><br><span class="line">           #响应结果</span><br><span class="line">           content_by_lua_file lua/item.lua;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h4 id="获取参数的API"><a href="#获取参数的API" class="headerlink" title="获取参数的API"></a>获取参数的API</h4><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402291415576.png" alt="image-20210821101433528"></p><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><p>通过上面的参数我们获取到了反向代理后传入的API,这里先来实现从OpenResty到Tomcat的请求查询</p><p>首先将打入的 请求按照标记拦截,进行响应处理后转发到主机的服务端口</p><p>先配置一个方法,用来发送http请求</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 封装函数，发送http请求，并解析响应</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_http</span><span class="params">(path, params)</span></span></span><br><span class="line">    <span class="keyword">local</span> resp = ngx.location.capture(<span class="built_in">path</span>,&#123;</span><br><span class="line">        method = ngx.HTTP_GET,</span><br><span class="line">        args = params,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 记录错误信息，返回404</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;http请求查询失败, path: &quot;</span>, <span class="built_in">path</span> , <span class="string">&quot;, args: &quot;</span>, args)</span><br><span class="line">        ngx.<span class="built_in">exit</span>(<span class="number">404</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> resp.body</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 将方法导出</span></span><br><span class="line"><span class="keyword">local</span> _M = &#123;  </span><br><span class="line">    read_http = read_http</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure><p>然后编写查询的lua脚本,分别查询商品数据和库存数据,然后进行合并,最后返回查询结果的json数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line">worker_processes  1;</span><br><span class="line">error_log  logs/error.log;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#lua 模块</span><br><span class="line">lua_package_path &quot;/usr/local/openresty/lualib/?.lua;;&quot;;</span><br><span class="line">#c模块     </span><br><span class="line">lua_package_cpath &quot;/usr/local/openresty/lualib/?.so;;&quot;;  </span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8081;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        </span><br><span class="line">        location /item &#123;</span><br><span class="line">        proxy_pass http://192.168.159.1:8081;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        location ~ /api/item/(\d+) &#123;</span><br><span class="line">            #默认响应类型</span><br><span class="line">            default_type application/json;</span><br><span class="line">            #响应结果</span><br><span class="line">            content_by_lua_file lua/item.lua;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里花了好长时间排查BUG,因为一直不返回结果; 又不知道这里怎么debug,最后是一步一步排查,做了一个下午才成功返回数据的</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>由于集群进程之间的缓存是不共享的, 而Tomcat的默认负载均4衡采用轮询的方式, 这样就会造成缓存的失效;<br>所以这里就引入一个hash的的负载均衡 <code>hash $request_uri</code> ,对于某个商品, 就去特定的服务器进行查询</p><h4 id="Redis缓存预热"><a href="#Redis缓存预热" class="headerlink" title="Redis缓存预热"></a>Redis缓存预热</h4><p><strong>冷启动</strong>: 服务刚刚启动时,由于缓存还没有载入,在初次访问数据时会访问数据库,可能造成数据库压力过大</p><p><strong>缓存预热</strong>:在实际开发中我们可以统计出热点数据, 在项目启动时将数据预载入Redis</p><p>这里直接在虚拟机上安装redis,在对应服务启动时,先从mysql中拉取对应的数据列表,再遍历列表将数据存入Redis即可</p><p>最后修改item.lua的逻辑即可实现多级缓存</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入common函数库</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&#x27;common&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="keyword">local</span> read_redis = common.read_redis</span><br><span class="line"><span class="comment">-- 导入cjson库</span></span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">&#x27;cjson&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 封装查询函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read_data</span><span class="params">(key, path, params)</span></span></span><br><span class="line">    <span class="comment">-- 查询本地缓存</span></span><br><span class="line">    <span class="keyword">local</span> val = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, key)</span><br><span class="line">    <span class="comment">-- 判断查询结果</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;redis查询失败，尝试查询http， key: &quot;</span>, key)</span><br><span class="line">        <span class="comment">-- redis查询失败，去查询http</span></span><br><span class="line">        val = read_http(<span class="built_in">path</span>, params)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取路径参数</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询商品信息</span></span><br><span class="line"><span class="keyword">local</span> itemJSON = read_data(<span class="string">&quot;item:id:&quot;</span> .. id,  <span class="string">&quot;/item/&quot;</span> .. id, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">-- 查询库存信息</span></span><br><span class="line"><span class="keyword">local</span> stockJSON = read_data(<span class="string">&quot;item:stock:id:&quot;</span> .. id, <span class="string">&quot;/item/stock/&quot;</span> .. id, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- JSON转化为lua的table</span></span><br><span class="line"><span class="keyword">local</span> item = cjson.decode(itemJSON)</span><br><span class="line"><span class="keyword">local</span> stock = cjson.decode(stockJSON)</span><br><span class="line"><span class="comment">-- 组合数据</span></span><br><span class="line">item.stock = stock.stock</span><br><span class="line">item.sold = stock.sold</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 把item序列化为json 返回结果</span></span><br><span class="line">ngx.say(cjson.encode(item))</span><br></pre></td></tr></table></figure><h3 id="nginx本地缓存"><a href="#nginx本地缓存" class="headerlink" title="nginx本地缓存"></a>nginx本地缓存</h3><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403011025991.png" alt="image-20210821114742950"></p><p>OpenResty为Nginx提供了<strong>shard dict</strong>的功能，可以在nginx的多个worker之间共享数据，实现缓存功能。</p><p>1）开启共享字典，在nginx.conf的http下添加配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 共享字典，也就是本地缓存，名称叫做：item_cache，大小150m</span></span><br><span class="line"><span class="attribute">lua_shared_dict</span> item_cache <span class="number">150m</span>; </span><br></pre></td></tr></table></figure><p>2）操作共享字典：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取本地缓存对象</span></span><br><span class="line"><span class="keyword">local</span> item_cache = ngx.shared.item_cache</span><br><span class="line"><span class="comment">-- 存储, 指定key、value、过期时间，单位s，默认为0代表永不过期</span></span><br><span class="line">item_cache:set(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">-- 读取</span></span><br><span class="line"><span class="keyword">local</span> val = item_cache:get(<span class="string">&#x27;key&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="实现本地缓存查询"><a href="#实现本地缓存查询" class="headerlink" title="实现本地缓存查询"></a>实现本地缓存查询</h3><p>1）修改<code>/usr/local/openresty/lua/item.lua</code>文件，修改read_data查询函数，添加本地缓存逻辑：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入共享词典，本地缓存</span></span><br><span class="line"><span class="keyword">local</span> item_cache = ngx.shared.item_cache</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 封装查询函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read_data</span><span class="params">(key, expire, path, params)</span></span></span><br><span class="line">    <span class="comment">-- 查询本地缓存</span></span><br><span class="line">    <span class="keyword">local</span> val = item_cache:get(key)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;本地缓存查询失败，尝试查询Redis， key: &quot;</span>, key)</span><br><span class="line">        <span class="comment">-- 查询redis</span></span><br><span class="line">        val = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, key)</span><br><span class="line">        <span class="comment">-- 判断查询结果</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">            ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;redis查询失败，尝试查询http， key: &quot;</span>, key)</span><br><span class="line">            <span class="comment">-- redis查询失败，去查询http</span></span><br><span class="line">            val = read_http(<span class="built_in">path</span>, params)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 查询成功，把数据写入本地缓存</span></span><br><span class="line">    item_cache:set(key, val, expire)</span><br><span class="line">    <span class="comment">-- 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>2）修改item.lua中查询商品和库存的业务，实现最新的read_data函数：</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202403011026513.png" alt="image-20210821115108528"></p><p>其实就是多了缓存时间参数，过期后nginx缓存会自动删除，下次访问即可更新缓存。</p><p>这里给商品基本信息设置超时时间为30分钟，库存为1分钟。</p><p>因为库存更新频率较高，如果缓存时间过长，可能与数据库差异较大。</p><p>3）完整的item.lua文件：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入common函数库</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&#x27;common&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="keyword">local</span> read_redis = common.read_redis</span><br><span class="line"><span class="comment">-- 导入cjson库</span></span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">&#x27;cjson&#x27;</span>)</span><br><span class="line"><span class="comment">-- 导入共享词典，本地缓存</span></span><br><span class="line"><span class="keyword">local</span> item_cache = ngx.shared.item_cache</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 封装查询函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read_data</span><span class="params">(key, expire, path, params)</span></span></span><br><span class="line">    <span class="comment">-- 查询本地缓存</span></span><br><span class="line">    <span class="keyword">local</span> val = item_cache:get(key)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;本地缓存查询失败，尝试查询Redis， key: &quot;</span>, key)</span><br><span class="line">        <span class="comment">-- 查询redis</span></span><br><span class="line">        val = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, key)</span><br><span class="line">        <span class="comment">-- 判断查询结果</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">            ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;redis查询失败，尝试查询http， key: &quot;</span>, key)</span><br><span class="line">            <span class="comment">-- redis查询失败，去查询http</span></span><br><span class="line">            val = read_http(<span class="built_in">path</span>, params)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 查询成功，把数据写入本地缓存</span></span><br><span class="line">    item_cache:set(key, val, expire)</span><br><span class="line">    <span class="comment">-- 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取路径参数</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询商品信息</span></span><br><span class="line"><span class="keyword">local</span> itemJSON = read_data(<span class="string">&quot;item:id:&quot;</span> .. id, <span class="number">1800</span>,  <span class="string">&quot;/item/&quot;</span> .. id, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">-- 查询库存信息</span></span><br><span class="line"><span class="keyword">local</span> stockJSON = read_data(<span class="string">&quot;item:stock:id:&quot;</span> .. id, <span class="number">60</span>, <span class="string">&quot;/item/stock/&quot;</span> .. id, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- JSON转化为lua的table</span></span><br><span class="line"><span class="keyword">local</span> item = cjson.decode(itemJSON)</span><br><span class="line"><span class="keyword">local</span> stock = cjson.decode(stockJSON)</span><br><span class="line"><span class="comment">-- 组合数据</span></span><br><span class="line">item.stock = stock.stock</span><br><span class="line">item.sold = stock.sold</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 把item序列化为json 返回结果</span></span><br><span class="line">ngx.say(cjson.encode(item))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis高级-2-—-多级缓存&quot;&gt;&lt;a href=&quot;#Redis高级-2-—-多级缓存&quot; class=&quot;headerlink&quot; title=&quot;Redis高级(2)  —- 多级缓存&quot;&gt;&lt;/a&gt;Redis高级(2)  —- 多级缓存&lt;/h1&gt;&lt;p&gt;传统的缓存的请求</summary>
      
    
    
    
    <category term="知识笔记" scheme="https://hantoul.github.io/categories/%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Redis" scheme="https://hantoul.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis高级(1) - 持久化</title>
    <link href="https://hantoul.github.io/2024/02/28/2024-2-28-Redis%E9%AB%98%E7%BA%A7-1-%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://hantoul.github.io/2024/02/28/2024-2-28-Redis%E9%AB%98%E7%BA%A7-1-%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2024-02-28T05:37:51.000Z</published>
    <updated>2024-02-28T05:37:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis高级-—-持久化-1"><a href="#Redis高级-—-持久化-1" class="headerlink" title="Redis高级  —- 持久化(1)"></a>Redis高级  —- 持久化(1)</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>RDB就是Redis数据快照,其将Redis的数据本身保存到硬盘</p><p>如果直接使用<code>save</code>来执行RDB,会阻塞所有命令</p><p>建议使用<code>bgsave</code>,会开启子进程来执行RDB,避免主进程收到阻塞</p><h3 id="RDB在Redis内部的使用"><a href="#RDB在Redis内部的使用" class="headerlink" title="RDB在Redis内部的使用"></a>RDB在Redis内部的使用</h3><p>redis.conf中配置了默认的RDB机制</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启RDB</span></span><br><span class="line"><span class="comment"># save &quot;&quot; 表示禁用RDB</span></span><br><span class="line"><span class="comment"># 3600s内,若至少有1个key被修改,则执行bgsave</span></span><br><span class="line"><span class="attr">save</span> <span class="string">3600 1</span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 100</span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 是否压缩rdb文件</span></span><br><span class="line"><span class="attr">rdbcompression</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># rdb文件名</span></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">dump.rdb</span></span><br><span class="line"><span class="comment"># 文件保存的路径目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">./</span></span><br></pre></td></tr></table></figure><h3 id="RDB原理"><a href="#RDB原理" class="headerlink" title="RDB原理"></a>RDB原理</h3><p>bgsave开始时会fork主进程得到子进程，子进程<strong>共享</strong>主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p><p>fork采用的是copy-on-write技术：</p><ul><li>当主进程执行读操作时，访问共享内存；</li><li>当主进程执行写操作时，则会<strong>拷贝一份数据</strong>，执行写操作。</li></ul><hr><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>即追加文件,Redis处理的每一个写命令都会记录在AOF,可看作命令日志文件</p><p>AOF默认关闭,需要修改redis.conf配置文件来开启AOF：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否开启AOF功能，默认是no</span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># AOF文件的名称</span></span><br><span class="line"><span class="attr">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span></span><br></pre></td></tr></table></figure><p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示每执行一次写命令，立即记录到AOF文件</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">always </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">everysec </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">no</span></span><br></pre></td></tr></table></figure><p>三种策略对比：</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402262358611.png" alt=""></p><p>RDB与AOF对比</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402270010354.png" alt=""></p><h3 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h3><p>如果之前写入了a,然后又写入了a,会执行文件重写,将用最新的值替代之前的值</p><p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AOF文件比上次文件 增长超过多少百分比则触发重写</span></span><br><span class="line"><span class="attr">auto-aof-rewrite-percentage</span> <span class="string">100</span></span><br><span class="line"><span class="comment"># AOF文件体积最小多大以上才触发重写 </span></span><br><span class="line"><span class="attr">auto-aof-rewrite-min-size</span> <span class="string">64mb </span></span><br></pre></td></tr></table></figure><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="数据同步原理"><a href="#数据同步原理" class="headerlink" title="数据同步原理"></a>数据同步原理</h3><p>主从第一次同步数据是<strong>全量同步</strong>,从节点会从主节点中拉取所有数据bgsave(RBD)</p><p>新写的数据会使用AOF进行同步,将在RDB的时间内收到的命令在从节点中再执行一次(<strong>增量数据同步</strong>)</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402271414009.png" alt="image-20240227141357869"></p><h4 id="数据同步情况的判断"><a href="#数据同步情况的判断" class="headerlink" title="数据同步情况的判断"></a>数据同步情况的判断</h4><ul><li>Replication Id: 简称replid,是数据集的标记; slave会继承master的replid</li><li>offset: 偏移量,若从节点offset小于offset,则说明从节点数据落后于主节点</li></ul><blockquote><p>主节点的增量同步数据若过长时间没有存入从节点,会导致溢出的数据覆盖原有数据,这时从节点要获取主节点数据就需要获取全量数据了</p><p>这个问题无法避免,只能尽量去优化,减少其出现的概率</p></blockquote><h4 id="数据同步的优化"><a href="#数据同步的优化" class="headerlink" title="数据同步的优化"></a>数据同步的优化</h4><ul><li>在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。</li><li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</li><li>适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li><li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从<u>链式结构</u>，减少master压力</li></ul><h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><p>上面的最基础的集群中,若主节点宕机了,那么整个服务就会陷入混乱; 这时就引入了哨兵Sentinel机制</p><p>哨兵负责衔接外部的请求和Redis集群,能为Redis访问提供正确的结点</p><h4 id="服务状态监控"><a href="#服务状态监控" class="headerlink" title="服务状态监控"></a>服务状态监控</h4><p>Sentinel的服务状态监控基于心跳机制,分为主观下线和客观下线</p><ul><li>主观下线: 某个Sentinel节点发现某实例未在规定时间内响应,则将其记为主管下线</li><li>客观下线: 若超过某个数量(最好是过半哨兵)的哨兵都认为某个节点主观下线了,就将这个实例记为客观下线</li></ul><h4 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h4><p>当发现master出现问题,就需要哨兵们选举新的master</p><ul><li>首先判断slave和master断开时间的长短,若超过指定值则会将该slave排除</li><li>再判断slave的优先级,越小越高,0不参加选举</li><li>再判断offset值,越大说明越新,优先级更高</li></ul><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><ul><li>哨兵给slave发送命令让该节点成为master</li><li>哨兵再给其余slave发送slave of (新主节点地址),让这些slave成为新的master的从节点</li><li>最后哨兵将故障的master节点标记为slave,若其在之后恢复正常了,会成为新master的从节点</li></ul><h4 id="哨兵集群搭建"><a href="#哨兵集群搭建" class="headerlink" title="哨兵集群搭建"></a>哨兵集群搭建</h4><p>跟搭建redis集群差不多,不赘述了</p><blockquote><p>这里在搭建的时候,redis声明ip跟着文档填忘了改成自己的了,抓了一个多小时虫子…</p></blockquote><h3 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h3><p>主从+哨兵实现了高可用高并发,但是仍然没有解决两个问题</p><ul><li>海量数据存储</li><li>高并发写</li></ul><p>使用分片集群可以结局上述问题, 分片集群的特征如下</p><ul><li>集群中有多个master, 保存不同数据</li><li>每个master都有多个slave结点</li><li>master之间互相ping来检测状态</li><li>客户端可以访问任意节点,最终会通过redis集群内部的路由转发到正确的节点</li></ul><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402281116061.png" alt="image-20240228111619707"></p><h4 id="散列插槽"><a href="#散列插槽" class="headerlink" title="散列插槽"></a>散列插槽</h4><p>Redis会把每一个节点映射到一个插槽上,数据的key不与节点绑定,而是与插槽绑定; Redis会根据key来计算插槽值,然后把对应的值放到相应的插槽中, 实际上就是一个hash</p><h4 id="集训伸缩"><a href="#集训伸缩" class="headerlink" title="集训伸缩"></a>集训伸缩</h4><p>Redis集群支持动态的增加或者减少实例数量</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis高级-—-持久化-1&quot;&gt;&lt;a href=&quot;#Redis高级-—-持久化-1&quot; class=&quot;headerlink&quot; title=&quot;Redis高级  —- 持久化(1)&quot;&gt;&lt;/a&gt;Redis高级  —- 持久化(1)&lt;/h1&gt;&lt;h2 id=&quot;RDB&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="知识笔记" scheme="https://hantoul.github.io/categories/%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Redis" scheme="https://hantoul.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis秒杀代码(逐步测试修改)</title>
    <link href="https://hantoul.github.io/2024/02/26/2024-2-26-Redis-%E7%A7%92%E6%9D%80%E7%AC%94%E8%AE%B01/"/>
    <id>https://hantoul.github.io/2024/02/26/2024-2-26-Redis-%E7%A7%92%E6%9D%80%E7%AC%94%E8%AE%B01/</id>
    <published>2024-02-26T06:37:46.000Z</published>
    <updated>2024-02-26T06:37:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis秒杀代码-逐步测试修改"><a href="#Redis秒杀代码-逐步测试修改" class="headerlink" title="Redis秒杀代码(逐步测试修改)"></a>Redis秒杀代码(逐步测试修改)</h1><hr><p>因为主要体现秒杀的业务,所以这里没融合jwt或者Session的登录校验,故id是直接显示传入的</p><h2 id="秒杀代码-Ver1-单例"><a href="#秒杀代码-Ver1-单例" class="headerlink" title="秒杀代码.Ver1 (单例)"></a>秒杀代码.Ver1 (单例)</h2><p>本次秒杀没有通过redis，在单例的情况下，直接通过查询数据库来实现防止超卖和一人一单，最简单，最暴力</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillItem</span><span class="params">(SecKillDTO secKillDTO)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">itemId</span> <span class="operator">=</span> secKillDTO.getItemId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> secKillDTO.getUserId();</span><br><span class="line">    <span class="comment">//1.获取对应的秒杀对象</span></span><br><span class="line">    <span class="type">SeckillItem</span> <span class="variable">item</span> <span class="operator">=</span> seckillItemService.getById(itemId);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">//2.判断是否在秒杀时间内</span></span><br><span class="line">    <span class="comment">//2.1 不在秒杀时间内</span></span><br><span class="line">    <span class="keyword">if</span>(now.isBefore(item.getBeginTime())||now.isAfter(item.getEndTime()))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="number">400</span>,<span class="string">&quot;当前不在秒杀时间段内!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --&gt; 从这里开始需要进行事务操作</span></span><br><span class="line">    <span class="keyword">synchronized</span> (userId.toString().intern())&#123;</span><br><span class="line">        <span class="comment">//3.判断是否下过单</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;item_id&quot;</span>, itemId).count();</span><br><span class="line">        <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="number">400</span>,<span class="string">&quot;您已经抢购过了,请勿重复下单!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.判断库存是否充足</span></span><br><span class="line">        <span class="comment">//找到对应秒杀商品,校验库存并扣减</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillItemService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;item_id&quot;</span>,itemId)</span><br><span class="line">                .gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>)</span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="number">400</span>,<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        itemService.update().</span><br><span class="line">                setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;id&quot;</span>,itemId)</span><br><span class="line">                .update();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.创建订单</span></span><br><span class="line">        <span class="type">ItemOrder</span> <span class="variable">itemOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ItemOrder</span>();</span><br><span class="line">        itemOrder.setUserId(userId);</span><br><span class="line">        itemOrder.setItemId(itemId);</span><br><span class="line">        <span class="built_in">this</span>.save(itemOrder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success(itemOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在开100个进程,商品库存设置为100,每个进程循环2次,相当于200个人抢100个商品,未出现异常,响应时间均值144ms</p><p><strong>测试结果</strong></p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402211210518.png" alt="image-20240221121052378"></p><hr><h2 id="秒杀代码-Ver2-单例"><a href="#秒杀代码-Ver2-单例" class="headerlink" title="秒杀代码.Ver2 (单例)"></a>秒杀代码.Ver2 (单例)</h2><p>第二版代码加上了Redis; 通过Redis中的Hash数据结构来存储被秒杀的商品信息, 使用set来存存储购买商品了的用户的信息;</p><p><strong>秒杀代码</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//秒杀ver2(单例 + redis优化)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillItem</span><span class="params">(SecKillDTO secKillDTO)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">itemId</span> <span class="operator">=</span> secKillDTO.getItemId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> secKillDTO.getUserId();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> stringRedisTemplate.opsForHash().get(<span class="string">&quot;itemkill:stock:&quot;</span> + itemId, <span class="string">&quot;stock&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(o==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="number">404</span>,<span class="string">&quot;当前秒杀商品不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.获取对应的秒杀对象</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> LocalDateTime.parse(</span><br><span class="line">            stringRedisTemplate.opsForHash()</span><br><span class="line">                    .get(<span class="string">&quot;itemkill:stock:&quot;</span> + itemId, <span class="string">&quot;beginTime&quot;</span>)</span><br><span class="line">                    .toString(),</span><br><span class="line">            DateTimeFormatter.ISO_LOCAL_DATE_TIME</span><br><span class="line">    );</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> LocalDateTime.parse(</span><br><span class="line">            stringRedisTemplate.opsForHash()</span><br><span class="line">                    .get(<span class="string">&quot;itemkill:stock:&quot;</span> + itemId, <span class="string">&quot;endTime&quot;</span>)</span><br><span class="line">                    .toString(),</span><br><span class="line">            DateTimeFormatter.ISO_LOCAL_DATE_TIME</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">//2.判断是否在秒杀时间内</span></span><br><span class="line">    <span class="comment">//2.1 不在秒杀时间内</span></span><br><span class="line">    <span class="keyword">if</span>(now.isBefore(beginTime)||now.isAfter(endTime))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="number">400</span>,<span class="string">&quot;当前不在秒杀时间段内!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.runOrder(userId,itemId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">Result <span class="title function_">runOrder</span><span class="params">(Long userId, Long itemId)</span>&#123;</span><br><span class="line">    <span class="comment">// --&gt; 从这里开始需要进行事务操作</span></span><br><span class="line">    <span class="keyword">synchronized</span> (userId.toString().intern())&#123;</span><br><span class="line">        <span class="comment">//3.判断是否下过单</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">isOrdered</span> <span class="operator">=</span> stringRedisTemplate.opsForSet().isMember(<span class="string">&quot;itemkill:order:&quot;</span> + itemId, userId.toString());</span><br><span class="line">        <span class="keyword">if</span>(Boolean.TRUE.equals(isOrdered))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="number">400</span>,<span class="string">&quot;您已经抢购过了,请勿重复下单!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.判断库存是否充足</span></span><br><span class="line">        <span class="comment">//获取库存数据</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">stock</span> <span class="operator">=</span> Integer.parseInt(stringRedisTemplate.opsForHash().get(<span class="string">&quot;itemkill:stock:&quot;</span> + itemId, <span class="string">&quot;stock&quot;</span>).toString());</span><br><span class="line">        <span class="comment">//找到对应秒杀商品,校验库存并扣减</span></span><br><span class="line">        <span class="keyword">if</span>(stock&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="number">400</span>,<span class="string">&quot;当前商品库存不足!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        stock -= <span class="number">1</span>;</span><br><span class="line">        stringRedisTemplate.opsForHash().put(<span class="string">&quot;itemkill:stock:&quot;</span> + itemId,<span class="string">&quot;stock&quot;</span>,stock.toString());</span><br><span class="line"></span><br><span class="line">        seckillItemService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;item_id&quot;</span>,itemId)</span><br><span class="line">                .update();</span><br><span class="line">        itemService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;id&quot;</span>,itemId)</span><br><span class="line">                .update();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.创建订单</span></span><br><span class="line">        <span class="type">ItemOrder</span> <span class="variable">itemOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ItemOrder</span>();</span><br><span class="line">        itemOrder.setUserId(userId);</span><br><span class="line">        itemOrder.setItemId(itemId);</span><br><span class="line">        <span class="built_in">this</span>.save(itemOrder);</span><br><span class="line"></span><br><span class="line">        stringRedisTemplate.opsForSet().add(<span class="string">&quot;itemkill:order:&quot;</span> + itemId, userId.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success(itemOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加秒杀商品代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span> <span class="comment">// 整个过程需要作为一个事务</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;Void&gt; <span class="title function_">add</span><span class="params">(AddSeckillItemDTO dto)</span> &#123;</span><br><span class="line">    <span class="comment">// 先同步到数据库</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">itemId</span> <span class="operator">=</span> dto.getItemId();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> dto.getBeginTime();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> dto.getEndTime();</span><br><span class="line">    <span class="type">SeckillItem</span> <span class="variable">seckillItem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillItem</span>();</span><br><span class="line">    <span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> itemService.getById(itemId);</span><br><span class="line">    <span class="keyword">if</span>(item == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="number">404</span>,<span class="string">&quot;不存在该商品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    seckillItem.setItemId(item.getId());</span><br><span class="line">    seckillItem.setStock(item.getStock());</span><br><span class="line">    seckillItem.setBeginTime(beginTime);</span><br><span class="line">    seckillItem.setEndTime(endTime);</span><br><span class="line">    <span class="built_in">this</span>.saveOrUpdate(seckillItem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再将优惠券信息同步到Redis中作为热点数据存储</span></span><br><span class="line">    Map&lt;String, String&gt; properties = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    properties.put(<span class="string">&quot;stock&quot;</span>, seckillItem.getStock().toString());</span><br><span class="line">    properties.put(<span class="string">&quot;beginTime&quot;</span>, seckillItem.getBeginTime().toString());</span><br><span class="line">    properties.put(<span class="string">&quot;endTime&quot;</span>, seckillItem.getEndTime().toString());</span><br><span class="line">    stringRedisTemplate.opsForHash().putAll(<span class="string">&quot;itemkill:stock:&quot;</span>+seckillItem.getItemId().toString(), properties);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然但是,本来打算这一版做了再写有分布式锁的集群的版本,但是在测试时出现了<strong>超卖</strong>的问题,进过排查,我这个多线程的测试方法就是需要加分布式锁,不然会超卖,所以这一版到此为止,在第三版中会加入分布式锁Redisson来解决多线程操作Redis导致的超卖问题</p><p>具体来说,在下面这段代码中,多线程状态下,会导致不同时间下各个线程分别获取的stock数据被自减后反复写回Redis,最终造成超卖,然后我采用的数据结构又没法采用Redis的原子操作<code>decr()</code>来解决这个问题,所以需要添加分布式锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取库存数据</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">stock</span> <span class="operator">=</span> Integer.parseInt(stringRedisTemplate.opsForHash().get(<span class="string">&quot;itemkill:stock:&quot;</span> + itemId, <span class="string">&quot;stock&quot;</span>).toString());</span><br><span class="line"><span class="comment">//找到对应秒杀商品,校验库存并扣减</span></span><br><span class="line"><span class="keyword">if</span>(stock&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="number">400</span>,<span class="string">&quot;当前商品库存不足!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">stock -= <span class="number">1</span>;</span><br><span class="line">stringRedisTemplate.opsForHash().put(<span class="string">&quot;itemkill:stock:&quot;</span> + itemId,<span class="string">&quot;stock&quot;</span>,stock.toString());</span><br></pre></td></tr></table></figure><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402212244502.png" alt="image-20240221224423364"></p><p>(延迟够低吧? 超卖换的(笑))</p><h2 id="秒杀代码-Ver3-Redisson"><a href="#秒杀代码-Ver3-Redisson" class="headerlink" title="秒杀代码.Ver3 (Redisson)"></a>秒杀代码.Ver3 (Redisson)</h2><p>Redisson作为第一个较为成熟的Redisson分布式锁, 给多线程下的Redis操作加个锁简直是小菜一碟</p><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--redisson--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加配置类RedissonConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redisClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://localhost:6379&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>给ver2的代码加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//秒杀ver3(Redisson)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillItem</span><span class="params">(SecKillDTO secKillDTO)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">itemId</span> <span class="operator">=</span> secKillDTO.getItemId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> secKillDTO.getUserId();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> stringRedisTemplate.opsForHash().get(<span class="string">&quot;itemkill:stock:&quot;</span> + itemId, <span class="string">&quot;stock&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(o==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="number">404</span>,<span class="string">&quot;当前秒杀商品不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.获取对应的秒杀对象</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> LocalDateTime.parse(</span><br><span class="line">            stringRedisTemplate.opsForHash()</span><br><span class="line">                    .get(<span class="string">&quot;itemkill:stock:&quot;</span> + itemId, <span class="string">&quot;beginTime&quot;</span>)</span><br><span class="line">                    .toString(),</span><br><span class="line">            DateTimeFormatter.ISO_LOCAL_DATE_TIME</span><br><span class="line">    );</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> LocalDateTime.parse(</span><br><span class="line">            stringRedisTemplate.opsForHash()</span><br><span class="line">                    .get(<span class="string">&quot;itemkill:stock:&quot;</span> + itemId, <span class="string">&quot;endTime&quot;</span>)</span><br><span class="line">                    .toString(),</span><br><span class="line">            DateTimeFormatter.ISO_LOCAL_DATE_TIME</span><br><span class="line">    );</span><br><span class="line">   </span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">//2.判断是否在秒杀时间内</span></span><br><span class="line">    <span class="comment">//2.1 不在秒杀时间内</span></span><br><span class="line">    <span class="keyword">if</span>(now.isBefore(beginTime)||now.isAfter(endTime))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="number">400</span>,<span class="string">&quot;当前不在秒杀时间段内!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.runOrder(userId,itemId);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">Result <span class="title function_">runOrder</span><span class="params">(Long userId, Long itemId)</span>&#123;</span><br><span class="line">    <span class="comment">// --&gt; 从这里开始需要进行事务操作</span></span><br><span class="line">    <span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> redissonConfig.redisClient();</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">seckillLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;seckill_lock&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            seckillLock.lock();</span><br><span class="line">            <span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">                <span class="comment">//3.判断是否下过单</span></span><br><span class="line">                <span class="type">Boolean</span> <span class="variable">isOrdered</span> <span class="operator">=</span> stringRedisTemplate.opsForSet().isMember(<span class="string">&quot;itemkill:order:&quot;</span> + itemId, userId.toString());</span><br><span class="line">                <span class="keyword">if</span> (Boolean.TRUE.equals(isOrdered)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Result.fail(<span class="number">400</span>, <span class="string">&quot;您已经抢购过了,请勿重复下单!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//4.判断库存是否充足</span></span><br><span class="line">                <span class="comment">//获取库存数据</span></span><br><span class="line">                <span class="type">Integer</span> <span class="variable">stock</span> <span class="operator">=</span> Integer.parseInt(stringRedisTemplate.opsForHash().get(<span class="string">&quot;itemkill:stock:&quot;</span> + itemId, <span class="string">&quot;stock&quot;</span>).toString());</span><br><span class="line">                <span class="comment">//找到对应秒杀商品,校验库存并扣减</span></span><br><span class="line">                <span class="keyword">if</span> (stock &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Result.fail(<span class="number">400</span>, <span class="string">&quot;当前商品库存不足!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                stock -= <span class="number">1</span>;</span><br><span class="line">                stringRedisTemplate.opsForHash().put(<span class="string">&quot;itemkill:stock:&quot;</span> + itemId, <span class="string">&quot;stock&quot;</span>, stock.toString());</span><br><span class="line">   </span><br><span class="line">                seckillItemService.update()</span><br><span class="line">                        .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                        .eq(<span class="string">&quot;item_id&quot;</span>, itemId)</span><br><span class="line">                        .update();</span><br><span class="line">                itemService.update()</span><br><span class="line">                        .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                        .eq(<span class="string">&quot;id&quot;</span>, itemId)</span><br><span class="line">                        .update();</span><br><span class="line">   </span><br><span class="line">                <span class="comment">//5.创建订单</span></span><br><span class="line">                <span class="type">ItemOrder</span> <span class="variable">itemOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ItemOrder</span>();</span><br><span class="line">                itemOrder.setUserId(userId);</span><br><span class="line">                itemOrder.setItemId(itemId);</span><br><span class="line">                <span class="built_in">this</span>.save(itemOrder);</span><br><span class="line">   </span><br><span class="line">                stringRedisTemplate.opsForSet().add(<span class="string">&quot;itemkill:order:&quot;</span> + itemId, userId.toString());</span><br><span class="line">   </span><br><span class="line">                <span class="keyword">return</span> Result.success(itemOrder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            seckillLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样好像不太对,延迟非常恐怖,甚至比直接访问数据库还要夸张; 直接修改相当于加了两层锁, Redis一层,进了Redis又有一层UserId的锁</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402252058001.png" alt="image-20240225205823890"></p></li></ol><ol><li><p>再修改</p><ul><li><p>首先对锁进行改造</p><p>重新对之前的代码进行分析,发现我们做的有点画蛇添足了; 还记得我们Ver2中提出了什么问题吗? 我们使用Redisson主要是为了解决stock写回时的冲突问题;</p><p>查阅文档,发现Redisson为我们提供了一系列支持分布式的数据结构,其中使用RMap来接管Redis中的Hash数据结构; 对于RMap的put等操作请求会直接同步到Redis中,不用再使用Template来进行上传;</p><p>进过上面的分析,我们发现,这里<strong>只需要在对RMap进行操作来判断并更新库存的时候需要加上Redisson的锁</strong>,所以只需要加一部分的锁就行,同时恢复之前的对userId加的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">    Result <span class="title function_">runOrder</span><span class="params">(Long userId, Long itemId)</span>&#123;</span><br><span class="line">        <span class="comment">// --&gt; 从这里开始需要进行事务操作</span></span><br><span class="line">        <span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">            <span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> redissonConfig.redisClient();</span><br><span class="line">            <span class="comment">//3.判断是否下过单</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isOrdered</span> <span class="operator">=</span> redissonClient.getSet(<span class="string">&quot;itemkill:order:&quot;</span> + itemId).contains(userId.toString());</span><br><span class="line">            <span class="comment">//Boolean isOrdered = stringRedisTemplate.opsForSet().isMember(&quot;itemkill:order:&quot; + itemId, userId.toString());</span></span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(isOrdered)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.fail(<span class="number">400</span>, <span class="string">&quot;您已经抢购过了,请勿重复下单!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//4.判断库存是否充足</span></span><br><span class="line">            <span class="comment">//获取库存数据</span></span><br><span class="line">            <span class="type">RLock</span> <span class="variable">stockLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;redisson_stock_lock&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                stockLock.lock();</span><br><span class="line">                RMap&lt;String, String&gt; rmap = redissonClient.getMap(<span class="string">&quot;itemkill:stock:&quot;</span> + itemId);</span><br><span class="line">                log.warn(rmap.toString());</span><br><span class="line">                <span class="type">int</span> <span class="variable">stock</span> <span class="operator">=</span> Integer.parseInt(rmap.get(<span class="string">&quot;stock&quot;</span>));</span><br><span class="line">                <span class="comment">//Integer stock = Integer.parseInt(redissonClient.getMap(&quot;itemkill:stock:&quot; + itemId).get(&quot;stock&quot;).toString());</span></span><br><span class="line">                <span class="comment">//Integer stock = Integer.parseInt(stringRedisTemplate.opsForHash().get(&quot;itemkill:stock:&quot; + itemId, &quot;stock&quot;).toString());</span></span><br><span class="line">                <span class="comment">//找到对应秒杀商品,校验库存并扣减</span></span><br><span class="line">                <span class="keyword">if</span> (stock &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Result.fail(<span class="number">400</span>, <span class="string">&quot;当前商品库存不足!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                rmap.fastPut(<span class="string">&quot;stock&quot;</span>,String.valueOf(stock - <span class="number">1</span> ));</span><br><span class="line">                <span class="comment">//stock -= 1;</span></span><br><span class="line">                <span class="comment">//stringRedisTemplate.opsForHash().put(&quot;itemkill:stock:&quot; + itemId, &quot;stock&quot;, stock.toString());</span></span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                stockLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            seckillItemService.update()</span><br><span class="line">                    .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                    .eq(<span class="string">&quot;item_id&quot;</span>, itemId)</span><br><span class="line">                    .update();</span><br><span class="line">            itemService.update()</span><br><span class="line">                    .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                    .eq(<span class="string">&quot;id&quot;</span>, itemId)</span><br><span class="line">                    .update();</span><br><span class="line">            <span class="comment">//5.创建订单</span></span><br><span class="line">            <span class="type">ItemOrder</span> <span class="variable">itemOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ItemOrder</span>();</span><br><span class="line">            itemOrder.setUserId(userId);</span><br><span class="line">            itemOrder.setItemId(itemId);</span><br><span class="line">            <span class="built_in">this</span>.save(itemOrder);</span><br><span class="line">            stringRedisTemplate.opsForSet().add(<span class="string">&quot;itemkill:order:&quot;</span> + itemId, userId.toString());</span><br><span class="line">            <span class="keyword">return</span> Result.success(itemOrder);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>发现了一个问题</p><p>在以前添加抢购商品的代码中,我直接使用的是StringRedisTemplate中的Hash进行插入;然后在抢购代码中进行拉取RMap的操作时会报错<code>java.io.IOException: Unsupported protocol version 98</code></p><p>这里我推测是RedisTemplate中的写操作的解析器和Redisson的不同; 所以解决方法也很粗暴,直接把涉及存储和读取的地方都替换成使用Redisson中的方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; properties = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">properties.put(<span class="string">&quot;stock&quot;</span>, seckillItem.getStock().toString());</span><br><span class="line">properties.put(<span class="string">&quot;beginTime&quot;</span>, seckillItem.getBeginTime().toString());</span><br><span class="line">properties.put(<span class="string">&quot;endTime&quot;</span>, seckillItem.getEndTime().toString());</span><br><span class="line"><span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> redissonConfig.redisClient();</span><br><span class="line">RMap&lt;String, String&gt; map = redissonClient.getMap(<span class="string">&quot;itemkill:stock:&quot;</span>+seckillItem.getItemId().toString());</span><br><span class="line">map.putAll(properties);</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>效果拔群</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402252143776.png" alt="image-20240225214325737"></p><p>​     </p><p>再看看代码,感觉还是有很大的优化空间; 比如说:</p><ul><li><p>对于数据库的同步太频繁,每次成功秒杀还是要修改数据库的库存;</p><p>是否可以定时或者定量地进行异步的同步呢?</p></li><li><p>还可以添加消息队列MQ来进行流量的平衡</p><p>仔细想想,来的早的请求没有不给他秒杀资格的道理,使用MQ还可以将资格判断与库存的扣减<strong>解耦</strong>,进一步地增加了数据的安全</p></li></ul><hr><h2 id="秒杀代码-Ver4-RabbitMQ"><a href="#秒杀代码-Ver4-RabbitMQ" class="headerlink" title="秒杀代码.Ver4 (RabbitMQ)"></a>秒杀代码.Ver4 (RabbitMQ)</h2><p>这里添加RabbitMQ对秒杀业务进行解耦操作; 当秒杀请求打进来后先判断其是否有抢购资格,然后把它丢到消息队列,然后异步地交给负责下单的方法进行判断并下单; 实现起来并不复杂</p><ol><li><p>引入RabbitMQ依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;--MQ--&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置RabbitMQConfig</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">Queue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder</span><br><span class="line">                .durable(<span class="string">&quot;item_seckill&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改秒杀代码</p><p>总体思路是把对数据库的操作与对RabbitMQ的查询分离,然后在验证请求的秒杀资格成功后将对数据库的操作丢入消息队列</p><p>需要注意锁的范围的修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//秒杀ver4(RabbitMQ 解耦)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillItem</span><span class="params">(SecKillDTO secKillDTO)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">itemId</span> <span class="operator">=</span> secKillDTO.getItemId();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> secKillDTO.getUserId();</span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> redissonConfig.redisClient();</span><br><span class="line">        RMap&lt;String, String&gt; rMap = redissonClient.getMap(<span class="string">&quot;itemkill:stock:&quot;</span> + itemId);</span><br><span class="line">        <span class="comment">//Object o = stringRedisTemplate.opsForHash().get(&quot;itemkill:stock:&quot; + itemId, &quot;stock&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(rMap==<span class="literal">null</span>||rMap.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="number">404</span>,<span class="string">&quot;当前秒杀商品不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.获取对应的秒杀对象</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> LocalDateTime.parse(</span><br><span class="line"><span class="comment">//                stringRedisTemplate.opsForHash()</span></span><br><span class="line"><span class="comment">//                        .get(&quot;itemkill:stock:&quot; + itemId, &quot;beginTime&quot;)</span></span><br><span class="line"><span class="comment">//                        .toString(),</span></span><br><span class="line">                rMap.get(<span class="string">&quot;beginTime&quot;</span>),</span><br><span class="line">                DateTimeFormatter.ISO_LOCAL_DATE_TIME</span><br><span class="line">        );</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> LocalDateTime.parse(</span><br><span class="line"><span class="comment">//                stringRedisTemplate.opsForHash()</span></span><br><span class="line"><span class="comment">//                        .get(&quot;itemkill:stock:&quot; + itemId, &quot;endTime&quot;)</span></span><br><span class="line"><span class="comment">//                        .toString(),</span></span><br><span class="line">                rMap.get(<span class="string">&quot;endTime&quot;</span>),</span><br><span class="line">                DateTimeFormatter.ISO_LOCAL_DATE_TIME</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="comment">//2.判断是否在秒杀时间内</span></span><br><span class="line">        <span class="comment">//2.1 不在秒杀时间内</span></span><br><span class="line">        <span class="keyword">if</span>(now.isBefore(beginTime)||now.isAfter(endTime))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="number">400</span>,<span class="string">&quot;当前不在秒杀时间段内!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">            <span class="comment">//3.判断是否下过单</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isOrdered</span> <span class="operator">=</span> redissonClient.getSet(<span class="string">&quot;itemkill:order:&quot;</span> + itemId).contains(userId.toString());</span><br><span class="line">            <span class="comment">//Boolean isOrdered = stringRedisTemplate.opsForSet().isMember(&quot;itemkill:order:&quot; + itemId, userId.toString());</span></span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(isOrdered)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.fail(<span class="number">400</span>, <span class="string">&quot;您已经抢购过了,请勿重复下单!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//4.判断库存是否充足</span></span><br><span class="line">            <span class="comment">//获取库存数据</span></span><br><span class="line">            <span class="type">RLock</span> <span class="variable">stockLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;redisson_stock_lock&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stockLock.lock();</span><br><span class="line">                RMap&lt;String, String&gt; rmap = redissonClient.getMap(<span class="string">&quot;itemkill:stock:&quot;</span> + itemId);</span><br><span class="line">                log.warn(rmap.toString());</span><br><span class="line">                <span class="type">int</span> <span class="variable">stock</span> <span class="operator">=</span> Integer.parseInt(rmap.get(<span class="string">&quot;stock&quot;</span>));</span><br><span class="line">                <span class="comment">//Integer stock = Integer.parseInt(redissonClient.getMap(&quot;itemkill:stock:&quot; + itemId).get(&quot;stock&quot;).toString());</span></span><br><span class="line">                <span class="comment">//Integer stock = Integer.parseInt(stringRedisTemplate.opsForHash().get(&quot;itemkill:stock:&quot; + itemId, &quot;stock&quot;).toString());</span></span><br><span class="line">                <span class="comment">//找到对应秒杀商品,校验库存并扣减</span></span><br><span class="line">                <span class="keyword">if</span> (stock &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Result.fail(<span class="number">400</span>, <span class="string">&quot;当前商品库存不足!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                rmap.fastPut(<span class="string">&quot;stock&quot;</span>, String.valueOf(stock - <span class="number">1</span>));</span><br><span class="line">                <span class="comment">//stock -= 1;</span></span><br><span class="line">                <span class="comment">//stringRedisTemplate.opsForHash().put(&quot;itemkill:stock:&quot; + itemId, &quot;stock&quot;, stock.toString());</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                stockLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ItemOrder</span> <span class="variable">itemOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ItemOrder</span>();</span><br><span class="line">        itemOrder.setUserId(userId);</span><br><span class="line">        itemOrder.setItemId(itemId);</span><br><span class="line">        stringRedisTemplate.opsForSet().add(<span class="string">&quot;itemkill:order:&quot;</span> + itemId, userId.toString());</span><br><span class="line">        amqpTemplate.convertAndSend(<span class="string">&quot;item_seckill&quot;</span>,itemOrder);</span><br><span class="line">        <span class="keyword">return</span> Result.success(itemOrder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runOrder</span><span class="params">(ItemOrder itemOrder)</span>&#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">itemId</span> <span class="operator">=</span> itemOrder.getItemId();</span><br><span class="line">        seckillItemService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;item_id&quot;</span>, itemId)</span><br><span class="line">                .update();</span><br><span class="line">        itemService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;id&quot;</span>, itemId)</span><br><span class="line">                .update();</span><br><span class="line">        <span class="comment">//5.创建订单</span></span><br><span class="line">        <span class="built_in">this</span>.save(itemOrder);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>写MQ的Listener的逻辑</p><p>直接调用刚才上面写好的操作数据库的方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;item_seckill&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">itemSeckillListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    ItemOrderService itemOrderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doOrder</span><span class="params">(ItemOrder itemOrder)</span>&#123;</span><br><span class="line">        itemOrderService.runOrder(itemOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>好吧,加了一个MQ之后又慢了不少; 可能效率和安全性没法完全兼顾</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402261423416.png" alt="image-20240226142330278"></p><hr><p><strong>应该还有很大的优化空间,后续找到更好的方法会更新</strong></p><ul><li>上面的代码部分还是使用的RedisTemple, 因为没啥大的印象,暂时还没有替换更新</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis秒杀代码-逐步测试修改&quot;&gt;&lt;a href=&quot;#Redis秒杀代码-逐步测试修改&quot; class=&quot;headerlink&quot; title=&quot;Redis秒杀代码(逐步测试修改)&quot;&gt;&lt;/a&gt;Redis秒杀代码(逐步测试修改)&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;因为主要体现秒</summary>
      
    
    
    
    <category term="知识笔记" scheme="https://hantoul.github.io/categories/%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Redis" scheme="https://hantoul.github.io/tags/Redis/"/>
    
    <category term="秒杀" scheme="https://hantoul.github.io/tags/%E7%A7%92%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>Redis-秒杀笔记1</title>
    <link href="https://hantoul.github.io/2024/02/21/2024-2-21-Redis-%E7%A7%92%E6%9D%80%E7%AC%94%E8%AE%B01-copy/"/>
    <id>https://hantoul.github.io/2024/02/21/2024-2-21-Redis-%E7%A7%92%E6%9D%80%E7%AC%94%E8%AE%B01-copy/</id>
    <published>2024-02-21T14:48:53.000Z</published>
    <updated>2024-02-21T14:48:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis秒杀"><a href="#Redis秒杀" class="headerlink" title="Redis秒杀"></a>Redis秒杀</h1><h2 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h2><p>按照我们平常做的自增的id来做的数据库，存在许多问题</p><ul><li>id规律性过于明显，可以对其进行破解；比如可以通过id的变化来判断商城的订单，通过id来爬取数据等</li><li>会受到单表数据量的限制</li></ul><h3 id="全局ID生成器"><a href="#全局ID生成器" class="headerlink" title="全局ID生成器"></a>全局ID生成器</h3><p>现在我们就需要生成一个全局唯一的ID，这就需要全局ID生成器，其需要具有唯一性、高性能、高可用、递增性和安全性</p><p>为了增加ID的安全性，我们不可以直接使用Redis自增的数值，而是要拼接一些其他信息。（其实就是雪花算法）</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402061819798.png" alt="image-20240206181418686"></p><h2 id="初版秒杀代码"><a href="#初版秒杀代码" class="headerlink" title="初版秒杀代码"></a>初版秒杀代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断秒杀是否结束</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span>(voucher.getStock()&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;当前优惠券已被抢光！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">            .update();</span><br><span class="line">    <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    voucherOrder.setUserId(UserHolder.getUser().getId());</span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    <span class="built_in">this</span>.save(voucherOrder);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样库存出现了超卖现象</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402070237584.png" alt="image-20240207023744388"></p><p>显然这种情况是不可接受的</p><p>在上面的代码中，我们先对他进行了查询判断，最后对数据库进行减操作；若在判断完成后，操作数据库前这一区间内存在多个线程，就可能造成超卖</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402070240110.png" alt="image-20240207024049064"></p><h2 id="利用锁来解决超卖"><a href="#利用锁来解决超卖" class="headerlink" title="利用锁来解决超卖"></a>利用锁来解决超卖</h2><p>这里就可以使用加锁的办法来防止超卖，所以这里用<strong>悲观锁</strong>还是<strong>乐观锁</strong>呢</p><ul><li><p>悲观锁假设线程安全问题一定会发生，所以在操作数据前会获取锁，确保线程串行（这样跟单线程还有区别吗。。。）</p></li><li><p>乐观锁认为线程安全问题不一定发生，所以不会无脑加锁；但是它会在更新数据时去判断有没有其他线程对数据进行修改（若未修改，其认为安全，就更新数据；若已修改，则认为可能出现了问题，就会进行重试或异常操作）</p></li></ul><h3 id="乐观锁的判断方法"><a href="#乐观锁的判断方法" class="headerlink" title="乐观锁的判断方法"></a>乐观锁的判断方法</h3><ul><li><p>基于版本号：每次修改都会改变版本号，每个线程拿自己手上的版本号来比较，如果版本号不一致就不会进行操作</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402070249223.png" alt="image-20240207024818818"></p><p>在本例子中，版本号可以和库存数进行简化嘛，大家下单就是为了争抢库存，所以直接拿库存数当版本号用即可，这样就是<strong>CAS法</strong>（Compare and Swap）</p><blockquote><p>这里扩展ABA问题，因为在其他场景下的不正确的CAS使用可能造成ABA问题；</p><p>简单来说，由于对版本的判断依赖于需要改变的值，这时就可能出现 进程1修改为A，进程2修改为B，进程3修改回A，对于又来进程4，你能说“版本”没有改变吗？</p><p>举个恶心的例子，沙漠中有一潭水，张三喝了一口，李四往里面撒了泡尿，喝的和尿的一样多，这样虽然水量没变，但你能说潭水没有变化吗，那新来的王五还该不该喝呢？（非常的新鲜，非常的美味，请全部端上来吧！）</p><p><u>提一嘴，上面的秒杀场景，由于这里的库存是递减的，所以不会产生ABA问题</u></p></blockquote></li></ul><p>我们按照上面的逻辑对秒杀代码进行修改，其实仅仅需要在查询数据库时加上对stock的判断即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.扣减库存</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">        .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">        .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="string">&quot;stock&quot;</span>,voucher.getStock())</span><br><span class="line">        .update();</span><br></pre></td></tr></table></figure><p>但是这样又产生了问题</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402080156017.png" alt="image-20240208015633891"></p><p>在经过了200个线程的秒杀后，异常率竟然达到接近90，查看数据库发现优惠券的库存甚至还没被卖完。这是什么情况？</p><p>这样生硬的使用乐观锁会出现一个问题，若你是前一百个到达服务器的请求，你不一定会得到你应得到的优惠券，因为你的“版本号”可能会因为收到其他线程操作的影响而失效，这样就会直接让你本应得到的优惠券落入别人的手里，而你只能重新提交请求或者灰溜溜的放弃。</p><p>这样的失败率也太高了！我们要进行修改，对于这里库存的情况，对于每个线程，我们只需要保证它在扣减库存时的库存&gt;1即可</p><blockquote><p>突然想到，会不会有多个语句同时进行gt的判断，导致超卖？</p><p>其实mybatis-plus会把下面的语句解析成mysql语句，显然会解析成一条update语句，而update语句又有排它锁，所以不存在两个事务同时修改数据的情况</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.扣减库存</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">        .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">        .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>)</span><br><span class="line">        .update();</span><br></pre></td></tr></table></figure><p>这下异常率达到50%了。当当！这样就轻松的解决秒杀问题了。。。吗？</p><p>仔细想想，这样本质上是借助了mysql的锁；但如果是在真实的业务中，让这么多的请求直接打到数据库，这样好吗。。。</p><h3 id="单例下的一人一单"><a href="#单例下的一人一单" class="headerlink" title="单例下的一人一单"></a>单例下的一人一单</h3><p>大额的秒杀券要修改成一人只能下一单</p><p>好像很简单，直接通过优惠券id和优用户id来查询优惠券订单数据库中有没有对应订单即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6.一人一单的判断</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line"><span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;已达到购买上限！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 5.一人一单的判断</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (userId.toString().intern())&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;已达到购买上限！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>)</span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        voucherOrder.setUserId(UserHolder.getUser().getId());</span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        <span class="built_in">this</span>.save(voucherOrder);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于需要先释放锁，再提交事务；如果按照上面的加锁的方法，当这个锁内的代码执行完毕后，其他线程也可以重新获得锁，然而这时候提交上去的事务可能未被执行，这样就达不到一人一单的效果了，所以需要将锁加到调用该函数的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"><span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">    <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">    <span class="comment">//如果直接按照下面的写法，会获取不到代理，造成事务失效</span></span><br><span class="line">    <span class="comment">//return createVoucherOrder(voucherId);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这下抢成功了</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402161436658.png" alt="image-20240216143624342"></p><p>至此完成了单例情况下的一人一单并发安全问题</p><h3 id="集群下的一人一单"><a href="#集群下的一人一单" class="headerlink" title="集群下的一人一单"></a>集群下的一人一单</h3><p>我们使用nginx进行负载均衡，然后再次进行下单接口的测试，发现两个后端的服务都收到了请求，没有被锁住。在集群部署的这种情况下，仍然会产生并发安全问题。</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402162220678.png" alt="image-20240216221955515"></p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>满足分布式或集群模式下多进程可见并且互斥的锁</p><h3 id="分布式锁的种类"><a href="#分布式锁的种类" class="headerlink" title="分布式锁的种类"></a>分布式锁的种类</h3><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402162243938.png" alt="image-20240216224310873"></p><h3 id="基于Redis的基础-的分布式锁"><a href="#基于Redis的基础-的分布式锁" class="headerlink" title="基于Redis的基础 的分布式锁"></a>基于Redis的基础 的分布式锁</h3><ul><li><p>获取锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET lock thread1 EX 10 NX 将获取锁和设置超时时间打包成事务</span><br><span class="line"></span><br><span class="line">// SETNX 获取锁</span><br><span class="line">// EXPIRE 设置锁的过期时间，避免服务宕机造成死锁</span><br></pre></td></tr></table></figure></li><li><p>释放锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEL key 删除锁</span><br><span class="line">或者在过期后自动释放</span><br></pre></td></tr></table></figure></li></ul><p>利用Redis实现一个锁对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisLock</span><span class="params">(StringRedisTemplate stringRedisTemplate, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">//获取线程标示</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">threadID</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadID + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在Impl里使用这个分布式的锁对象来判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建分布式锁对象</span></span><br><span class="line"><span class="type">RedisLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisLock</span>(stringRedisTemplate, <span class="string">&quot;voucherOrder&quot;</span> + userId);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.tryLock(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">    <span class="comment">// 获取锁失败</span></span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;请求过多，请稍后再试。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//获取代理对象（事务）</span></span><br><span class="line">    <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">    <span class="comment">//如果直接按照下面的写法，会获取不到代理，造成事务失效</span></span><br><span class="line">    <span class="comment">//return createVoucherOrder(voucherId);</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    redisLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就完成了基础的分布式锁</p><h4 id="改进的分布式锁"><a href="#改进的分布式锁" class="headerlink" title="改进的分布式锁"></a>改进的分布式锁</h4><p>如果正在执行的线程1出现了业务阻塞导致锁超时了被自动释放，然后线程2获取了刚刚被释放的锁，开始执行线程2的任务，这时候线程1终于完成了业务，它又释放了线程2获取的锁，这时候线程2还在执行；线程3趁虚而入，又上了个锁；这下乱套了</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402171121491.png" alt="image-20240217112124343"></p><p>这里要让每个线程只能释放自己加的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">threadID</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(threadID.equals(id))&#123;</span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="再次改进"><a href="#再次改进" class="headerlink" title="再次改进"></a>再次改进</h4><p>没想到吧，还有问题，上次是执行业务的过程中发生了阻塞，这次是在判断锁一直并的即将释放锁的时候发生了阻塞。</p><p>所以我们需要保持 判断锁是否一致 和 释放锁 这两个操作的原子性</p><p>这里需要使用到Redis的Lua脚本</p><h5 id="Redis的Lua脚本"><a href="#Redis的Lua脚本" class="headerlink" title="Redis的Lua脚本"></a>Redis的Lua脚本</h5><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;get&#x27;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>然后在RedisLock中调用lua脚本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">stringRedisTemplate.execute(UNLOCK_SCRIPT, Collections.singletonList(KEY_PREFIX+name),ID_PREFIX+Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>但是这样还不够完美</strong></p><p>基于setnx的分布式锁存在以下问题</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402172152734.png" alt="image-20240217215208608"></p><h3 id="使用redisson完成的分布式锁"><a href="#使用redisson完成的分布式锁" class="headerlink" title="使用redisson完成的分布式锁"></a>使用redisson完成的分布式锁</h3><ul><li><p>导入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.13</span><span class="number">.6</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://localhost:6379&quot;</span>).setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改之前的锁代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">       <span class="comment">// 创建分布式锁对象</span></span><br><span class="line"><span class="comment">//      RedisLock redisLock = new RedisLock(stringRedisTemplate, &quot;voucherOrder:&quot; + userId);</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;voucherOrder:&quot;</span> + userId);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        boolean isLock = redisLock.tryLock(1200);</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">            <span class="comment">// 获取锁失败</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;请求过多，请稍后再试。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//获取代理对象（事务）</span></span><br><span class="line">            <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">            <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">            <span class="comment">//如果直接按照下面的写法，会获取不到代理，造成事务失效</span></span><br><span class="line">            <span class="comment">//return createVoucherOrder(voucherId);</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Redisson可重入锁原理"><a href="#Redisson可重入锁原理" class="headerlink" title="Redisson可重入锁原理"></a>Redisson可重入锁原理</h4><p>使用哈希结构来加Redis锁，在删除锁的时候判断value的值</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402180011145.png" alt="image-20240218001110009"></p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402180027409.png" alt="image-20240218002747361"></p><h2 id="Redis优化秒杀"><a href="#Redis优化秒杀" class="headerlink" title="Redis优化秒杀"></a>Redis优化秒杀</h2><p>之前的秒杀还是要频繁地操作Mysql数据库，效率仍然较低</p><p>现在我们先把秒杀的热点数据存入Redis中备用，然后请求打进来直接先在Redis里处理；最后找一个合适的时机同步回数据库，这样就降低了Mysql数据库的访问量</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402182125245.png" alt="image-20240218210745226"></p><h3 id="基于消息队列优化"><a href="#基于消息队列优化" class="headerlink" title="基于消息队列优化"></a>基于消息队列优化</h3><p>这里跳过阻塞队列实现优化，直接使用消息队列来优化Redis异步秒杀</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202402191203177.png" alt="image-20240219120341072"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis秒杀&quot;&gt;&lt;a href=&quot;#Redis秒杀&quot; class=&quot;headerlink&quot; title=&quot;Redis秒杀&quot;&gt;&lt;/a&gt;Redis秒杀&lt;/h1&gt;&lt;h2 id=&quot;全局唯一ID&quot;&gt;&lt;a href=&quot;#全局唯一ID&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="知识笔记" scheme="https://hantoul.github.io/categories/%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Redis" scheme="https://hantoul.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>（JVM调优）GC调优</title>
    <link href="https://hantoul.github.io/2024/01/19/2024-1-19-JVM%E8%B0%83%E4%BC%98-GC%E8%B0%83%E4%BC%98/"/>
    <id>https://hantoul.github.io/2024/01/19/2024-1-19-JVM%E8%B0%83%E4%BC%98-GC%E8%B0%83%E4%BC%98/</id>
    <published>2024-01-19T12:43:23.000Z</published>
    <updated>2024-01-19T12:43:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h3><p>GC调优指的是对JVM的垃圾回收部分进行调优，其目标是避免由垃圾回收引起的程序性能下降；</p><p>其调优的核心分为三部分</p><ul><li>通用JVM参数的设置</li><li>特定垃圾回收期的JVM参数设置</li><li>解决频繁的Full GC造成的性能问题</li></ul><h4 id="GC调优的核心指标"><a href="#GC调优的核心指标" class="headerlink" title="GC调优的核心指标"></a>GC调优的核心指标</h4><ul><li>业务吞吐量：一段时间内程序需要完成的业务数量</li><li>垃圾回收吞吐量：CPU用于执行用户代码的时间与CPU总执行时间的比值</li><li>延迟：用户发起一个请求到收到相应之间经历的时间</li><li>内存使用量：Java程序占系统内存的最大值，在满足上面的指标的前提下，内存用量越少越好</li></ul><h4 id="GC调优的方法"><a href="#GC调优的方法" class="headerlink" title="GC调优的方法"></a>GC调优的方法</h4><p>GC调优与内存调优一样，也是分为 发现-&gt;诊断-&gt;修复-&gt;验证 四个阶段</p><h5 id="发现阶段"><a href="#发现阶段" class="headerlink" title="发现阶段"></a>发现阶段</h5><p>我们可以通过使用jstat工具，visualvm插件，Prometheus + Grafana，观察GC日志，GC Viewer工具，GCeasy工具来帮助我们发现问题</p><h5 id="诊断阶段"><a href="#诊断阶段" class="headerlink" title="诊断阶段"></a>诊断阶段</h5><h6 id="CG的正常情况"><a href="#CG的正常情况" class="headerlink" title="CG的正常情况"></a>CG的正常情况</h6><p>呈现锯齿状，对象创建后内存使用增加，在经过垃圾清理后大幅回落，且每次回收之后的使用内存大小接近，留存对象较少</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202401191645798.png" alt="image-20240119164533646"></p><h6 id="缓存对象过多的情况"><a href="#缓存对象过多的情况" class="headerlink" title="缓存对象过多的情况"></a>缓存对象过多的情况</h6><p>与正常情况类似，但是在清理后的内存占用仍然较高</p><p>原因：程序中保存了大量缓存对象（临时存储在内存中的数据），导致GC无法释放，可以使用MAT或者HeapHero等工具来具体分析原因</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202401191647726.png" alt="image-20240119164733678"></p><h6 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h6><p>呈现锯齿状，每次GC之后的内存使用一次比一次多，最后完全无法释放内存，导致OutOfMemory错误</p><p>原因：程序中保存了大量的内存泄露对象，导致GC之后无法释放，同样可以使用MAT或者HeapHero等工具来具体分析原因</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202401191648239.png" alt="image-20240119164853182"></p><h6 id="连续的Full-GC"><a href="#连续的Full-GC" class="headerlink" title="连续的Full GC"></a>连续的Full GC</h6><p>在某个时间点出现多次Full GC，CPU使用率拉满，无法处理用户请求，一段时间后恢复正常</p><p>原因：在该时间点请求量激增，程序开始产生大量对象，同时垃圾收集速度跟不上对象创建的速度，进而导致不断地Full GC</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202401191652825.png" alt="image-20240119165258778"></p><h6 id="元空间不足导致的Full-GC"><a href="#元空间不足导致的Full-GC" class="headerlink" title="元空间不足导致的Full GC"></a>元空间不足导致的Full GC</h6><p>发生该问题时，堆内存占用明明不高，可是还是不断的发生Full GC</p><p>原因：元空间大小不足，导致持续触发Full GC来回收元空间的数据</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202401191655451.png" alt="image-20240119165504389"></p><h5 id="修复阶段"><a href="#修复阶段" class="headerlink" title="修复阶段"></a>修复阶段</h5><p>下面介绍四种解决GC的手段，第四种方案仅建议在前三种方案无法解决时使用</p><h6 id="1-优化JVM参数"><a href="#1-优化JVM参数" class="headerlink" title="1.优化JVM参数"></a>1.优化JVM参数</h6><ul><li><p>参数1：<strong>-Xmx 和 -Xms</strong></p><p>-Xmx 设置的是最大堆内存，需要注意的是，计算可用内存时，需要将元数据、操作系统和其他软件占用的内存排除掉。eg：服务器内存4G，操作系统+元空间最大值+其它软件占用1.5G，-Xmx可以设置为2g。</p><p>-Xms 设置初始堆大小，这里建议将Xms和Xmx设置一样大，这样有以下优点</p><p>运行性能好（减少堆扩容导致的性能损耗），可用性好（与同在运行的其他程序抢占内存），启动速度快（GC次数少）</p><p><strong>最合理的设置方式应该是根据最大并发量估算服务器的配置，然后再根据服务器配置计算最大堆内存的值。</strong></p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202401191702489.png" alt="image-20240119170226451"></p></li><li><p><strong>-xx:MaxMetaspaceSize 和 -xx:MetaSpaceSice</strong></p><p>-XX:MaxMetaspaceSize=值 参数指的是最大元空间大小，默认值比较大，如果出现元空间内存泄漏会让操作系统可用内存不可控，建议根据测试情况设置最大值，一般设置为256m。</p><p>-XX:MetaspaceSize=值 参数指的是到达这个值之后会触发FULLGC（网上很多文章的初始元空间大小是错误的），后续什么时候再触发JVM会自行计算。如果设置为和MaxMetaspaceSize一样大，就不会FULLGC，但是对象也无法回收。</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202401191702687.png" alt="image-20240119170242650"></p></li><li><p><strong>-Xss</strong> 虚拟机栈大小</p><p>如果我们不指定栈的大小，JVM 将创建一个具有默认大小的栈。大小取决于操作系统和计算机的体系结构。</p></li><li><p>不建议手动设置的参数</p><ul><li><p>-Xmn 年轻代的大小；在设置这个值之前需要进行大量的计算，不建议手动修改。同时如果使用G1垃圾回收器，就尽量不要使用该值，因为G1会动态地调整年轻代的大小</p></li><li><p>‐XX:SurvivorRatio 伊甸园区和幸存者区的大小比例，默认值为8。</p></li><li><p>‐XX:MaxTenuringThreshold 最大晋升阈值，年龄大于此值之后，会进入老年代。JVM有动态年龄判断机制：将年龄从小到大的对象占据的空间加起来，如果大于survivor区域的50%，然后把等于或大于该年龄的对象，放入到老年代，所以也不建议修改</p></li></ul></li><li><p>其他参数</p><ul><li><p><strong>-XX:+DisableExplicitGC</strong></p><p>禁止在代码中使用System.gc()， System.gc()可能会引起FULLGC，在代码中尽量不要使用。使用DisableExplicitGC参数可以禁止使用System.gc()方法调用</p></li><li><p><strong>-XX:+HeapDumpOnOutOfMemoryError</strong>：发生OutOfMemoryError错误时，自动生成hprof内存快照文件。</p><p>-XX:HeapDumpPath=<path>：指定hprof文件的输出路径。</p></li><li><p>打印<strong>GC日志</strong></p><p>JDK8及之前 ： -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:文件路径</p><p>JDK9及之后 ： -Xlog:gc*:file=文件路径</p></li></ul></li><li><p>JVM参数模版</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-Xms1g</span><br><span class="line">-Xmx1g</span><br><span class="line">-Xss256k</span><br><span class="line">-XX:MaxMetaspaceSize=512m </span><br><span class="line">-XX:+DisableExplicitGC</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:HeapDumpPath=/opt/logs/my-service.hprof</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-Xloggc:文件路径</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>JDK9及之后gc日志输出修改为 -Xlog:gc*:file=文件名</p><p>堆内存大小和栈内存大小根据实际情况灵活调整。</p></blockquote></li></ul><h6 id="2-减少对象产生"><a href="#2-减少对象产生" class="headerlink" title="2.减少对象产生"></a>2.减少对象产生</h6><p>大多数场景下的FULLGC是由于对象产生速度过快导致的，减少对象产生可以有效的缓解FULLGC的发生</p><ul><li>对对象进行复用：重复创建和销毁对象会增加GC的负担。因此，可以尽量避免频繁创建和销毁对象，而是通过对象的复用来减少对象的产生。</li><li>使用对象池：对象池是一种缓存对象的机制。通过预先创建一定数量的对象，并将其保存在池中，当需要对象时，从池中获取，使用完毕后再放回池中。这样可以避免频繁创建和销毁对象，减少GC的压力。</li><li>及时释放对象引用：在对象不再使用时，及时将其引用置为null</li></ul><h6 id="3-更换垃圾回收器"><a href="#3-更换垃圾回收器" class="headerlink" title="3.更换垃圾回收器"></a>3.更换垃圾回收器</h6><ul><li><p>垃圾回收器的组合关系</p><p>由于垃圾回收器分为年轻代和老年代，所以除了G1以外的垃圾处理器需要根据年轻代和老年代进行成对组合的使用</p><p>关系图如下：</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202401192032340.png" alt="image-20240119203154232"></p></li></ul><p>可以通过测试不同组合在特定负载要求下的性能表现，找到适用的垃圾处理器</p><h6 id="4-优化垃圾回收器参数"><a href="#4-优化垃圾回收器参数" class="headerlink" title="4.优化垃圾回收器参数"></a>4.优化垃圾回收器参数</h6><p>尽量在前三种方法无效时再使用这种方法；具体需要根据产生性能问题的原因来进行针对性的排查。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/video/BV1r94y1b7eS?p=41&amp;vd_source=ccb7919bcde1355acd4bb39725e50302">黑马JVM虚拟机入门到实战</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;GC调优&quot;&gt;&lt;a href=&quot;#GC调优&quot; class=&quot;headerlink&quot; title=&quot;GC调优&quot;&gt;&lt;/a&gt;GC调优&lt;/h3&gt;&lt;p&gt;GC调优指的是对JVM的垃圾回收部分进行调优，其目标是避免由垃圾回收引起的程序性能下降；&lt;/p&gt;
&lt;p&gt;其调优的核心分为三部</summary>
      
    
    
    
    <category term="知识笔记" scheme="https://hantoul.github.io/categories/%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JVM" scheme="https://hantoul.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>（JVM调优）内存调优</title>
    <link href="https://hantoul.github.io/2024/01/18/2024-1-18-JVM%E8%B0%83%E4%BC%98-%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98/"/>
    <id>https://hantoul.github.io/2024/01/18/2024-1-18-JVM%E8%B0%83%E4%BC%98-%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98/</id>
    <published>2024-01-18T15:11:39.000Z</published>
    <updated>2024-01-18T15:11:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内存调优"><a href="#内存调优" class="headerlink" title="内存调优"></a>内存调优</h3><h4 id="什么是内存泄露"><a href="#什么是内存泄露" class="headerlink" title="什么是内存泄露"></a>什么是内存泄露</h4><p>Java中如果一个对象不再被使用，但他仍在GC ROOT的引用链上，根据之前提到的回收办法，他就不会被垃圾回收器回收，这就造成了内存泄露。内存泄漏往往发生在堆区。</p><h5 id="下面列举几个内存泄露的常见场景"><a href="#下面列举几个内存泄露的常见场景" class="headerlink" title="下面列举几个内存泄露的常见场景"></a>下面列举几个内存泄露的常见场景</h5><ul><li>在Java后端程序中处理完用户请求后未及时将用户数据删除，随着用户数据不断累积，造成堆内存溢出</li><li>进行分布式调度时被调度的应用在调度结束时出现了内存泄漏，多次调度后内存溢出</li></ul><h4 id="内存泄露的解决方案"><a href="#内存泄露的解决方案" class="headerlink" title="内存泄露的解决方案"></a>内存泄露的解决方案</h4><p>对于内存泄露，常常按照四步来解决</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202401182113766.png" alt="image-20240118211321699"></p><h5 id="发现问题阶段"><a href="#发现问题阶段" class="headerlink" title="发现问题阶段"></a>发现问题阶段</h5><p>常使用阿里开发的Arthas工具来对业务状态进行监看</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202401182116593.png" alt="image-20240118211600536"></p><p>而Prometheus+Grafana是企业中运维常用的监控方案</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202401182116889.png" alt="image-20240118211642843"></p><p>在使用上面的工具对堆内存状况进行监看，我们可以发现出现内存泄漏时，堆内存会出现明显异常</p><p><img src="https://hantou-picbed.oss-cn-hangzhou.aliyuncs.com/img/202401182117487.png" alt="image-20240118211749433"></p><h5 id="诊断阶段"><a href="#诊断阶段" class="headerlink" title="诊断阶段"></a>诊断阶段</h5><h6 id="原因1：-内存中的代码泄露"><a href="#原因1：-内存中的代码泄露" class="headerlink" title="原因1： 内存中的代码泄露"></a>原因1： 内存中的代码泄露</h6><ul><li><p>equals()和hashCode()的不正确使用，导致同一数据被保存多次</p></li><li><p>ThreadLocal的使用过程中未回收线程池中的线程；</p><p>线程方法执行完毕后，一定要调用ThreadLocal中的remove方法来清理对象</p></li><li><p>通过静态字段来保存对象，造成大量数据在静态变量中被引用，但又不被使用</p><p>尽量减少将对象长时间保存在静态变量中； 使用单例模式时，尽量使用懒加载； SpringBoot的Bean中不要长期存放大对象，若临时使用，设定过期时间定期失效</p></li><li><p>内部类引用外部类；<strong><u>非</u></strong>静态的内部类会默认持有外部类，虽然代码上没有使用外部类，但如果在别的地方使用了该静态内部类，会导致外部类也被引用，让他无法被回收，造成内存泄漏</p></li><li><p>String的intern方法被大量调用并保存导致内存泄漏</p></li><li><p>资源没有正常关闭；</p><p>在finally块中关闭不在使用的资源</p></li></ul><h6 id="原因2：-并发请求问题"><a href="#原因2：-并发请求问题" class="headerlink" title="原因2： 并发请求问题"></a>原因2： 并发请求问题</h6><p>用户在短时间内发来大量并发请求，导致处理数据的时间激增，导致大量数据堆积在内存中，造成内存溢出。</p><p>为了解决高并发请求造成的内存溢出，我们可以使用Jmeter进行并发测试，定位问题根源</p><h6 id="内存快照"><a href="#内存快照" class="headerlink" title="内存快照"></a>内存快照</h6><p>当内存溢出时，为了进行时候的分析与复盘，会将内存溢出时的整个堆内存保存下来，生成内存快照（Heap Profile）。我们可以使用MAT工具打开快照文件，并且选择内存泄漏检测，就可以自动分析数据定位内存泄漏根源</p><p>生成内存快照的JVM参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError：发生OutOfMemoryError错误时，自动生成hprof内存快照文件。</span><br><span class="line">-XX:HeapDumpPath=&lt;path&gt;：指定hprof文件的输出路径</span><br></pre></td></tr></table></figure><blockquote><p>MAT内存泄漏检测的原理 :</p><p>MAT就是根据支配树(如果所有指向B的路径都经过A，就认为A支配B，按这个判定方法生成支配树)，从叶子节点向根节点遍历，如果发现深堆的大小超过整个堆内存的一定比例阈值，就会将其标记成内存泄漏的“嫌疑对象”。</p></blockquote><h5 id="修复阶段"><a href="#修复阶段" class="headerlink" title="修复阶段"></a>修复阶段</h5><p>上面介绍了几种引发内存泄露的来源，对于他们，我们需要逐一分析</p><ul><li>对于<strong>代码</strong>中的内存泄露；在上一阶段中已经介绍并且提供了解决方案，这里不再赘述</li><li>对于因为<strong>参数不当</strong>而在高并发引起的内存溢出；需要调整参数，在下一章节GC调优中会详细介绍</li><li>对于因为<strong>设计不当</strong>而在高并发引起的内存溢出（比如拉取过大的数据库数据，线程池设计不当，消费者消费性能不足等）；需要对设计方案进行优化</li></ul><h5 id="验证阶段"><a href="#验证阶段" class="headerlink" title="验证阶段"></a>验证阶段</h5><p>对引发内存泄漏的问题进行修复后，我们就可以使用压测工具对之前引发内存泄露的场景进行复现，验证修复的可靠性</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/video/BV1r94y1b7eS?p=41&amp;vd_source=ccb7919bcde1355acd4bb39725e50302">黑马JVM虚拟机入门到实战</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;内存调优&quot;&gt;&lt;a href=&quot;#内存调优&quot; class=&quot;headerlink&quot; title=&quot;内存调优&quot;&gt;&lt;/a&gt;内存调优&lt;/h3&gt;&lt;h4 id=&quot;什么是内存泄露&quot;&gt;&lt;a href=&quot;#什么是内存泄露&quot; class=&quot;headerlink&quot; title=&quot;什么是</summary>
      
    
    
    
    <category term="知识笔记" scheme="https://hantoul.github.io/categories/%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JVM" scheme="https://hantoul.github.io/tags/JVM/"/>
    
  </entry>
  
</feed>
